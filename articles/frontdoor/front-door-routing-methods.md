---
title: Azure Front Door - トラフィック ルーティング方法 | Microsoft Docs
description: この記事では、Front Door で使用されるさまざまなトラフィック ルーティング方法について説明します
services: front-door
documentationcenter: ''
author: duongau
ms.service: frontdoor
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 09/10/2018
ms.author: duau
ms.openlocfilehash: d12eb67abbc216afb241fa6c5a9ef9c66e65040c
ms.sourcegitcommit: 5a3b9f35d47355d026ee39d398c614ca4dae51c6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/02/2020
ms.locfileid: "89399312"
---
# <a name="front-door-routing-methods"></a>Front Door ルーティング方法

Azure Front Door では、さまざまなサービス エンドポイントに HTTP/HTTPS トラフィックをルーティングする方法を決定するために、さまざまなトラフィック ルーティング方法をサポートしています。 Front Door に到達するクライアント要求ごとに、構成されているルーティング方法が適用されて、要求は最適なバックエンド インスタンスに確実に転送されます。 

Front Door で使用可能なトラフィック ルーティングには、4 つの主要な概念があります。

* **[[待機時間]](#latency):** 待機時間ベースのルーティングでは、感度の範囲内で許容される最低遅延のバックエンドに要求が送信されます。 基本的に、ユーザーの要求は、ネットワーク待機時間に関して "最も近い" バックエンドのセットに送信されます。
* **[[優先順位]](#priority):** すべてのトラフィックでプライマリ サービス バックエンドを使用したい場合、優先順位をそれぞれのバックエンドに割り当てることができ、プライマリまたはバックアップのバックエンドが使用可能ではない場合は、バックアップを提供できます。
* **[[重み付け]](#weighted):** 均等にまたは重み係数に従って一連のバックエンド間でトラフィックを分散する場合に、さまざまなバックエンドに重みを割り当てることができます。
* **[セッション アフィニティ](#affinity):** ユーザー セッションがまだアクティブであり、バックエンド インスタンスが正常性プローブに基づいてまだ正常と報告している間は、後続の要求を同じバックエンドに送信する場合は、フロントエンド ホストまたはドメインに対してセッション アフィニティを構成できます。 

Front Door のすべての構成には、バックエンドの正常性および自動即時グローバル フェールオーバーの監視が含まれます。 詳しくは、[Front Door Backend Monitoring](front-door-health-probes.md) (Front Door のバックエンド監視) に関するページをご覧ください。 Front Door は、単一のルーティング方法に基づき、アプリケーションのニーズに応じて動作するように構成するか、あるいは複数または全部のルーティング方法を組み合わせて使用して、最適なルーティング トポロジを構築することができます。

## <a name="lowest-latencies-based-traffic-routing"></a><a name = "latency"></a>最低遅延に基づくトラフィック ルーティング

世界中の複数の場所にバックエンドをデプロイすると、エンド ユーザーに "最も近い" 場所にトラフィックをルーティングすることで、多くのアプリケーションの応答性を向上させることができます。 Front Door の構成に対する既定のトラフィック ルーティング方法では、エンド ユーザーからの要求は、要求を受信した Front Door 環境から最も近いバックエンドに転送されます。 このアプローチを、Azure Front Door のエニーキャスト アーキテクチャと組み合わせると、各エンド ユーザーが、エンド ユーザーの場所に基づいて個人設定された最大限のパフォーマンスを得ることができます。

"最も近い" バックエンドは、必ずしも地理的な距離で最も近いとは限りません。 Front Door は、ネットワーク待機時間を測定することによって、最も近いバックエンドを決定します。 詳しくは、[Front Door's routing architecture](front-door-routing-architecture.md) (Front Door のルーティング アーキテクチャ) に関するページをご覧ください。 

全体的な決定の流れを次に示します。

| 使用可能なバックエンド | Priority | 待機時間シグナル (正常性プローブに基づく) | 重み |
|-------------| ----------- | ----------- | ----------- |
| 最初に、有効になっていて、正常性プローブに対して正常 (200 OK) を返すすべてのバックエンドを選択します。 たとえば、A、B、C、D、E、F の 6 つのバックエンドがあり、その中で C は異常、E は無効であるものとします。 したがって、使用可能なバックエンドのリストは、A、B、D、F です。  | 次に、使用可能なものの中で優先順位が最も高いバックエンドが選択されます。 たとえば、バックエンド A、B、D は優先順位 1、バックエンド F は優先順位 2 であるものとします。 この場合、選択されるバックエンドは A、B、D です。| 待機時間の範囲 (ミリ秒単位で指定された最小待機時間と待機時間感度) でバックエンドを選択します。 たとえば、要求が到着する Front Door 環境から A が 15 ミリ秒、B が 30 ミリ秒、D が 60 ミリ秒離れていて、待機時間感度が 30 ミリ秒の場合、最低遅延プールは A と B で構成されます。なぜなら、D は最も近いバックエンドつまり A から 30 ミリ秒より大きく離れているためです。 | 最後に、Front Door は、最終的に選択されたプールのバックエンドの間で、指定されている重みの比率を使用して、トラフィックをラウンドロビンします。 たとえば、バックエンド A の重みが 5、バックエンド B の重みが 8 であるとすると、トラフィックはバックエンド A と B に 5:8 の比率で分散されます。 |

>[!NOTE]
> 既定では、待機時間感度プロパティは 0 ミリ秒に設定されます。つまり、要求は常に利用可能な最速のバックエンドに転送されます。


## <a name="priority-based-traffic-routing"></a><a name = "priority"></a>優先順位に基づくトラフィック ルーティング

多くの場合、組織ではサービスの信頼性を提供したいと考えており、主要なサービスがダウンした場合に備えて 1 つ以上のバックアップ サービスをデプロイすることでこれを実行しています。 業界では、このトポロジはアクティブ/スタンバイまたはアクティブ/パッシブのデプロイ トポロジとも呼ばれます。 "優先順位" トラフィック ルーティング方法を使用すると、Azure ユーザーはこのフェールオーバー パターンを簡単に実装できます。

既定の Front Door には、優先順位が等しいバックエンドのリストが含まれています。 既定では、Front Door は優先順位が最も高い (最も小さい値) バックエンド、つまりバックエンドのプライマリ セットに対してのみ、トラフィックを送信します。 プライマリ バックエンドが使用できない場合、Front Door はバックエンドのセカンダリ セット (2 番目に小さい値) にトラフィックをルーティングします。 プライマリとセカンダリのどちらのエンドポイントも使用できない場合、トラフィックは 3 番目のバックエンドに送信されます。以降も同様です。 バックエンドの可用性は、構成されている状態 (有効または無効) と、正常性プローブによって決定される継続的なバックエンドの正常性状態に基づきます。

### <a name="configuring-priority-for-backends"></a>バックエンドの優先順位の構成

Front Door 構成内のバックエンド プールの各バックエンドは、"優先順位" と呼ばれるプロパティを持っていて、設定できる値は 1 から 5 です。 Azure Front Door では、各バックエンドのこのプロパティを使用して、バックエンドの優先順位を明示的に構成します。 このプロパティの値の範囲は、1 から 5 です。 値が小さいほど、優先順位が高くなります。 複数のバックエンドに同じ優先順位の値を設定できます。

## <a name="weighted-traffic-routing-method"></a><a name = "weighted"></a>重み付けトラフィック ルーティング方法
"重み付け" トラフィック ルーティング方法を使用すると、トラフィックを均等に分散したり、定義済みの重み付けを使用したりできます。

重み付けトラフィック ルーティング方式では、バックエンド プールの Front Door の構成で各バックエンドに重みを割り当てます。 重みは 1 から 1000 の整数です。 このパラメーターの既定の重みは "50" です。

(指定されている) 許容される待機時間感度内で使用可能なバックエンドのリストの間で、トラフィックは指定された重みの比率を使ってラウンドロビン方式で分散されます。 待機時間感度が 0 ミリ秒に設定されている場合、同じネットワーク待機時間のバックエンドが複数存在しない限り、このプロパティは反映されません。 

重み付け方式を使用することで、有用なシナリオをいくつか実現できます。

* **アプリケーションの段階的アップグレード**: 新しいバックエンドにルーティングするトラフィックのパーセンテージを割り当て、他のバックエンドと同等になるまで時間と共にトラフィックを徐々に増やします。
* **Azure へのアプリケーションの移行**: Azure と外部バックエンドの両方を含むバックエンド プールを作成します。 バックエンドの重みを調整して新しいバックエンドを優先します。 最初に新しいバックエンドを無効に設定し、次に最低の重みを割り当て、少しずつ増やしながらほとんどのトラフィックを受け取るレベルまで段階的に上げることができます。 最後に優先順位の低いバックエンドを無効にして、プールから削除します。  
* **追加容量のクラウド バースト**: Front Door の背後に配置することによって、オンプレミスのデプロイをクラウドにすばやく拡張します。 クラウドに追加容量が必要なとき、バックエンドを追加または有効にして、各バックエンドに送るトラフィックの割り当てを指定します。

## <a name="session-affinity"></a><a name = "affinity"></a>セッション アフィニティ
既定のセッション アフィニティが設定されていない状態では、Front Door は、同じクライアントから送信された要求を、負荷分散の構成に基づいて、特に、異なるバックエンドへの待機時間が変化したときや、同じユーザーからの異なる要求が別の Front Door 環境に到着した場合に、異なるバックエンドに転送します。 ただし、一部のステートフルなアプリケーションや、他の特定のシナリオでは、同じユーザーからの後続の要求は最初の要求を処理したのと同じバックエンドに届くのが望ましい場合があります。 Cookie ベースのセッション アフィニティ機能は、同じバックエンド上にユーザー セッションを保持する場合に便利です。 Front Door のマネージド Cookie を使用することにより、Azure Front Door は、バックエンドが正常であり、ユーザー セッションの有効期限が切れていない限り、ユーザー セッションからの後続のトラフィックを、同じバックエンドで処理されるように送ります。 

セッション アフィニティは、構成されているドメイン (またはサブドメイン) ごとに、フロントエンドのホスト レベルで有効にすることができます。 有効にすると、Front Door はユーザーのセッションに Cookie を追加します。 Cookie ベースのセッション アフィニティでは、Front Door は同じ IP アドレスの背後にある場合でも異なるユーザーを識別することができ、それにより異なるバックエンド間でトラフィックをより均等に分散できます。

現在 Front Door はセッション Cookie のみをサポートしているので、Cookie の有効期間はユーザーのセッションと同じです。 

> [!NOTE]
> パブリック プロキシは、セッション アフィニティを妨げる可能性があります。 これは、セッションを確立するには Front Door はセッション アフィニティ Cookie を応答に追加する必要がありますが、応答がキャッシュ可能な場合は、同じリソースを要求している他のクライアントの Cookie を妨害するので、これを行うことはできません。 これを防ぐため、バックエンドがキャッシュ可能な応答を送信する場合は、セッション アフィニティは確立**されません**。 セッションが既に確立されている場合は、バックエンドからの応答がキャッシュ可能であっても問題ありません。
> 応答に HTTP 304 状態コードが含まれて**いない限り**、セッション アフィニティは次の状況で確立されます。
> - 応答の ```Cache-Control``` ヘッダーにキャッシュを禁止する特定の値 ("private" や "no-store" など) が設定されている。
> - 応答に有効期限が切れていない ```Authorization``` ヘッダーが含まれる。
> - 応答に HTTP 302 状態コードが含まれている。

## <a name="next-steps"></a>次のステップ

- [フロント ドアの作成](quickstart-create-front-door.md)方法について学習します。
- [Front Door のしくみ](front-door-routing-architecture.md)について学習します。
