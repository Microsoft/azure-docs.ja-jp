---
title: Queue storage のパフォーマンスとスケーラビリティのチェックリスト - Azure Storage
description: 高パフォーマンスのアプリケーションを開発する際に Queue storage で使用する実証済みプラクティスのチェックリスト。
services: storage
author: tamram
ms.service: storage
ms.topic: overview
ms.date: 10/10/2019
ms.author: tamram
ms.subservice: queues
ms.custom: devx-track-csharp
ms.openlocfilehash: 3b9aadf7d9cd27763cafb878d0b35d13a140a304
ms.sourcegitcommit: 419cf179f9597936378ed5098ef77437dbf16295
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/27/2020
ms.locfileid: "89008405"
---
# <a name="performance-and-scalability-checklist-for-queue-storage"></a>Queue storage のパフォーマンスとスケーラビリティのチェックリスト

Microsoft は、Queue storage を使用して高パフォーマンス アプリケーションを開発するための多数の実証済みプラクティスを開発してきました。 このチェックリストでは、パフォーマンスを最適化するために開発者が従うことのできる主要なプラクティスを示します。 アプリケーションを設計している間、およびプロセス全体を通して、これらのプラクティスに留意してください。

Azure Storage には、容量、トランザクション レート、および帯域幅についてスケーラビリティとパフォーマンスのターゲットがあります。 Azure Storage のスケーラビリティ ターゲットの詳細については、「[Standard Storage アカウントのスケーラビリティとパフォーマンスのターゲット](../common/scalability-targets-standard-account.md?toc=%2fazure%2fstorage%2fqueues%2ftoc.json)」および「[Queue storage のスケーラビリティとパフォーマンスのターゲット](scalability-targets.md)」を参照してください。

## <a name="checklist"></a>チェック リスト

この記事では、パフォーマンスに関する実証済みプラクティスを、Queue storage アプリケーションの開発中に従うことのできるチェックリストにまとめています。

| 完了 | カテゴリ | 設計上の考慮事項 |
| --- | --- | --- |
| &nbsp; |スケーラビリティ ターゲット |[使用するストレージ アカウントの数が最大数以下になるようにアプリケーションを設計できますか?](#maximum-number-of-storage-accounts) |
| &nbsp; |スケーラビリティ ターゲット |[容量とトランザクションの制限に近づかないようにしていますか?](#capacity-and-transaction-targets) |
| &nbsp; |ネットワーク |[クライアント側のデバイスは、必要なパフォーマンスを達成するのに十分な高帯域幅と低遅延を備えていますか?](#throughput) |
| &nbsp; |ネットワーク |[クライアント側のデバイスには、高品質のネットワーク リンクがありますか?](#link-quality) |
| &nbsp; |ネットワーク |[クライアント アプリケーションは、ストレージ アカウントと同じリージョンにありますか?](#location) |
| &nbsp; |クライアントへの直接アクセス |[Shared Access Signature (SAS) とクロスオリジン リソース共有 (CORS) を使用して、Azure Storage への直接アクセスを有効にしていますか?](#sas-and-cors) |
| &nbsp; |.NET 構成 |[最適なパフォーマンスを実現するために .NET Core 2.1 以降を使用していますか?](#use-net-core) |
| &nbsp; |.NET 構成 |[十分な数のコンカレント接続を使用するようにクライアントを構成していますか?](#increase-default-connection-limit) |
| &nbsp; |.NET 構成 |[.NET アプリケーションの場合、十分な数のスレッドを使用するように .NET を構成しましたか?](#increase-minimum-number-of-threads) |
| &nbsp; |Parallelism |[クライアントの機能に過剰な負荷を掛けたり、スケーラビリティ ターゲットに近づいたりしないように、並列処理が適切に制限されていることを確認しましたか?](#unbounded-parallelism) |
| &nbsp; |ツール |[Microsoft が提供する最新バージョンのクライアント ライブラリとツールを使用していますか?](#client-libraries-and-tools) |
| &nbsp; |[再試行の回数] |[エクスポネンシャル バックオフを使ってエラーとタイムアウトを調整する再試行ポリシーを使用していますか?](#timeout-and-server-busy-errors) |
| &nbsp; |[再試行の回数] |[再試行できないエラーに対するアプリケーションの再試行を回避していますか?](#non-retryable-errors) |
| &nbsp; |構成 |[小さな要求のパフォーマンスを上げるために、Nagle アルゴリズムをオフにしていますか?](#disable-nagle) |
| &nbsp; |メッセージ サイズ |[キューのパフォーマンスが向上するようにメッセージをコンパクトにしていますか?](#message-size) |
| &nbsp; |一括取得 |[1 回の GET 操作で複数のメッセージを取得していますか?](#batch-retrieval) |
| &nbsp; |ポーリング頻度 |[アプリケーションの知覚可能な遅延を減らすために、ポーリング頻度は十分ですか?](#queue-polling-interval) |
| &nbsp; |更新メッセージ |[エラー発生時にメッセージ全体の再処理が必要になる事態を回避するために、メッセージ更新操作を使用してメッセージ処理中の進捗を格納していますか?](#use-update-message) |
| &nbsp; |アーキテクチャ |[キューを使用して、クリティカル パスから長期間のワークロードを外し、アプリケーション全体の拡張性を高めて、その後、個別に規模を設定していますか?](#application-architecture) |

## <a name="scalability-targets"></a>スケーラビリティ ターゲット

運用中のアプリケーションがいずれかのスケーラビリティ ターゲットに近づいたり超過したりすると、トランザクション待機時間や調整が増加することがあります。 Azure Storage によってアプリケーションが調整されると、サービスが 503 (サーバー ビジー) または 500 (操作タイムアウト) のエラー コードを返し始めます。 スケーラビリティ ターゲットの制限内にとどまることでこれらのエラーを回避することは、アプリケーションのパフォーマンスを強化するうえで重要な部分です。

Queue サービスのスケーラビリティ ターゲットの詳細については、[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット](/azure/storage/queues/scalability-targets#scale-targets-for-queue-storage)に関するページを参照してください。

### <a name="maximum-number-of-storage-accounts"></a>ストレージ アカウントの最大数

特定のサブスクリプションとリージョンの組み合わせについて許容されるストレージ アカウントの最大数に近づいてきた場合に、複数のストレージ アカウントを使用したシャード化により、イングレス、エグレス、1 秒あたりの I/O 操作 (IOPS)、または容量を増やすことがあります。 このシナリオでは、ワークロードに必要なストレージ アカウントの数を減らすために、可能であればストレージ アカウントの制限を引き上げることをお勧めします。 [Azure サポート](https://azure.microsoft.com/support/options/)に連絡して、ストレージ アカウントの制限の引き上げをご依頼ください。 詳細については、「[ストレージ アカウントの制限引き上げを発表](https://azure.microsoft.com/blog/announcing-larger-higher-scale-storage-accounts/)」を参照してください。

### <a name="capacity-and-transaction-targets"></a>容量とトランザクションのターゲット

アプリケーションが 1 つのストレージ アカウントに対するスケーラビリティ ターゲットに接近している場合は、次の方法のいずれかを検討し、適用します。  

- キューのスケーラビリティ ターゲットがアプリケーションにとって十分でない場合は、複数のキューを使用してメッセージを分散させる必要があります。
- 対象のアプリケーションでスケーラビリティ ターゲットに対する接近や超過を引き起こしたワークロードを見直します。 設計を変更して、必要な帯域幅や処理能力を抑えたり、トランザクションを減らしたりすることができないでしょうか?
- アプリケーションがいずれかのスケーラビリティ ターゲットを超過することがほぼ確実な場合には、複数のストレージ アカウントを作成し、それらのアカウントにアプリケーション データを分けて配置します。 このパターンを使用する場合は、後で負荷分散用のストレージ アカウントを追加できるようにアプリケーションを設計してください。 ストレージ アカウント自体では、データ保存、トランザクション実行、データ転送以外の使用に料金が発生することはありません。
- アプリケーションが帯域幅ターゲットに近づいてきた場合は、クライアント側でデータを圧縮し、Azure Storage へのデータ送信に必要な帯域幅を削減する方法を検討します。
    データを圧縮することにより帯域幅の節約とネットワーク パフォーマンスの改善が期待できますが、パフォーマンスにマイナスの影響が及ぶ可能性もあります。 クライアント側でデータの圧縮と展開の処理要件が増加することにより生じるパフォーマンスへの影響を評価してください。 圧縮データを格納すると、標準ツールではデータが見づらくなるため、トラブルシューティングが困難になる場合があることに留意してください。
- アプリケーションがスケーラビリティ ターゲットに近づいている場合は、再試行にエクスポネンシャル バックオフを使用していることを確認してください。 この記事に書かれている推奨事項を実践して、スケーラビリティ ターゲットへの到達を回避することを強くお勧めします。 ただし、再試行にエクスポネンシャル バックオフを使用するとアプリケーションの迅速な再試行が妨げられ、調整が悪化する可能性もあります。 詳細については、「[タイムアウト エラーとサーバー ビジー エラー](#timeout-and-server-busy-errors)」セクションを参照してください。

## <a name="networking"></a>ネットワーク

アプリケーションの物理ネットワークの制約がパフォーマンスに大きな影響を及ぼすことがあります。 以降のセクションでは、ユーザーが遭遇する可能性のあるいくつかの制限について説明します。  

### <a name="client-network-capability"></a>クライアントのネットワーク機能

ネットワーク リンクの帯域幅と接続品質は、アプリケーションのパフォーマンスに重要な役割を果たします。以降のセクションでは、この点について説明しています。

#### <a name="throughput"></a>スループット

帯域幅については、多くの場合にクライアントの処理能力が問題になります。 大きい Azure インスタンスは、処理能力の高い NIC を使用します。そのため、1 台のコンピューターのネットワーク制限を引き上げる必要がある場合は、大きなインスタンスを使用するか VM の数を増やすことを検討してください。 オンプレミスのアプリケーションから Azure Storage にアクセスする場合にも、同じ法則が当てはまります。クライアント デバイスのネットワーク性能と、Azure Storage の場所へのネットワーク接続を把握し、それらを必要に応じて増強するか、それぞれの性能の範囲内でアプリケーションが稼働するように設計してください。

#### <a name="link-quality"></a>接続品質

他のネットワーク運用と同様に、エラーやパケット損失が生じるネットワーク状態では、遅延が生じて有効なスループットが損なわれることに留意してください。  WireShark または NetMon は、この問題の診断に有用です。  

### <a name="location"></a>場所

分散型環境では、サーバーの近くにクライアントを配置すると、パフォーマンスが最大になります。 最小限の遅延で Azure Storage にアクセスするには、同じ Azure リージョン内にクライアントを配置するのが最適です。 たとえば、Azure Storage を使用する Azure Web アプリを 1 つ保有している場合は、その両方を単一のリージョン内に配置します (たとえば、米国西部や東南アジア)。 リソースを併置することにより待ち時間が短縮され、コストが低下します。1 つのリージョン内での帯域幅使用は無料であるためです。  

Azure 内にホストされていないクライアント アプリケーション (モバイル デバイス アプリやオンプレミスのエンタープライズ サービスなど) が Azure Storage にアクセスする場合、それらのクライアントに近いリージョンにストレージ アカウントを配置することで待ち時間が短くなる可能性があります。 クライアントが広範囲に分散されている場合 (一部が北米に、一部がヨーロッパに存在する場合など) は、ストレージ アカウントをリージョンごとに 1 つ使用することを検討します。 アプリケーションが保存するデータが個々のユーザーに固有であり、ストレージ アカウント間でデータをレプリケーションする必要がなければ、導入しやすい方法です。

## <a name="sas-and-cors"></a>SAS と CORS

ユーザーの Web ブラウザーや携帯電話アプリで実行されている JavaScript などのコードが Azure Storage 内のデータにアクセスするのを承認する必要があるとします。 1 つの方法として、プロキシとして動作するサービス アプリケーションを作成することが考えられます。 このサービスに対してユーザーのデバイスが認証を行うと、Azure Storage リソースへのアクセスがそのサービスによって承認されるというものです。 この方法では、安全でないデバイスにストレージ アカウント キーを知らせずに済みます。 しかし、この方法では、サービス アプリケーションに大きなオーバーヘッドが生じます。ユーザーのデバイスと Azure Storage との間で転送されるデータがすべてそのサービス アプリケーションを通過することになるためです。

Shared Access Signature (SAS) を使用すると、サービス アプリケーションを Azure Storage のプロキシとして用いることを回避できます。 SAS を使用すれば、ユーザーのデバイスから制限付きアクセス トークンを使って、Azure Storage に直接要求を実行できるようになります。 たとえば、ユーザーがアプリケーションに写真をアップロードしたい場合に、サービス アプリケーションで SAS を生成してユーザーのデバイスに送信することが考えられます。 Azure Storage リソースへの書き込みアクセス許可を SAS トークンで与えることが可能です。アクセス許可には期間が指定され、その期間を過ぎると SAS トークンの有効期限が切れます。 SAS の詳細については、「[Shared Access Signatures (SAS) を使用して Azure Storage リソースへの制限付きアクセスを許可する](../common/storage-sas-overview.md)」を参照してください。  

通常、あるドメイン上の Web サイトにホストされているページの JavaScript が、他のドメインに対して特定の操作 (書き込みなど) を実行することは、Web ブラウザーによって許可されません。 このポリシーは "同一オリジン ポリシー" と呼ばれ、ページ上の悪意のあるスクリプトが別の Web ページ上のデータにアクセスすることを阻止するものです。 ただし、クラウドのソリューションを構築するときには、同一オリジン ポリシーが制限になることがあります。 クロスオリジン リソース共有 (CORS) はブラウザーの機能です。ソース ドメインで生成された要求が信頼済みであることをターゲット ドメインがブラウザーに伝達できます。

たとえば、Azure で実行されている Web アプリケーションが Azure Storage アカウントにリソースを要求するとします。 Web アプリケーションがソース ドメインで、ストレージ アカウントがターゲット ドメインです。 任意の Azure Storage サービスに対して CORS を構成して、ソース ドメインからの要求が Azure Storage によって信頼されていることを Web ブラウザーに伝えることができます。 CORS の詳細については、「[Azure Storage でのクロスオリジン リソース共有 (CORS) のサポート](/rest/api/storageservices/Cross-Origin-Resource-Sharing--CORS--Support-for-the-Azure-Storage-Services)」を参照してください。  
  
SAS と CORS はどちらも、Web アプリケーションに対する不要な負荷をなくす効果があります。  

## <a name="net-configuration"></a>.NET 構成

このセクションでは、.NET Framework を使用してパフォーマンスの大幅な向上を図る場合に利用できる簡単な構成を示します。  他の言語を使用する場合は、その言語に類似の概念がないか確認してください。  

### <a name="use-net-core"></a>.NET Core を使用する

強化されたパフォーマンスを活かすために、Azure Storage アプリケーションは .NET Core 2.1 以降で開発してください。 可能であれば、.NET Core 3.x の使用をお勧めします。

.NET Core のパフォーマンス強化の詳細については、次のブログ記事を参照してください。

- [.NET Core 3.0 のパフォーマンス向上](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/)
- [.NET Core 2.1 のパフォーマンス向上](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/)

### <a name="increase-default-connection-limit"></a>既定の接続数の上限を引き上げる

.NET の次のコードは、既定の接続数の上限 (通常、クライアント環境では 2、サーバー環境では 10) を 100 に増やします。 一般的に、この値はアプリケーションが使用するおおよそのスレッド数に設定します。  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

接続数の上限は、接続を開始する前に設定してください。  

他のプログラミング言語については、対象の言語のドキュメントで接続数の上限の設定方法を確認してください。  

詳細については、ブログ記事「[Web Services:Concurrent Connections (Web サービス: コンカレント接続数)](https://blogs.msdn.microsoft.com/darrenj/2005/03/07/web-services-concurrent-connections/)」を参照してください。  

### <a name="increase-minimum-number-of-threads"></a>スレッドの最小数を増やす

同期呼び出しを非同期タスクと共に使用している場合、スレッド プールのスレッド数を増やしたい場合があります。

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

詳細については、[ThreadPool.SetMinThreads](/dotnet/api/system.threading.threadpool.setminthreads) メソッドを参照してください。  

## <a name="unbounded-parallelism"></a>無制限の並列処理

並列処理はパフォーマンスという観点では非常に有用ですが、無制限の並列処理を使用する場合には、スレッド数や並列要求数に対して適用される制限がなくなることになるので、注意が必要です。 同じストレージ アカウント内の複数のパーティションにアクセスする状況や、同じパーティション内の複数の項目にアクセスする状況では、データをアップロードまたはダウンロードするための並列要求の数を制限するようにしてください。 並列処理が無制限の場合、アプリケーションはクライアント デバイスの処理能力やストレージ アカウントのスケーラビリティ ターゲットを超過することがあり、その結果、待ち時間や調整時間が長くなります。  

## <a name="client-libraries-and-tools"></a>クライアント ライブラリとツール

パフォーマンスを最大限に引き出すためには必ず、Microsoft から提供される最新のクライアント ライブラリとツールを使用してください。 Azure Storage のクライアント ライブラリは、さまざまな言語に対応しています。 また、Azure Storage は PowerShell と Azure CLI をサポートします。 Microsoft はパフォーマンスに留意してこれらのクライアント ライブラリとツールを積極的に開発し、最新のサービス バージョンに遅れることなく対応して、数多くのパフォーマンスの実証済みプラクティスを内部で確実に処理できるように取り組んでいます。 詳細については、[Azure Storage のリファレンス ドキュメント](/azure/storage/#reference)を参照してください。

## <a name="handle-service-errors"></a>サービス エラーの処理

サービスが要求を処理できない場合、Azure Storage からエラーが返されます。 特定のシナリオで Azure Storage から返される可能性のあるエラーについての知識は、パフォーマンスを最適化するうえで役立ちます。

### <a name="timeout-and-server-busy-errors"></a>タイムアウト エラーとサーバー ビジー エラー

アプリケーションがスケーラビリティの限界に近づくと、アプリケーションに対して Azure Storage による調整が発生することがあります。 場合によっては、なんらかの一時的な状態によって、Azure Storage が要求を処理できなくなることもあります。 どちらのケースでも、サービスからは 503 (サーバー ビジー) または 500 (タイムアウト) エラーが返されます。 スループットを高めるためにデータ パーティションがサービスによって再調整されている場合にも、これらのエラーが発生することがあります。 通常、クライアント アプリケーションは、そうしたエラーを引き起こしている操作を再試行する必要があります。 しかし、スケーラビリティ ターゲットを超過しているためにアプリケーションに Azure Storage による調整が発生しているなど、なんらかの理由でサービスが要求を処理できない場合、積極的に再試行を実行すると問題が悪化することがあります。 再試行ポリシーにはエクスポネンシャル バックオフを使用することをお勧めします。エクスポネンシャル バックオフは、クライアント ライブラリの既定の動作にもなっています。 この動作では、たとえば、アプリケーションが再試行する間隔を、2 秒後、4 秒後、10 秒後、30 秒後と延ばしていき、最終的に再試行を取りやめます。 そうすれば、調整が起こって動作が悪化することなく、サービスに対するアプリケーションの負荷を大幅に軽減できます。  

接続エラーは、調整の結果ではなく、一時的な問題と予想されるので、直後に再試行を実行してかまいません。  

### <a name="non-retryable-errors"></a>再試行できないエラー

クライアント ライブラリは、再試行できるエラーとできないエラーを認識して再試行を処理します。 ただし、Azure Storage REST API を直接呼び出している場合は、再試行すべきではないエラーも一部存在します。 たとえば、400 (正しくない要求) エラーは、クライアント アプリケーションから送信された要求が想定外の形式であったために処理できなかったことを示しています。 この要求を再送信しても、毎回同じ応答が返されることになるので、再試行は無意味です。 Azure Storage REST API を直接呼び出している場合は、どのようなエラーが生じる可能性があるか、また、それらを再試行すべきかどうかを意識するようにしてください。

Azure Storage のエラー コードの詳細については、「[状態コードとエラー コード](/rest/api/storageservices/status-and-error-codes2)」を参照してください。

## <a name="disable-nagle"></a>Nagle の無効化

Nagle のアルゴリズムは、ネットワーク パフォーマンスを向上させる方法として、TCP/IP ネットワークで広く使用されています。 しかし、すべての状況に適しているわけではありません (高度な対話形式の環境などには不向き)。 Nagle のアルゴリズムは Azure Table service に対する要求のパフォーマンスにマイナスの影響を及ぼすため、可能な場合は無効にしてください。

## <a name="message-size"></a>メッセージ サイズ

メッセージ サイズが増加すると、キューのパフォーマンスとスケーラビリティが低下します。 メッセージには、受信者が必要な情報のみを含めてください。  

## <a name="batch-retrieval"></a>一括取得

1 回の操作でキューから最大 32 個のメッセージを取得できます。 一括取得により、クライアント アプリケーションとのラウンドトリップの数を減らすことができます。これは、モバイル デバイスなどの待ち時間が長い環境では特に有用です。  

## <a name="queue-polling-interval"></a>キューのポーリング間隔

多くのアプリケーションはキューからメッセージをポーリングします。キューは、そのアプリケーションにとって最大のトランザクション ソースの 1 つです。 ポーリング間隔を適切に選択します。ポーリング頻度が高すぎると、アプリケーションはキューのスケーラビリティ ターゲットに近づく可能性があります。 ただし、200,000 トランザクションあたり 0.01 ドル (記事の執筆時点) で、1 つのプロセッサが 1 か月間 1 秒に 1 回ポーリングする場合、そのコストは 15 セントにも満たないため、通常、コストはポーリング間隔の選択に影響を与える要因ではありません。  

最新のコストの情報については、「 [Azure Storage 料金](https://azure.microsoft.com/pricing/details/storage/)」をご覧ください。  

## <a name="use-update-message"></a>メッセージ更新の使用

**メッセージ更新**操作を使用すると、非表示タイムアウトを長くしたり、メッセージの状態情報を更新したりすることができます。 ジョブの各ステップが完了するごとに次のキューにジョブを渡すワークフローよりも、**メッセージ更新**を使用した方がはるかに効率的です。 アプリケーションは、ジョブの各ステップが完了するたびに次のステップのメッセージを再キューイングするのではなく、ジョブ状態をメッセージに保存して、処理を継続することができます。 各**メッセージ更新**操作はスケーラビリティ ターゲットにカウントされることに留意してください。

## <a name="application-architecture"></a>アプリケーションのアーキテクチャ

アプリケーション アーキテクチャのスケーラビリティを確保するには、キューを使用します。 以下のリストは、キューを使用して、アプリケーションの拡張性を高めるための方法を示しています。  

- キューを使用して、処理に関する作業のバックログを作成し、アプリケーションのワークロードを平滑化するために利用できます。 たとえば、アップロード済み画像のサイズ変更など、プロセッサの負荷が高い作業の要求をキューに残しておくことができます。
- キューを使用して、アプリケーションの一部を切り離し、個別に拡張することができます。 たとえば、Web フロントエンドがユーザーから得られた調査結果をキューに配置し、将来の解析とストレージに活用できます。 必要に応じて、キュー データを処理する worker ロール インスタンスを追加できます。  

## <a name="next-steps"></a>次のステップ

- [Queue storage のスケーラビリティとパフォーマンスのターゲット](scalability-targets.md)
- [標準ストレージ アカウントのスケーラビリティとパフォーマンスのターゲット](../common/scalability-targets-standard-account.md?toc=%2fazure%2fstorage%2fqueues%2ftoc.json)
- [状態コードとエラー コード](/rest/api/storageservices/Status-and-Error-Codes2)
