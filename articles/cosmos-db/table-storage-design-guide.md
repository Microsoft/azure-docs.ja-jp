---
title: スケーリングとパフォーマンスのために Azure Cosmos DB テーブルを設計する
description: Azure Table storage の設計ガイドAzure Cosmos DB と Azure Table storage の、スケーラビリティとパフォーマンスに優れたテーブル
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: how-to
ms.date: 06/19/2020
author: sakash279
ms.author: akshanka
ms.custom: seodec18, devx-track-csharp
ms.openlocfilehash: 05a469dbeb093c41b45be278aec42cc930223c72
ms.sourcegitcommit: 419cf179f9597936378ed5098ef77437dbf16295
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/27/2020
ms.locfileid: "89002178"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Azure Table storage のテーブル設計ガイド:スケーラビリティとパフォーマンスに優れたテーブル

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

スケーラビリティとパフォーマンスに優れたテーブルを設計するには、コストを含むさまざまな要因を考慮する必要があります。 過去にリレーショナル データベースのスキーマを設計した経験がある方なら、こうした考慮事項はご存じであると思われます。 しかし、Azure Table storage とリレーショナル モデルにはいくつかの類似点がある一方で、重要な違いも多数あります。 こうした相違点は、リレーショナル データベースの扱いに慣れた方には直感的にわかりづらかったり、扱いづらかったりする設計につながりがちですが、Table storage などの NoSQL キー/値ストアを設計する場合には好都合です。

Table storage は、何十億ものデータ エンティティ (リレーショナル データベースの用語では "行") が含まれることがあるクラウド規模のアプリケーションをサポートするために、あるいは、大量のトランザクションをサポートしなければならないデータセットのために設計されています。 したがって、データの格納方法について考え方を変え、Table storage の動作方法を理解する必要があります。 NoSQL データ ストアを適切に設計すれば、リレーショナル データベースを使うソリューションよりも、ソリューションのスケーラビリティが大幅に高まります (また、コストも抑えられます)。 このガイドでは、これらのトピックについて説明します。  

## <a name="about-azure-table-storage"></a>Azure Table storage について
このセクションでは、パフォーマンスとスケーラビリティを重視した設計に関連する Table storage の主要機能を取り上げます。 初めて Azure Storage と Table storage を利用する場合は、[Microsoft Azure Storage の概要](../storage/common/storage-introduction.md)および [.NET を使用した Azure Table storage の概要](table-storage-how-to-use-dotnet.md)に関する記事を参照してから、この記事を読み進めてください。 このガイドで主に取り上げるのは Table storage ですが、Azure Queue storage と Azure BLOB ストレージについて、また、それらをソリューションで Table storage と共に使用する方法についても説明します。  

Table storage では、表形式を使用してデータを格納します。 各エンティティは、それ自体を一意に識別するためのキーのペアと、Table サービスがエンティティの最終更新日時をトラッキングするためのタイムスタンプ列を持ちます (エンティティの更新は自動的に行われます。 すべてのエンティティには、エンティティを一意に識別するキーと、エンティティの最終更新時を追跡するために Table storage が使用するタイムスタンプ列のペアがあります。 タイムスタンプ フィールドは自動的に追加されます。タイムスタンプを手動で任意の値に上書きすることはできません。 Table storage では、この最終更新日時のタイムスタンプ (LMT) を使ってオプティミスティック コンカレンシーを管理します。  

> [!NOTE]
> Table storage REST API 操作により、LMT から派生する `ETag` 値も返されます。 このドキュメントでは、ETag と LMT という用語が区別なく使用されます。基となる同じデータを表しているためです。  
> 
> 

次の例は、従業員と部署のエンティティを格納する、シンプルなテーブル設計を示しています。 このガイドで後述する例の多くは、このシンプルな設計が基になっています。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>マーケティング</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>マーケティング</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>6 月</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>マーケティング</td>
<td>部署</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>マーケティング</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>売上</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


これまでは、この設計はリレーショナル データベースのテーブルに似ています。 重要な違いは、必須の列と、同じテーブルに複数のエンティティの種類を格納できることです。 さらに、**FirstName** や **Age** などのユーザー定義プロパティには、リレーショナル データベース内の列のように、整数や文字列などのデータ型があります。 ただし、リレーショナル データベースとは違って、Table storage にはスキーマがないため、エンティティごとにプロパティのデータ型は同じである必要はありません。 1 つのプロパティに複雑なデータ型を格納するには、JSON や XML などのシリアル化された形式を使う必要があります。 詳細については、[Table storage のデータ モデルの理解](https://msdn.microsoft.com/library/azure/dd179338.aspx)に関する記事を参照してください。

`PartitionKey` と `RowKey` の選択は優れたテーブル設計の基礎です。 テーブルに格納されている各エンティティは、`PartitionKey` と `RowKey` の一意の組み合わせである必要があります。 リレーショナル データベース テーブル内のキーと同様に、`PartitionKey` と `RowKey` の値には、高速検索を可能にするクラスター化インデックスを作成するためのインデックスが作成されています。 ただし、Table storage ではセカンダリ インデックスは作成されないため、インデックスが作成されるプロパティはこれら 2 つだけです (後で説明するパターンの一部は、この明白な制限を回避する方法を示しています)。  

テーブルは 1 つ以上のパーティション から構成されており、設計に関する決定事項の多くは、ソリューションを最適化するために適切な `PartitionKey` と `RowKey` を選択することになります。 ソリューションは、すべてのエンティティがパーティションを使って整理された 1 つのテーブルだけでも構成できますが、通常は複数のテーブルが含まれます。 テーブルは、エンティティを論理的に整理するために、またアクセス制御リストを使用してデータへのアクセスを管理するために役立ちます。 1 つのストレージ操作を使用してテーブル全体を削除できます。  

### <a name="table-partitions"></a>テーブルのパーティション
アカウント名、テーブル名、`PartitionKey` を組み合わせて、Table storage がエンティティを格納するストレージ サービス内のパーティションを特定します。 パーティションは、エンティティのアドレス指定スキームの一部であると同時に、トランザクションのスコープを定義し (この記事内の「[エンティティ グループ トランザクション](#entity-group-transactions)」を参照)、Table storage のスケーリング方法の基礎を形成します。 テーブル パーティションの詳細については、「[Table Storage のパフォーマンスとスケーラビリティのチェックリスト](../storage/tables/storage-performance-checklist.md)」を参照してください。  

Table storage では、個々のノードが 1 つ以上の完全なパーティションを提供し、サービスのスケーリングはノード間でパーティションの負荷を動的に分散させることで行われます。 ノードに負荷がかかっている場合、Table storage は、そのノードによって処理されるパーティションの範囲を別のノードに分割できます。 トラフィックが減少したら、Table storage は、複数の低負荷ノードから 1 つのノードにパーティション範囲をマージできます。  

Table storage の内部詳細、特に、パーティションの管理方法については、[Microsoft Azure Storage: 強力な一貫性を備えた高可用性クラウド ストレージ サービス](https://docs.microsoft.com/archive/blogs/windowsazurestorage/sosp-paper-windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency)に関する記事を参照してください。  

### <a name="entity-group-transactions"></a>エンティティ グループ トランザクション
エンティティ グループ トランザクション (EGT) は、Table storage で複数のエンティティ間でアトミックな更新を行うための唯一の組み込みのメカニズムです。 EGT は*バッチ トランザクション*とも呼ばれています。 EGT では、同じパーティションに格納されたエンティティしか処理できないため (特定のテーブルで同じパーティション キーを共有)、複数のエンティティにまたがるアトミックなトランザクション動作が必要な場合は、それらのエンティティを同じパーティションに格納してください。 これが、異なる種類のエンティティに複数のテーブルを使わずに、異なる種類のエンティティを同じテーブル (とパーティション) に格納する主な理由です。 単一の EGT で最大 100 個のエンティティを処理できます。  複数の並行処理 EGT を送信する場合は、それらの EGT が EGT 間の共通であるエンティティには動作しないことを確認することが重要です。 そのようにしないと、処理が遅延するおそれがあります。

また、EGT によって、設計で評価が必要なトレードオフが生じる可能性があります。 使用するパーティションが増えると、ノード間で要求を負荷分散しやすくなるため、アプリケーションのスケーラビリティが向上します。 一方、これによって、アプリケーションでアトミックなトランザクションを実行し、データの強力な一貫性を維持する能力が制限される可能性があります。 さらに、1 つのノードの予想されるトランザクションのスループットを制限する可能性がある、パーティション レベルの特定のスケーラビリティ ターゲットがあります。

Azure ストレージ アカウントのスケーラビリティ ターゲットの詳細については、[Standard ストレージ アカウントのスケーラビリティ ターゲット](../storage/common/scalability-targets-standard-account.md)に関する記事を参照してください。 Table storage のスケーラビリティ ターゲットの詳細については、[Table storage のスケーラビリティとパフォーマンスのターゲット](../storage/tables/scalability-targets.md)に関する記事を参照してください。 このガイドの後のセクションでは、このようなトレードオフを管理しやすくするさまざまな設計戦略を紹介すると共に、クライアント アプリケーションの固有の要件に基づいてパーティション キーを選択する最適な方法についても説明します。  

### <a name="capacity-considerations"></a>容量に関する考慮事項
次の表に、Table storage ソリューションの設計時に考慮する必要のある主要な値をまとめます。  

| Azure ストレージ アカウントの合計容量 | 500 TB |
| --- | --- |
| Azure のストレージ アカウントのテーブルの数 |ストレージ アカウントの容量のみによる制限。 |
| テーブルのパーティションの数 |ストレージ アカウントの容量のみによる制限。 |
| パーティション内のエンティティの数 |ストレージ アカウントの容量のみによる制限。 |
| 個別のエンティティのサイズ |1 MB までの最大 255 個のプロパティ (`PartitionKey`、`RowKey`、`Timestamp` を含む) |
| `PartitionKey` のサイズ |最大 1 KB の文字列。 |
| `RowKey` のサイズ |最大 1 KB の文字列。 |
| エンティティ グループ トランザクションのサイズ |トランザクションには最大で 100 個のエンティティを含めることができ、ペイロードは 4 MB 未満にする必要があります。 EGT では 1 回に 1 つのエンティティしか更新できません。 |

詳細については、[Table service のデータ モデルの理解](https://msdn.microsoft.com/library/azure/dd179338.aspx)に関する記事を参照してください。  

### <a name="cost-considerations"></a>コストに関する考慮事項
Table storage は比較的安価ですが、Table storage を使うソリューションの評価の一環として、容量の使用とトランザクションの量を踏まえてコストを見積もる必要があります。 ただし、多くのシナリオでは、ソリューションのパフォーマンスとスケーラビリティを向上させるために、非正規化されたデータまたは重複するデータを格納するのも有効です。 価格の詳細については、[Azure Storage の価格](https://azure.microsoft.com/pricing/details/storage/)に関するページを参照してください。  

## <a name="guidelines-for-table-design"></a>テーブル設計のガイドライン
これらの一覧は、テーブルを設計するときに注意する必要がある重要なガイドラインの一部をまとめたものです。 これらのすべてについて、このガイドの残りの部分で詳しく説明します。 これらのガイドラインは、リレーショナル データベースの設計のために通常参照するガイドラインとは異なります。  

*読み取り*の効率を高める Table storage の設計は次のとおりです。

* **読み込みが多いアプリケーションでクエリを実行するための設計** テーブルを設計するときは、エンティティの更新方法について考える前に、実行するクエリ (特に、待機時間に影響を受けやすいもの) について検討してください。 これは通常、効率的でパフォーマンスの高いソリューションになります。  
* **クエリで `PartitionKey` と `RowKey` の両方を指定する。** これらのような*ポイント クエリ*は、最も効率的な Table storage のクエリです。  
* **エンティティの重複コピーを格納するか検討します。** テーブル ストレージは安価であるため、クエリの効率を上げるために、(異なるキーを持つ) 同じエンティティを複数回格納することをご検討ください。  
* **データの非正規化を検討します。** テーブル ストレージは安価であるため、データの非正規化を検討してください。 たとえば、概要エンティティを格納すると、統計データ用クエリは単一のエンティティにアクセスするだけで済みます。  
* **複合キーの値を使用します。** 存在するキーは `PartitionKey` と `RowKey` だけです。 たとえば、複合キーの値を使用してエンティティへの代替キー付きアクセス パスを有効にします。  
* **クエリ プロジェクションを使用します。** 必要なフィールドだけを選択するクエリを使用して、ネットワーク経由で転送するデータ量を削減できます。  

*書き込み*の効率を高める Table storage の設計は次のとおりです。  

* **ホット パーティションは作成しません。** 任意の時点で、複数のパーティションで要求を分散できるキーを選択します。  
* **トラフィックの急増を回避します。** 適切な期間にわたってトラフィックを分散させ、トラフィックの急増を回避します。
* **必ずしもエンティティの種類ごとに個別のテーブルを作成する必要はありません。** 複数のエンティティ種類でアトミック トランザクションが必要なときに、同じテーブル内の同じパーティションにこれら複数のエンティティ種類を格納できます。
* **実現する必要のある最大スループットを検討します。** Table storage のスケーラビリティ ターゲットを確認し、それを超えない設計にする必要があります。  

このガイドの後半では、これらの原則をすべて実践した例を紹介します。  

## <a name="design-for-querying"></a>クエリに対応した設計
Table storage では、読み取り、書き込み、またはその両方の負荷が高くなることがあります。 ここでは、読み取り操作を効率的にサポートするための設計について検討します。 通常は、読み取り操作を効率的にサポートする設計は、書き込み操作についても効率が高くなります。 ただし、書き込み操作をサポートするための設計にあたっては、追加の検討事項があります。 これらについては、次の「[データの変更に対応した設計](#design-for-data-modification)」で説明します。

データを効率的に読み取るためには、まず「必要なデータを取得するには、アプリケーションでどのようなクエリを実行する必要があるか」を考えてみてください。  

> [!NOTE]
> Table storage を使う場合は、事前に正しく設計することが重要です。後で設計を変更するのは難しいだけでなく、コストも高くなるためです。 たとえば、リレーショナル データベースなら、多くの場合、既存のデータベースにインデックスを追加するだけでパフォーマンスの問題に対処できます。 Table storage ではそうはいきません。  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>`PartitionKey` と `RowKey` の選択がクエリのパフォーマンスに与える影響
次の例では、以下の構造を持った複数の従業員エンティティを Table storage が格納すると想定しています (明確にするためほとんどの例で `Timestamp` プロパティを省略)。  

| 列名 | データ型 |
| --- | --- |
| `PartitionKey` (部署名) |String |
| `RowKey` (従業員 ID) |String |
| `FirstName` |String |
| `LastName` |String |
| `Age` |Integer |
| `EmailAddress` |String |

ここでは、Table storage のクエリの設計に関する一般的なガイドラインを示します。 以下の例で使用しているフィルター構文は、Table storage REST API のものです。 詳細については、[クエリ エンティティ](https://msdn.microsoft.com/library/azure/dd179421.aspx)に関する記事を参照してください。  

* *ポイント クエリ*は使用できる中で最も効率的な検索であり、大量の検索や、最も短い待機時間が求められる検索にお勧めします。 このようなクエリでは、`PartitionKey` と `RowKey` 値の両方を指定することでインデックスを使用し、個別のエンティティを効率よく検索することができます。 (例: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`)。  
* 2 番目に良いのは*範囲クエリ*です。 `PartitionKey` を使用し、`RowKey` 値の範囲でフィルター処理して複数のエンティティを返します。 `PartitionKey` 値は特定のパーティションを識別し、`RowKey` 値はそのパーティション内のエンティティのサブセットを識別します。 (例: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`)。  
* 3 番目に良いのは*パーティション スキャン*です。 `PartitionKey` を使用し、キーでない別のプロパティでフィルター処理し、複数のエンティティを返す場合があります。 `PartitionKey` 値は特定のパーティションを識別し、プロパティ値はそのパーティション内のエンティティのサブセットを選択します。 (例: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`)。  
* *テーブル スキャン*に `PartitionKey` は含まれません。また、一致するエンティティのテーブルを構成するパーティションのすべてを検索するため、非効率的です。 フィルターが `RowKey` を使用するかどうかにかかわらず、テーブル スキャンを実行します。 (例: `$filter=LastName eq 'Jones'`)。  
* 複数のエンティティを返す Azure Table storage クエリは、それらを `PartitionKey` および `RowKey` の順序で並べ替えます。 クライアント内でエンティティを再度並べ替えるのを防ぐため、最も一般的な並べ替え順序を定義する `RowKey` を選択します。 Azure Cosmos DB で Azure Table API によって返されるクエリ結果は、パーティション キーや行キーの順序にはなりません。 機能の相違に関する詳細なリストについては、[Azure Cosmos DB の Table API と Azure Table Storage の間の相違](table-api-faq.md#table-api-vs-table-storage)に関するページを参照してください。

"**or**" を使用して `RowKey` 値に基づいてフィルターを指定した場合はパーティション スキャンが行われます。範囲クエリとしては扱われません。 したがって、`$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')` などのフィルターを使用するクエリは避けてください。  

ストレージ クライアント ライブラリを使って効率的なクエリを実行するクライアント側コードの例については、以下を参照してください。  

* [ストレージ クライアント ライブラリを使用してポイント クエリを実行する](#run-a-point-query-by-using-the-storage-client-library)
* [LINQ を使用して複数のエンティティを取得する](#retrieve-multiple-entities-by-using-linq)
* [サーバー側のプロジェクション](#server-side-projection)  

同じテーブルに格納された複数の種類のエンティティを処理できるクライアント側コードの例については、  

* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>適切な `PartitionKey` を選択する
`PartitionKey` の選択においては、(一貫性の確保に必要となる) EGT の使用を可能にするため、複数のパーティションでエンティティを配布するための要件に対し、(スケーラブルなソリューションの確保のため) 必要性のバランスを取ることが求められます。  

極端な例としては、すべてのエンティティを 1 つのパーティションに格納できます。 ただし、これによってソリューションのスケーラビリティが制限され、Table storage が要求を負荷分散できなくなる可能性があります。 反対の極端な例としては、パーティションごとに 1 つのエンティティを格納できます。 これは拡張性が高く、Table storage が要求を負荷分散できるようにしますが、エンティティ グループ トランザクションは使用できなくなります。  

理想的な `PartitionKey` は、効率的なクエリの使用を可能にし、かつソリューションのスケーラビリティを確保するために十分なパーティションを備えています。 通常、エンティティには、十分な数のパーティションにエンティティを分散できるだけのプロパティがあります。

> [!NOTE]
> たとえば、ユーザーまたは従業員に関する情報を格納するシステムでは、`UserID` を `PartitionKey` として使うと便利です。 パーティション分割キーとして特定の `UserID` を使用する複数のエンティティを使用できます。 ユーザーに関するデータを格納する個々のエンティティは、1 つのパーティションにグループ化されます。 これらのエンティティは EGT を介してアクセスできる一方で、スケーラビリティにも優れています。
> 
> 

選択した `PartitionKey` についてエンティティの挿入、更新、削除方法に関連する追加の検討事項があります。 詳細については、この記事の後半の「[データの変更に対応した設計](#design-for-data-modification)」を参照してください。  

### <a name="optimize-queries-for-table-storage"></a>Table storage のクエリを最適化する
Table storage では、`PartitionKey` と `RowKey` 値を使用して、1 つのクラスター化インデックスにエンティティのインデックスを自動的に作成します。 これが、ポイント クエリを使用するのが最も効率が良い理由です。 ただし、`PartitionKey` と `RowKey` のクラスター化インデックス以外にはインデックスはありません。

多くの設計で、複数の条件に基づいてエンティティを参照できるようにするという要件を満たす必要があります。 たとえば、電子メール、従業員 ID、姓に基づいて従業員エンティティを特定する場合などです。 「[テーブルの設計パターン](#table-design-patterns)」にある以下のパターンは、これらの種類の要件を扱っています。 これらのパターンは、Table storage がセカンダリ インデックスを提供しないという事実への対処方法についても説明しています。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern):(同じパーティション内の) 異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  
* [パーティション間のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern):別個のパーティション内または別個のテーブル内の異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  
* [インデックス エンティティのパターン](#index-entities-pattern):エンティティ一覧を返す、効率的な検索を有効にするインデックスのエンティティを管理します。  

### <a name="sort-data-in-table-storage"></a>Table storage でのデータの並べ替え

Table storage は、`PartitionKey` に基づいて、次に `RowKey` によって昇順で並べ替えたクエリ結果を返します。

> [!NOTE]
> Azure Cosmos DB で Azure Table API によって返されるクエリ結果は、パーティション キーや行キーの順序にはなりません。 機能の相違に関する詳細なリストについては、[Azure Cosmos DB の Table API と Azure Table Storage の間の相違](table-api-faq.md#table-api-vs-table-storage)に関するページを参照してください。

Table storage でのキーは文字列値です。 数値が正しく並べ替えられるようにするには、固定長の値に変換し、ゼロ パディングを施す必要があります。 たとえば、従業員 ID 値を整数値の `RowKey` として使用する場合、従業員 ID を **123** から **00000123** に変換する必要があります。 

さまざまな順序 (名前、入社日など) で並べ替えられたデータを使う必要のあるアプリケーションは多数あります。 「[テーブルの設計パターン](#table-design-patterns)」にある以下のパターンは、エンティティの並べ替え順序を代替する方法を扱っています。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern):(同じパーティション内の) 異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  
* [パーティション間のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern):別個のパーティション内または別個のテーブル内の異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。
* [ログ テール パターン](#log-tail-pattern):逆の日付と時間順でソートする `RowKey` 値を 使用して、最も新しく追加された *n* 件のエンティティを取得します。  

## <a name="design-for-data-modification"></a>データの変更に対応した設計
このセクションでは、挿入、更新、削除の操作を最適化するための設計上の考慮事項を示します。 場合によっては、クエリのために最適化する設計と、データ変更のために最適化する設計の間でトレードオフを評価する必要があります。 この評価は、リレーショナル データベース向けの設計で行うものに似ています (ただし、リレーショナル データベースでは、設計のトレードオフを管理するための手法が異なります)。 「[テーブルの設計パターン](#table-design-patterns)」では、Table storage 用の詳細な設計パターンをいくつか説明し、これらのトレードオフに注目します。 実際のところ、クエリ向けに最適化された設計の多くは、エンティティの変更にも適していることがおわかりになると思います。  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>挿入、更新、削除の操作のパフォーマンスを最適化する
エンティティを更新または削除するには、`PartitionKey` と `RowKey` 値を使用してエンティティを識別する必要があります。 この点では、エンティティを変更するための `PartitionKey` と `RowKey` を選択する際は、ポイント クエリをサポートするための選択と同様の基準に従う必要があります。 エンティティはできるだけ効率的に識別したいものです。 `PartitionKey` と `RowKey` 値の検出のためにエンティティを特定する非効率的なパーティションまたはテーブル スキャンを使用したくない場合は、更新または削除する必要があります。  

「[テーブルの設計パターン](#table-design-patterns)」にある以下のパターンは、挿入、更新、削除の各操作のパフォーマンスの最適化を扱っています。  

* [大量削除パターン](#high-volume-delete-pattern): すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。 エンティティを削除するときは、テーブル自体を削除することになります。  
* [データ系列のパターン](#data-series-pattern): データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  
* [ワイド エンティティ パターン](#wide-entities-pattern): 複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  
* [大型エンティティ パターン](#large-entities-pattern): 大規模なプロパティの値を格納する BLOB ストレージを使用します。  

### <a name="ensure-consistency-in-your-stored-entities"></a>格納されたエンティティの一貫性を確保する
データの変更を最適化するためのキーの選択を左右する要因として、アトミックなトランザクションを使って一貫性を確保する方法も挙げられます。 同じパーティションに格納されたエンティティを操作する場合は、EGT しか使用できません。  

「[テーブルの設計パターン](#table-design-patterns)」にある以下のパターンは、一貫性の管理を扱っています。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern):(同じパーティション内の) 異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  
* [パーティション間のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern):別個のパーティション内または別個のテーブル内の異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern):Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。
* [インデックス エンティティのパターン](#index-entities-pattern):エンティティ一覧を返す、効率的な検索を有効にするインデックスのエンティティを管理します。  
* [非正規化パターン](#denormalization-pattern):関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  
* [データ系列のパターン](#data-series-pattern): データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

詳細については、この記事内の「[エンティティ グループ トランザクション](#entity-group-transactions)」を参照してください。  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>効率的な変更に対応した設計によるクエリの効率化
効率的なクエリに適した設計は変更の効率も高いのが普通ですが、自分のシナリオにもそれが当てはまるかどうかは必ず評価する必要があります。 [テーブルの設計パターン](#table-design-patterns) セクションのパターンの中には、エンティティのクエリと変更との間のトレードオフを明示的に評価するものがあります。常に各操作数を考慮しておく必要があります。  

[テーブルの設計パターン](#table-design-patterns) セクションの以下のパターンでは、 効率的なクエリの設計と効率的なデータ変更の設計の間のトレードオフについて説明します。  

* [複合キー パターン](#compound-key-pattern):クライアントで単一のポイント クエリを使用して関連するデータを検索できるようにするには、複合 `RowKey` 値を使用します。  
* [ログ テール パターン](#log-tail-pattern):逆の日付と時間順でソートする `RowKey` 値を 使用して、最も新しく追加された *n* 件のエンティティを取得します。  

## <a name="encrypt-table-data"></a>テーブル データを暗号化する
.NET Azure Storage クライアント ライブラリでは、挿入および置換操作の文字列エンティティ プロパティの暗号化がサポートされます。 暗号化された文字列はバイナリ プロパティとしてサービスで保存され、復号化された後、解読された後、文字列に再度変換されます。    

テーブルの場合、暗号化ポリシーに加え、ユーザーは暗号化するプロパティを指定する必要があります。 `EncryptProperty` 属性を指定する (`TableEntity` から派生した POCO エンティティの場合) か、要求オプションで暗号化リゾルバーを指定します。 暗号化リゾルバーは、パーティション キー、行キー、プロパティ名を取得するデリゲートで、プロパティを暗号化するかどうかを示すブール値を返します。 暗号化時、クライアント ライブラリはこの情報を使用して、ネットワークへの書き込み時にプロパティを暗号化するかどうかを決定します。 また、デリゲートは、プロパティの暗号化方法に関するロジックを使用する可能性にも備えます。 (X の場合、プロパティ A を暗号化し、それ以外の場合はプロパティ A および B を暗号化するなど。)エンティティの読み込み中、またはクエリの実行中は、この情報を指定する必要はありません。

マージは現在サポートされていません。 以前に別のキーを使用してプロパティのサブセットが暗号化されている可能性があるため、新しいプロパティをマージしたり、メタデータを更新したりするとデータ損失が発生します。 マージでは、追加のサービス呼び出しをして既存のエンティティをサービスから読み込むか、プロパティごとに新しいキーを使用する必要があります。 いずれの方法も、パフォーマンス上の理由でお勧めできません。     

テーブル データの暗号化については、「[Microsoft Azure Storage のクライアント側の暗号化と Azure Key Vault](../storage/common/storage-client-side-encryption.md)」を参照してください。  

## <a name="model-relationships"></a>リレーションシップのモデル化
複雑なシステムの設計において、ドメイン モデルの作成は重要なステップです。 通常は、モデル化プロセスを使用して各種エンティティとそれらの間のリレーションシップを特定します。これはビジネス ドメインについて理解し、システムの設計を伝えるための手段となります。 このセクションでは、ドメイン モデル内の一般的なリレーションシップの種類を Table storage 向けの設計に変換する方法を中心に説明します。 論理データ モデルから物理的な NoSQL ベースのデータ モデルへのマッピング プロセスは、リレーショナル データベースの設計時に使われるプロセスとは異なります。 リレーショナル データベースの設計では、通常、冗長性を最小限に抑えるために最適化されたデータ正規化プロセスを想定しています。 また、このような設計では、データベースの動作の実装を抽象化する宣言型のクエリ機能も想定しています。  

### <a name="one-to-many-relationships"></a>一対多のリレーションシップ
ビジネス ドメイン オブジェクトの間で一対多のリレーションシップが存在することはよくあります。たとえば、1 つの部署に多数の従業員が存在する場合などです。 特定のシナリオにおいて、長短それぞれあるものの、Table storage に一対多のリレーションシップを実装する方法はいくつかあります。  

部署および従業員のエンティティが何万とある、多国籍の大企業の例を考えてみましょう。 各部署には多数の従業員が在籍し、各従業員は 1 つの特定の部署に関連付けられています。 次のように、部署のエンティティと従業員のエンティティを分けて格納する方法もあります。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE01.png" alt-text="部署エンティティと従業員エンティティを示す図":::

この例は、`PartitionKey` 値に基づいて、各種類における暗黙の一対多のリレーションシップを示しています。 各部署に多数の従業員が存在する可能性があります。  

この例は、部署エンティティと、同じパーティションに含まれる関連の従業員エンティティも示しています。 別のエンティティの種類として、別のパーティション、テーブル、またはストレージ アカウントを使うこともできます。  

別の方法として、次の例に示すように、データを非正規化し、非正規化された部署データと共に従業員エンティティのみを格納する方法もあります。 このシナリオで部署のマネージャーの詳細を変更できるようにする必要がある場合は、この非正規化の方法は最適ではない可能性があります。 これを行うには、部署内のすべての従業員を更新する必要があります。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE02.png" alt-text="従業員エンティティの図":::

詳細については、 このガイドで後述する [非正規化パターン](#denormalization-pattern) を参照してください。  

次の表に、一対多のリレーションシップを持つ従業員エンティティと部署エンティティを格納するアプローチについて、それぞれの長所と短所をまとめます。 また、さまざまな操作を実行する頻度の予測も考慮する必要があります。 まれにしか実行しない操作であれば、コストの高い操作を設計に含めることが許容される可能性があります。  

<table>
<tr>
<th>アプローチ</th>
<th>長所</th>
<th>短所</th>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブルは同じ</td>
<td>
<ul>
<li>1 回の操作で部署エンティティを更新できる。</li>
<li>従業員エンティティを更新、挿入、削除するたびに部署エンティティを変更する必要がある場合は、一貫性を維持するために EGT を使用できます。 たとえば、部署ごとの従業員数を管理する場合などです。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>ストレージ操作が同じパーティションで行われる。 トランザクションの量が多いときにホットスポットが生じる可能性がある。</li>
<li>EGT を使用して従業員を新しい部署に移動することはできない。</li>
</ul>
</td>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブル、ストレージ アカウントは別</td>
<td>
<ul>
<li>1 回の操作で部署エンティティと従業員エンティティを更新できる。</li>
<li>トランザクションの量が多いときに、負荷をより多くのパーティションに分散させることができる。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>従業員を更新、挿入、削除し、部署を更新するときに、一貫性を維持するために EGT を使用することはできない。 たとえば、部署エンティティ内の従業員数を更新する場合などです。</li>
<li>EGT を使用して従業員を新しい部署に移動することはできない。</li>
</ul>
</td>
</tr>
<tr>
<td>単一のエンティティの種類への非正規化</td>
<td>
<ul>
<li>必要なすべての情報を 1 回の要求で取得できる。</li>
</ul>
</td>
<td>
<ul>
<li>部署の情報を更新する必要がある場合、一貫性の維持のコストが高くなる可能性がある (部署のすべての従業員を更新する必要があるため)。</li>
</ul>
</td>
</tr>
</table>

これらの選択肢のうちのどれを選ぶか、また、どの長所と短所の影響が最も大きいかは、アプリケーションのシナリオによって異なります。 たとえば、部署エンティティを変更する頻度はどのくらいですか。 すべての従業員クエリに追加の部署情報が必要ですか。 パーティションまたはストレージ アカウントのスケーラビリティの制限まで、どのくらいの余裕がありますか。  

### <a name="one-to-one-relationships"></a>一対一のリレーションシップ
ドメイン モデルにはエンティティ間の一対一のリレーションシップが含まれる可能性があります。 Table storage で一対一のリレーションシップを実装する必要がある場合は、2 つの関連するエンティティを取得する必要があるときにそれらをリンクする方法も選択する必要があります。 このリンクはキー値の規則に基づいて、各エンティティにおいて `PartitionKey` と `RowKey` 値形式で関連エンティティへのリンクを格納することで、明示的にも暗黙的にも成り得ます。 同じパーティションに関連エンティティを格納するかどうかの詳細については、 [一対多のリレーションシップ](#one-to-many-relationships)セクションを参照してください。  

実装上の検討内容に応じて、Table storage で一対一のリレーションシップを実装する必要が生じることもあります。  

* ラージ エンティティを処理する (詳細については、「[ラージ エンティティ パターン](#large-entities-pattern)」を参照してください)。  
* アクセス制御を実装する (詳細については、「[共有アクセス署名を使用してアクセスを制御する](#control-access-with-shared-access-signatures)」を参照してください)。  

### <a name="join-in-the-client"></a>クライアントでの結合
Table storage でのリレーションシップのモデル化には何とおりかの方法がありますが、Table storage を使う主な理由はスケーラビリティとパフォーマンスの 2 つであることを忘れないでください。 ソリューションのパフォーマンスとスケーラビリティを損なう多数のリレーションシップをモデル化しようとしていることに気が付いた場合は、そのすべてのデータ リレーションシップをテーブル設計に組み込む必要があるかどうかを確認する必要があります。 クライアント アプリケーションで必要な結合が実行されるようにすると、設計を簡素化し、ソリューションのスケーラビリティとパフォーマンスを向上させることができます。  

たとえば、変更頻度の高くないデータが格納された小さなテーブルがある場合は、一度そのデータを取得してクライアント上にキャッシュできます。 そうすると、何度も同じデータを取得する必要がなくなります。 このガイドで取り上げた例では、小さな組織の一連の部署はおそらく小規模で、頻繁には変更されません。 そのため、クライアント アプリケーションが一度ダウンロードして検索データとしてキャッシュできるデータの有力な候補です。  

### <a name="inheritance-relationships"></a>継承リレーションシップ
クライアント アプリケーションでビジネス エンティティを表す継承リレーションシップの一部を構成するクラスのセットを使用する場合は、それらのエンティティを Table storage で簡単に保持できます。 たとえば、`Person` が抽象クラスとなっているクライアント アプリケーションにはクラスセットが定義されている可能性があります。

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE03.png" alt-text="継承リレーションシップの図":::

1 つの `Person` テーブルを使用して、2 つの具象クラスのインスタンスを Table storage に永続化できます。 次のようなエンティティを使用します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE04.png" alt-text="顧客エンティティと従業員エンティティを示す図":::

クライアント コードの同じテーブル内の複数のエンティティ種類の詳細については、このガイド内の「[異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)」を参照してください。 クライアント コードでエンティティの種類を認識する方法の例が示されています。  

## <a name="table-design-patterns"></a>テーブルの設計パターン
以前のセクションでは、クエリを使用してエンティティ データを取得する場合と、エンティティ データを挿入、更新、削除する場合の両方のテーブル設計を最適化する方法について説明しました。 このセクションでは、Table storage で使用するのに適したパターンをいくつか紹介します。 また、このガイドで前に提起された問題とトレードオフの一部に実際に対処する方法を説明しています。 次の図は、さまざまなパターン間の関係をまとめたものです。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE05.png" alt-text="テーブル設計パターンの図":::

パターン マップには、このガイドに記載されているパターン (青) とアンチパターン (オレンジ) の関係の一部が示されています。 もちろん、検討する価値があるパターンは他にもたくさんあります。 たとえば、Table storage 向けの主なシナリオの 1 つに、[コマンド クエリ責務分離](https://msdn.microsoft.com/library/azure/jj554200.aspx)パターンの[具体化されたビュー パターン](https://msdn.microsoft.com/library/azure/dn589782.aspx)の使用があります。  

### <a name="intra-partition-secondary-index-pattern"></a>パーティション内のセカンダリ インデックス パターン
(同じパーティション内の) 異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。 コピー間の更新の一貫性は、EGT を使用して保つことができます。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table storage では、`PartitionKey` と `RowKey` 値を使用してエンティティのインデックスを自動的に作成します。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のテーブル構造を使用することにより、クライアント アプリケーションでは、ポイント クエリを使用して部署名と従業員 ID (`PartitionKey` と `RowKey` 値) から、個々の従業員エンティティを取得できます。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE06.png" alt-text="従業員エンティティの図":::

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索する場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table storage ではセカンダリ インデックスが提供されないためです。 さらに、`RowKey` 順以外の順序で並べ替えられた従業員の一覧を要求するオプションはありません。  

#### <a name="solution"></a>解決策
セカンダリ インデックスの不足を回避するには、異なる `RowKey` 値を使用して各コピーの複数コピーを格納します。 次の構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。 `RowKey` のプレフィックス値、`empid_`、`email_` で、1 人の従業員をクエリするか電子メール アドレスまたは従業員 ID の範囲を使用して、ある特定の範囲の従業員をクエリできます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE07.png" alt-text="RowKey 値が変化する従業員エンティティを示す図":::

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件とメール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

* $filter = (PartitionKey eq 'Sales') と (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') と (RowKey eq 'email_jonesj@contoso.com')  

ある範囲の従業員エンティティのクエリを実行する場合は、従業員 ID の順に並べ替えられた範囲を指定するか、メール アドレス順に並べ替えられた範囲を指定することができます。 `RowKey` に適切なプレフィックスが含まれているエンティティのクエリを実行します。  

* Sales 部署において、従業員 ID、000100 から 000199 を指定して、すべての従業員を検索するには、$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199') を使用します。  
* Sales 部署において、"a" で始まる電子メール アドレスを持つすべての従業員を検索するには:$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b') を使用します。  
  
前の例で使用しているフィルター構文は、Table storage REST API のものです。 詳細については、[クエリ エンティティ](https://msdn.microsoft.com/library/azure/dd179421.aspx)に関する記事を参照してください。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
* セカンダリ インデックス エンティティは元のエンティティと同じパーティションに格納されるため、個々のパーティションのスケーラビリティ ターゲットを超えないようにしてください。  
* EGT を使用してエンティティの 2 つのコピーをアトミックに更新することで、重複するエンティティどうしの一貫性を保つことができます。 そのためには、エンティティのすべてのコピーを同じパーティションに格納する必要があります。 詳細については、[エンティティ グループ トランザクションの使用](#entity-group-transactions)に関する節を参照してください。  
* `RowKey` に使用される値は各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
* 数値を `RowKey` (たとえば、従業員 ID 000223) にパディングすると、上限と下限に基づき正確な並べ替えとフィルタリングが可能になります。  
* 必ずしもエンティティのすべてのプロパティを複製する必要はありません。 たとえば、電子メールアドレスを使用してエンティティを `RowKey` で検索するクエリの場合、従業員の年齢は不要です。このようなエンティティは、次のような構造になっている可能性があります。

  :::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE08.png" alt-text="従業員エンティティの図":::

* 通常は、エンティティの検索と必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
このパターンは次の状況で使用します。

- クライアント アプリケーションが、さまざまなキーを使用してエンティティを取得する必要がある。
- クライアントが、さまざまな並べ替え順序でエンティティを取得する必要がある。
- さまざまな一意の値を使用して各エンティティを識別できる。

ただし、異なる `RowKey` 値を使用してエンティティ参照を実行している場合は、パーティションのスケーラビリティの制限を超えないようにしてください。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [パーティション内セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern)
* [複合キー パターン](#compound-key-pattern)
* [エンティティ グループ トランザクション](#entity-group-transactions)
* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>パーティション内のセカンダリ インデックス パターン
別個のパーティション内または別個のテーブル内の異なる `RowKey` 値を使用して、各エンティティの複数のコピーを格納します。 これにより、異なる `RowKey` 値を使用することで、高速で効率的な検索と、代替の並べ替え順序が可能になります。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table storage では、`PartitionKey` と `RowKey` 値を使用してエンティティのインデックスを自動的に作成します。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のテーブル構造を使用することにより、クライアント アプリケーションでは、ポイント クエリを使用して部署名と従業員 ID (`PartitionKey` と `RowKey` 値) から、個々の従業員エンティティを取得できます。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE09.png" alt-text="従業員エンティティの図":::[9]

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table storage ではセカンダリ インデックスが提供されないためです。 さらに、`RowKey` 順以外の順序で並べ替えられた従業員の一覧を要求するオプションはありません。  

これらのエンティティに対するトランザクションの量が膨大になることが予想される場合は、Table storage によってクライアントがレート制限されるリスクを最小限に抑える必要があります。  

#### <a name="solution"></a>解決策
セカンダリ インデックスの不足を回避するには、異なる `PartitionKey` と `RowKey` 値を使用して各コピーの複数コピーを格納します。 次の構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。 `PartitionKey` のプレフィックスの値、`empid_`、`email_` で、クエリに使用するインデックスを特定することができます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE10.png" alt-text="プライマリ インデックスを持つ従業員エンティティとセカンダリ インデックスを持つ従業員エンティティを示す図":::

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件とメール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') と (RowKey eq 'jonesj@contoso.com')  

ある範囲の従業員エンティティのクエリを実行する場合は、従業員 ID の順に並べ替えられた範囲を指定するか、メール アドレス順に並べ替えられた範囲を指定することができます。 `RowKey` に適切なプレフィックスが含まれているエンティティのクエリを実行します。  

* 従業員 ID 順で格納された、従業員 ID が**000100** から **000199** の範囲の Sales 部署のすべての従業員を検索するには、$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199') を使用します。  
* Sales 部署において、電子メール アドレス順で格納された電子メール アドレスで、"a" で始まる電子メール アドレスを持つすべての従業員を検索するには、$filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b') を使用します。  

前の例で使用しているフィルター構文は、Table storage REST API のものであることに注意してください。 詳細については、[クエリ エンティティ](https://msdn.microsoft.com/library/azure/dd179421.aspx)に関する記事を参照してください。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* プライマリとセカンダリ インデックスのエンティティを維持するため、重複するエンティティを保持して、 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) を使用し、互いに最終的に一貫性を持たせます。  
* テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用する重複エンティティのみを追加してください。  
* `RowKey` に使用される値は各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
* 数値を `RowKey` (たとえば、従業員 ID 000223) にパディングすると、上限と下限に基づき正確な並べ替えとフィルタリングが可能になります。  
* 必ずしもエンティティのすべてのプロパティを複製する必要はありません。 たとえば、電子メールアドレスを使用してエンティティを `RowKey` で検索するクエリの場合、従業員の年齢は不要です。このようなエンティティは、次のような構造になっている可能性があります。
  
  :::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE11.png" alt-text="セカンダリ インデックスを持つ従業員エンティティを示す図":::

* 通常は、セカンダリ インデックスを使用したエンティティの検索とプライマリ インデックス内の必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
このパターンは次の状況で使用します。

- クライアント アプリケーションが、さまざまなキーを使用してエンティティを取得する必要がある。
- クライアントが、さまざまな並べ替え順序でエンティティを取得する必要がある。
- さまざまな一意の値を使用して各エンティティを識別できる。

異なる `RowKey` 値を使用してエンティティ検索を実行しており、パーティションのスケーラビリティの制限を超えないようにしたい場合、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern)  
* [複合キー パターン](#compound-key-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>最終的に一貫性のあるトランザクション パターン
Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。  

#### <a name="context-and-problem"></a>コンテキストと問題
EGT を使用すると、同じパーティション キーを共有する複数のエンティティに対してアトミックなトランザクションを実行できます。 パフォーマンスやスケーラビリティの関係で、一貫性が必要なエンティティを別々のパーティションや別のストレージ システムに格納する場合があります。 そのような場合は、EGT を使用して一貫性を保つことはできません。 たとえば、次の一貫性を最終的に確保する必要があるとします。  

* 同じテーブル内の 2 つの異なるパーティション、異なるテーブル、異なるストレージ アカウントに格納されているエンティティ。  
* Table storage に格納されているエンティティと、BLOB ストレージに格納されている BLOB。  
* Table storage に格納されているエンティティとファイル システム内のファイル。  
* Table storage に格納されているが、Azure Cognitive Search を使用してインデックスが作成されたエンティティ。  

#### <a name="solution"></a>解決策
Azure キューを使用すると、2 つ以上のパーティションまたはストレージ システム間で最終的に一貫性を確保するソリューションを実装できます。

この方法を説明するために、以前の従業員エンティティをアーカイブできるようにする必要があるという場合を考えてみましょう。 以前の従業員エンティティはめったに照会されず、現在の従業員を対象にしたすべてのアクティビティから除外する必要があります。 この要件を実装するには、**現在**テーブルにいる現在の従業員と、**アーカイブ** テーブルにいる以前の従業員を格納します。 従業員をアーカイブするには、**現在**テーブルからのエンティティを削除し、**アーカイブ** テーブルにエンティティを追加する必要があります。

しかし、EGT を使用してこれら 2 つの操作を実行することはできません。 エンティティが両方のテーブルに表示されることや、どちらのテーブルにも表示されないことがないように、アーカイブ操作は最終的に一貫性が確保される必要があります。 次のシーケンス図は、この操作の大まかな手順を示しています。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE12.png" alt-text="最終的整合性を考慮したソリューションの図":::

クライアントは、Azure キューにメッセージを配置することによって、アーカイブ操作を開始します (この例では、ID が 456 の従業員をアーカイブします)。 worker ロールは、キューをポーリングして新しいメッセージの有無を確認します。メッセージを見つけると、そのメッセージを読み取り、隠しコピーをキューに残します。 worker ロールは、次に、**現在**テーブルからコピーをフェッチし、**アーカイブ** テーブルにコピーを挿入し、その後、元のデータを**現在**テーブルから削除します。 最後に、前の手順でエラーが発生しなければ、worker ロールはキューから隠しメッセージを削除します。  

この例では、図のステップ 4 で従業員を**アーカイブ** テーブルに挿入しています。 BLOB ストレージ内の BLOB またはファイル システム内のファイルに従業員を追加できます。  

#### <a name="recover-from-failures"></a>エラーからの復旧
worker ロールがアーカイブ操作を再開する必要がある場合、図中の手順 4 ～ 5 が*べき等*になっていることが重要です。 Table storage を使用している場合、手順 4 で "挿入または置換" 操作を使用する必要があります。手順 5 では、使用しているクライアント ライブラリで "存在する場合は削除" 操作を使用する必要があります。 他のストレージ システムを使用する場合は、適切なべき等操作を使用する必要があります。  

worker ロールが図の手順 6 を完了しない場合は、タイムアウトの後、メッセージが worker ロール準備完了のキューに表示され再処理を試みます。 worker ロールは、キュー上のメッセージを読み取った回数を確認し、必要に応じて、別のキューに送信することで、調査のために "有害" メッセージとしてフラグを設定できます。 キュー メッセージの読み取りとデキュー カウントのチェックの詳細については、[メッセージの取得](https://msdn.microsoft.com/library/azure/dd179474.aspx)に関する記事を参照してください。  

Table storage と Queue storage のエラーには一時的なエラーもあります。クライアント アプリケーションには、そうしたエラーに対処する適切な再試行ロジックを組み込む必要があります。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* このソリューションは、トランザクションを分離するためのソリューションではありません。 たとえば、worker ロールが手順 4 ～ 5 の間にあるとき、クライアントは**現在**テーブルと**アーカイブ** テーブルを読み取る可能性があり、クライアントから見たデータのビューには一貫性がない可能性があります。 データは最終的に一貫性が確保されます。  
* 最終的に一貫性を確保するために、手順 4 ～ 5 がべき等になっていることを確認する必要があります。  
* 複数のキューと worker ロール インスタンスを使用して、ソリューションを拡張できます。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
別のパーティションまたはテーブルに存在するエンティティ間の一貫性を最終的に確保する必要がある場合に、このパターンを使用します。 このパターンを拡張して、Table storage と BLOB ストレージのほかにも、データベースやファイル システムなどの Azure 以外のストレージ データ ソース間の操作で最終的な一貫性を確保できます。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [マージまたは置換](#merge-or-replace)  

> [!NOTE]
> ソリューションにとってトランザクションの分離が重要な場合は、EGT を使用できるようにテーブルを再設計することを検討してください。  
> 
> 

### <a name="index-entities-pattern"></a>インデックス エンティティのパターン
エンティティ一覧を返す、効率的な検索を有効にするインデックスのエンティティを管理します。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table storage では、`PartitionKey` と `RowKey` 値を使用してエンティティのインデックスを自動的に作成します。 そうすると、クライアント アプリケーションでポイント クエリを使用してエンティティを効率的に取得できます。 たとえば、次のテーブル構造を使用することにより、クライアント アプリケーションでは、部署名と従業員 ID (`PartitionKey` と `RowKey`) から、個々の従業員エンティティを効率的に取得できます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE13.png" alt-text="従業員エンティティの図":::

また、姓など、一意ではない他のプロパティの値に基づいて従業員エンティティの一覧を取得できるようにする場合は、効率の劣るパーティション スキャンを使用する必要があります。 このスキャンでは、インデックスを使用して直接参照するのではなく、一致を検索します。 これは、Table storage ではセカンダリ インデックスが提供されないためです。  

#### <a name="solution"></a>解決策
前述のエンティティ構造の場合、姓で検索できるようにするには、従業員 ID の一覧を保持する必要があります。 Jones など、特定の姓を持つ従業員エンティティを取得するには、まず姓が Jones である従業員の従業員 ID の一覧を検索してから、それらの従業員エンティティを取得する必要があります。 従業員 ID の一覧を格納する方法は主に次の 3 つがあります。  

* BLOB ストレージを使用する。  
* 従業員エンティティと同じパーティションにインデックス エンティティを作成する。  
* 別のパーティションまたはテーブルにインデックス エンティティを作成する。  

オプション 1: BLOB ストレージを使用する  

すべての一意の姓について BLOB を作成し、各 BLOB には、その姓の従業員の `PartitionKey` (部署) と `RowKey` (従業員 ID) の値の一覧が格納されます。 従業員を追加または削除した場合は、関連する BLOB の内容と従業員エンティティの一貫性が最終的に確保されていることを確認してください。  

オプション 2: 同じパーティション内でインデックス エンティティを作成する  

次のデータを格納するインデックス エンティティを使用します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE14.png" alt-text="従業員エンティティと、同じ姓を持つ従業員 ID の一覧を含む文字列を示した図":::

`EmployeeIDs` プロパティには、`RowKey` に格納されている姓を持つ従業員の従業員 ID リストが含まれています。  

次の手順は、新しい従業員を追加するときに従う必要がある手順の概要を示しています。 この例では、ID が 000152、姓が Jones の従業員を Sales 部署に追加します。  

1. `PartitionKey` 値 "Sales" と `RowKey` 値 "Jones" を持つインデックス エンティティを取得します。 このエンティティの ETag を、手順 2. で使用するために保存します。  
2. 新しい従業員エンティティ (`PartitionKey` の値は "Sales"、`RowKey` の値は "000152") を挿入し、インデックス エンティティ (`PartitionKey` の値は "Sales"、`RowKey` の値は "Jones") を更新するエンティティ グループ トランザクション (つまり、バッチ操作) を作成します。 EGT は、新しい従業員 ID を EmployeeIDs フィールドの一覧に追加することによってこれを行います。 EGT の詳細については、「[エンティティ グループ トランザクション](#entity-group-transactions)」を参照してください。  
3. オプティミスティック コンカレンシー エラー (他のユーザーがインデックス エンティティを変更したこと) が原因で EGT が失敗した場合は、手順 1 からやり直す必要があります。  

2 番目の方法を使用する場合は、同じような方法で従業員を削除できます。 従業員の姓を変更するのは、3 つのエンティティ (従業員エンティティ、元の姓のインデックス エンティティ、新しい姓のインデックス エンティティ) を更新する EGT を実行する必要があるため、少し複雑です。 変更を加える前に、各エンティティを取得して、ETag 値を取得する必要があります。その ETag 値を使用して、オプティミスティック コンカレンシーで更新を実行できます。  

次の手順は、ある部署で特定の姓を持つすべての従業員を検索する必要があるときに従う必要がある手順の概要を示しています。 この例では、Sales 部署で姓が Jones のすべての従業員を検索します。  

1. `PartitionKey` 値 "Sales" と `RowKey` 値 "Jones" を持つインデックス エンティティを取得します。  
2. `EmployeeIDs` フィールドで従業員 ID の一覧を解析します。  
3. 各従業員に関する追加情報 (電子メール アドレスなど) が必要な場合は、手順 2 で取得した従業員リストから `PartitionKey` 値 "Sales" と `RowKey` 値を使用して各従業員のエンティティを取得します。  

オプション 3:別のパーティションまたはテーブルにインデックス エンティティを作成する  

この方法では、以下のデータを格納するインデックス エンティティを使用します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE15.png" alt-text="従業員エンティティと、同じ姓を持つ従業員 ID の一覧を含む文字列を示した図":::

`EmployeeIDs` プロパティには、`RowKey` と `PartitionKey` に格納されている姓を持つ従業員の従業員 ID リストが含まれています。  

インデックス エンティティが従業員エンティティとは別のパーティションにあるため、EGT を使用して一貫性を保つことはできません。 インデックス エンティティが従業員エンティティと最終的に一貫していることを確認してください。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* このソリューションでは、一致するエンティティを取得するために、少なくとも 2 つのクエリが必要です。1 つはインデックス エンティティを照会して `RowKey` 値の一覧を取得するクエリです。もう 1 つはその一覧内の各エンティティを取得するクエリです。  
* 個々のエンティティの最大サイズは 1 MB であるため、ソリューションの方法 2 と方法 3 では、どの特定の姓についても従業員 ID の一覧が 1 MB を超えないと仮定しています。 従業員 ID の一覧のサイズが 1 MB を超える可能性がある場合は、方法 1 を使用して、BLOB ストレージにインデックス データを格納します。  
* 方法 2 を使用する (EGT を使用して、従業員の追加と削除、従業員の姓の変更を処理する) 場合は、トランザクションの量が特定のパーティションのスケーラビリティの限界に近づくかどうかを確認する必要があります。 この場合は、最終的に一貫性のあるソリューション (方法 1 または方法 3) を検討する必要があります。 これらはキューを使用して更新要求を処理し、従業員エンティティとは別のパーティションにインデックス エンティティを格納できるようにします。  
* このソリューションの方法 2 では、部署内で姓によって検索することを想定しています。 たとえば、姓が Jones で営業部に所属する従業員の一覧を取得するとします。 組織全体で姓が Jones のすべての従業員を検索できる必要がある場合は、方法 1 と方法 3 のどちらかを使用します。
* 最終的な一貫性を提供するキュー ベースのソリューションを実装できます。 詳細については、「[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)」を参照してください。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
姓が Jones のすべての従業員など、特定のプロパティ値がすべて共通している一連のエンティティを検索する場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>非正規化パターン
関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  

#### <a name="context-and-problem"></a>コンテキストと問題
リレーショナル データベースでは、通常、クエリで複数のテーブルからデータを取得するときに発生する重複を排除するためにデータを正規化します。 Azure テーブルのデータを正規化した場合、関連するデータを取得するには、クライアント アプリケーションとサーバー間のラウンド トリップを複数回行う必要があります。 たとえば、次のテーブル構造では、部署の詳細を取得するために 2 回のラウンド トリップが必要です。 1 回目でマネージャーの ID を含む部署エンティティをフェッチし、2 回目でマネージャーの詳細を従業員エンティティにフェッチします。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE16.png" alt-text="部署エンティティと従業員エンティティの図":::

#### <a name="solution"></a>解決策
データを 2 つのエンティティに格納する代わりに、データを非正規化し、部署エンティティにマネージャーの詳細のコピーを保持します。 次に例を示します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE17.png" alt-text="非正規化され、結合された部署エンティティの図":::

格納されている部署エンティティにはこれらのプロパティがあるため、ポイント クエリを使用して、部署に関して必要なすべての詳細を取得できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 一部のデータを重複して格納するため、多少コストがかかります。 Table storage への要求が減ることによるパフォーマンスの向上は、通常、ストレージ コストのわずかな増加よりも有益です。 さらに、このコストは、部署の詳細を取得するために必要なトランザクション数の削減によって部分的に相殺されます。  
* マネージャーに関する情報を格納する 2 つのエンティティの一貫性を維持する必要があります。 EGT を使用して 1 回のアトミックなトランザクションで複数のエンティティを更新することによって、一貫性の問題に対処できます。 この場合、部署エンティティと、部署マネージャーの従業員エンティティは同じパーティションに格納されます。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
関連情報を頻繁に検索する必要がある場合に、このパターンを使用します。 このパターンを使用すると、クライアントが必要なデータを取得するために実行する必要があるクエリの数が減少します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>複合キー パターン
クライアントで単一のポイント クエリを使用して関連するデータを検索できるようにするには、複合 `RowKey` 値を使用します。  

#### <a name="context-and-problem"></a>コンテキストと問題
リレーショナル データベースでは、単一のクエリで関連するデータをクライアントに返すために、クエリでよく結合を使用します。 たとえば、従業員 ID を使用して、その従業員の業績と評価データが含まれている関連エンティティの一覧を検索する場合があります。  

次の構造を使用して Table storage に従業員エンティティを格納しているとします。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE18.png" alt-text="従業員エンティティの図":::

また、各年度の従業員の評価と業績に関する履歴データを格納し、この情報に年度別でアクセスできる必要もあります。 それには、次の構造でエンティティを格納する別のテーブルを作成するという方法があります。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE19.png" alt-text="従業員レビュー エンティティの図":::

この方法では、単一の要求でデータを取得できるようにするには、一部の情報 (姓や名など) を新しいエンティティに複製する必要があります。 ただし、EGT を使用しても 2 つのエンティティをアトミックには更新できないため、厳密な一貫性を保つことはできません。  

#### <a name="solution"></a>解決策
次の構造のエンティティを使用して、元のテーブルに新しい種類のエンティティを格納します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE20.png" alt-text="複合キーを持つ従業員エンティティの図":::

`RowKey` が複合キーになっていることに注目してください。これは、従業員 ID とレビュー データの年で構成されています。 これにより、1 つのエンティティに対する 1 つの要求で、従業員のパフォーマンスを取得し、データを確認することができます。  

次の例では、Sales 部署の従業員 000123 など、特定の従業員のすべての評価データを取得する方法を示しています。  

$filter=(PartitionKey eq 'Sales')、(RowKey ge 'empid_000123')、(RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* **000123_2012** のような、`RowKey` 値の解析を容易にする適切な区切り文字を使用する必要があります。  
* また、このエンティティは、同じ従業員の関連データを含む他のエンティティと同じパーティションに格納します。 こうすると、EGT を使用して、厳密な一貫性を維持できます。
* このパターンが適切であるかどうかを判断するには、データを照会する頻度を考慮する必要があります。 たとえば、評価データにはあまり頻度にアクセスせず、メインの従業員データには頻度にアクセスする場合は、それらのデータを別々のエンティティとして保持する必要があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
頻繁に照会する関連エンティティを 1 つ以上格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類を使用する](#work-with-heterogeneous-entity-types)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>ログ テール パターン
逆の日付と時間順でソートする `RowKey` 値を 使用して、最も新しく追加された *n* 件のエンティティを取得します。  

> [!NOTE]
> Azure Cosmos DB で Azure Table API によって返されるクエリ結果は、パーティション キーや行キーの順序にはなりません。 そのため、このパターンは Table storage には適していますが、Azure Cosmos DB には適していません。 機能の相違に関する詳細なリストについては、[Azure Cosmos DB の Table API と Azure Table Storage の間の相違](table-api-faq.md#table-api-vs-table-storage)に関するページを参照してください。

#### <a name="context-and-problem"></a>コンテキストと問題
直近に作成されたエンティティ (従業員が提出した経費請求を日時の新しいものから 10 件など) の取得が必要となる場合がよくあります。 テーブル クエリは、セットから最初の *n* 個のエンティティを返す `$top` クエリ操作をサポートします。 セット内の最後の *n* 個のエンティティを返す同等のクエリ操作はありません。  

#### <a name="solution"></a>解決策
日付/時刻の逆順で自然に並べ替える `RowKey` を使用してエンティティを格納し、最新のエントリが常にテーブルの最初のエントリになるようにします。  

たとえば、従業員が提出した経費請求を日時の新しいものから 10 件取得できるようにする場合は、現在の日時から派生した逆順のティック値を使用できます。 次の C# のコード サンプルは、最新から最古の順で並べ替える `RowKey` 用の適切な "反転ティック" 値を作成する方法の 1 つを示しています。  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

次のコードを使用すると、日付/時刻値に戻すことができます。  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

テーブル クエリは次のようになります。  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 文字列値が正しく並び替わるように、逆順のティック値の先頭にゼロをパディングする必要があります。  
* パーティション レベルのスケーラビリティ ターゲットに注意する必要があります。 ホット スポット パーティションが発生しないように注意してください。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
日時の逆順でエンティティにアクセスする必要がある場合、または追加日時の新しい順にエンティティにアクセスする必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [先頭または末尾に追加するアンチ パターン](#prepend-append-anti-pattern)  
* [エンティティの取得](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>大量削除パターン
すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。 エンティティを削除するときは、テーブル自体を削除することになります。  

#### <a name="context-and-problem"></a>コンテキストと問題
多くのアプリケーションでは、クライアント アプリケーションで使用する必要がなくなった古いデータや、他の記憶域メディアにアーカイブした古いデータを削除します。 通常は、日付でそうしたデータを特定します。 たとえば、60 日以上前のすべてのサインイン要求のレコードを削除する必要があるとします。  

1 つ候補となるのは、`RowKey` でサインイン要求の日付と時刻を使用する設計です。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE21.png" alt-text="ログイン試行エンティティの図":::

この方法では、アプリケーションが別のパーティションで各ユーザーのサインイン エンティティを挿入したり削除したりできるため、パーティションのホット スポットを回避できます。 ただし、多数のエンティティがある場合、このアプローチはコストが高く、時間がかかる可能性があります。 まず、削除するすべてのエンティティを識別するためにテーブル スキャンを実行する必要があり、次に、古いエンティティをそれぞれ削除する必要があります。 複数の削除要求をバッチ処理として EGT にまとめることで、古いエンティティを削除するのに必要なサーバーへのラウンド トリップの回数を減らすことができます。  

#### <a name="solution"></a>解決策
サインイン試行の日付ごとに異なるテーブルを使用します。 前述のエンティティの設計を使用すると、エンティティを挿入する際にホットスポットを回避できます。 毎日数百や数千もの個々のサインイン エンティティを検索して削除する代わりに、毎日テーブルを 1 つ削除する (単一のストレージ操作) だけで古いエンティティを削除できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 特定のエンティティの検索、他のデータとのリンク、集計情報の生成など、データの他の用途もサポートするように設計していますか。  
* 新しいエンティティを挿入する際にホットスポットを回避するように設計していますか。  
* テーブル名を削除した後に同じテーブル名を再利用する場合に待ち時間が必要になります。 常に一意のテーブル名を使用することをお勧めします。  
* Table storage ではアクセス パターンを学習して、ノード全体にパーティションを分散しますが、最初に新しいテーブルを使用するときは何らかのレート制限が行われます。 新しいテーブルを作成する必要がある頻度を検討する必要があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
同時に削除する必要があるエンティティが大量にある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)
* [エンティティの変更](#modify-entities)  

### <a name="data-series-pattern"></a>データ系列のパターン
データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

#### <a name="context-and-problem"></a>コンテキストと問題
一般的なシナリオとして、通常、アプリケーションで一度にすべて取得する必要があるデータ系列を格納するというものがあります。 たとえば、アプリケーションで 1 時間ごとに各従業員が送信した IM メッセージの数を記録し、後でその情報を使用して、各ユーザーが過去 24 時間以内に送信したメッセージの数をプロットするとします。 設計の 1 つとして、従業員ごとに 24 個のエンティティを格納します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE22.png" alt-text="メッセージ統計情報エンティティの図":::

この設計では、アプリケーションでメッセージのカウント値を更新する必要があるときに、各従業員の更新するエンティティを簡単に検索して更新できます。 ただし、情報を取得して、過去 24 時間の活動のグラフをプロットするためには、24 個のエンティティを取得する必要があります。  

#### <a name="solution"></a>解決策
次の設計を使用し、各時間のメッセージ数をそれぞれ別のプロパティに格納します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE23.png" alt-text="区切られたプロパティのメッセージ統計情報エンティティを示す図":::

この設計では、マージ操作を使用して、特定の時間の従業員のメッセージ数を更新できます。 これで、単一のエンティティに対する単一の要求を使用して、チャートをプロットするために必要なすべての情報を取得できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* データ系列全体が単一のエンティティに収まらない場合 (エンティティは最大 252 個のプロパティを持つことができます)、BLOB などの代わりのデータ ストアを使用します。  
* 複数のクライアントが同時にエンティティを更新する場合は、**ETag** を使用して、オプティミスティック コンカレンシーを実装します。 クライアントがたくさんある場合は、競合が大量に発生する可能性があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
個々のエンティティに関連付けられているデータ系列を更新したり取得したりする必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [ラージ エンティティ パターン](#large-entities-pattern)  
* [マージまたは置換](#merge-or-replace)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) (格納するデータ系列を Blob に格納している場合)  

### <a name="wide-entities-pattern"></a>ワイド エンティティ パターン
複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  

#### <a name="context-and-problem"></a>コンテキストと問題
個々のエンティティが持つことができるプロパティは、(必須のシステム プロパティを除き) 252 個までです。また、格納できるデータは合計で 1 MB までです。 リレーショナル データベースでは、通常、新しいテーブルを追加し、その新しいテーブルと 1 対 1 のリレーションシップを作成することによって、行のサイズに関するさまざまな制限を回避します。  

#### <a name="solution"></a>解決策
Table storage を使用することで、複数のエンティティを格納して、252 を超えるプロパティを持つ単一の大きなビジネス オブジェクトを作成できます。 たとえば、過去 365 日の間に各従業員が送信した IM メッセージの数を格納する場合は、スキーマの異なる 2 つのエンティティを使用する次のデザインを使用できます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE24.png" alt-text="Rowkey 01 のメッセージ統計情報エンティティと Rowkey 02 のメッセージ統計情報エンティティを示す図":::

両方のエンティティを更新しないとエンティティどうしの同期が維持されない変更を加える必要がある場合は、EGT を使用できます。 それ以外の場合は、単一のマージ操作を使用して、特定の日のメッセージ数を更新できます。 個々の従業員のすべてのデータを取得するには、両方のエンティティを取得する必要があります。 これは、`PartitionKey` と `RowKey` 値の両方を使用する 2 つの効率的な要求で行うことができます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、次の点に注意してください。  

* 論理エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (各物理エンティティを取得するトランザクション) が必要です。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
サイズやプロパティの数が Table storage の個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)
* [マージまたは置換](#merge-or-replace)

### <a name="large-entities-pattern"></a>大型エンティティ パターン
大規模なプロパティの値を格納する BLOB ストレージを使用します。  

#### <a name="context-and-problem"></a>コンテキストと問題
個々のエンティティに格納できるデータは合計で 1 MB までです。 1 つまたは複数のプロパティに格納される値でエンティティの合計サイズが 1 MB を超える場合は、Table storage にエンティティ全体は格納できません。  

#### <a name="solution"></a>解決策
1 つ以上のプロパティに大量のデータが含まれているためにエンティティのサイズが 1 MB を超える場合は、BLOB ストレージにデータを格納し、エンティティのプロパティに BLOB のアドレスを格納できます。 たとえば、従業員の写真を BLOB ストレージに格納し、写真へのリンクを従業員エンティティの `Photo` プロパティに格納できます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE25.png" alt-text="Photo が BLOB ストレージを指す文字列の従業員エンティティを示す図":::

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* Table storage 内のエンティティと、BLOB ストレージ内のデータの間の最終的な一貫性を保つには、[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)を使用してエンティティを維持します。
* エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (エンティティを取得するトランザクションと BLOB データを取得するトランザクション) が必要です。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
サイズが Table storage の個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [ワイド エンティティパターン](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>先頭または末尾に追加するアンチパターン
大量に挿入する場合に、挿入を複数のパーティションに分散させることで、スケーラビリティを向上させます。  

#### <a name="context-and-problem"></a>コンテキストと問題
格納されているエンティティの先頭または末尾にエンティティを追加すると、通常は、連続するパーティションの最初または最後のパーティションに新しいエンティティが追加されます。 この場合、特定の時点におけるすべての挿入が同じパーティションで発生し、ホットスポットになります。 これは、Table storage が挿入を複数のノードに負荷分散することを妨げ、アプリケーションがパーティションのスケーラビリティ ターゲットに達する原因となる可能性があります。 たとえば、従業員によるネットワークとリソースへのアクセスをログに記録するアプリケーションの場合を考えてみます。 トランザクションの量が個々のパーティションのスケーラビリティ ターゲットに達した場合、次のようなエンティティ構造が原因で、現在の時間のパーティションがホットスポットになる可能性があります。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE26.png" alt-text="従業員エンティティの図":::

#### <a name="solution"></a>解決策
代わりに次のエンティティ構造を使用すると、アプリケーションでイベントをログに記録する際に特定のパーティションのホットスポットを回避できます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE27.png" alt-text="年、月、日、時間、イベント ID から構成される RowKey の従業員エンティティを示す図":::

次の例では 2 つのキー `PartitionKey` と `RowKey` がどのように複合キーになっているか注意してください。 `PartitionKey` は部署と従業員の両方の ID を使用して複数のパーティションにログを配布します。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 挿入時のホット パーティションの発生を回避する代わりのキー構造でクライアント アプリケーションが実行するクエリを効率的にサポートしていますか。  
* 予想されるトランザクションの量から判断して、個々のパーティションのスケーラビリティ ターゲットに達し、Table storage によって調整される可能性がありますか。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
トランザクションの量により、ホット パーティションにアクセスすると Table storage によってレート制限される可能性がある場合は、先頭または末尾に追加するアンチパターンを使用しないでください。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [ログ テールパターン](#log-tail-pattern)  
* [エンティティの変更](#modify-entities)  

### <a name="log-data-anti-pattern"></a>ログ データのアンチパターン
ログ データの格納には通常、Table storage ではなく BLOB ストレージを使用します。  

#### <a name="context-and-problem"></a>コンテキストと問題
ログ データの一般的なユース ケースは、特定の日付/時刻範囲のログ エントリを選択して取得するというものです。 たとえば、特定の日付の 15:04 から 15:06 までの間にアプリケーションがログに記録したすべてのエラー メッセージと重大なメッセージを検索するとします。 ログ エンティティを保存するパーティションを決定するために、ログ メッセージの日付と時刻を使用することは望まないものとします。 その結果、どの特定の時点においても、すべてのログ エンティティが同じ `PartitionKey` 値を共有するため、ホット パーティションが発生します (「[先頭または末尾に追加するアンチパターン](#prepend-append-anti-pattern)」を参照)。 たとえば、ログ メッセージに関する以下のエンティティ スキーマでは、アプリケーションが現在の日付や時刻についてパーティションにあらゆるログ メッセージを書き込むことになるため、ホット パーティションの問題が発生します。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE28.png" alt-text="ログ メッセージ エンティティの図":::

この例では、ログ メッセージが日付/時刻の順序で並べ替えられるように、`RowKey` にはログ メッセージの日付と時刻が含まれています。 複数のログメッセージが同じ日付と時刻を共有する場合、`RowKey` にはメッセージ ID も含まれます。  

別の方法は、アプリケーションに確実に パーティション範囲にわたってメッセージを書き込ませる `PartitionKey` の使用です。 たとえば、ログ メッセージのソースで多数のパーティションにメッセージを配信できるようになっている場合には、以下のエンティティ スキーマを使用できます。  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE29.png" alt-text="ログ メッセージ エンティティの図":::

ただし、このスキーマには問題があります。特定のタイム スパンに記録されたログ メッセージをすべて取得するときには、テーブル内のパーティションを逐一検索する必要があるからです。

#### <a name="solution"></a>解決策
前のセクションでは、ログ エントリの保存先として Table storage を使用した場合に生じる問題について説明し、その解決策として、完璧とは言いがたいものの 2 つの設計を紹介しました。 1 つ目に紹介した方法には、ホット パーティションが発生し、ログ メッセージの書き込みのパフォーマンスが低下するリスクがあります。 これに対して 2 つ目の方法は、特定のタイム スパンについてログ メッセージを取得しようとした場合に、テーブル内のパーティションを逐一スキャンしなければならないため、クエリのパフォーマンスが低下するという問題がありました。 BLOB ストレージなら、ここで取り上げたシナリオについて前の 2 つよりも優れたソリューションとなることができます。このため、Azure Storage analytics が収集したログ データを保存するときにも、この BLOB ストレージが使用されています。  

このセクションでは、Storage analytics が BLOB ストレージにログ データを格納する流れの概要を説明し、範囲を指定してクエリを実行することが多いデータを保存する際にこのアプローチがどのように役立つかを見ていきます。  

Storage analytics では、ログ メッセージを一定の形式で区切ったものを、複数の BLOB に格納します。 区切りに使用する形式は、クライアント アプリケーション側でログ メッセージのデータ解析を円滑に完了できるものになっています。  

Storage analytics が BLOB に対して使用している名前付け規則は、検索対象のログ メッセージが含まれる BLOB の場所を特定できるようなものになっています。 たとえば、"queue/2014/07/31/1800/000001.log" という名前の BLOB であれば、2014 年 7 月 31 日の 18:00 から始まる時間の Queue サービスと関係があるログ メッセージが格納されています。 "000001" という部分は、この期間の最初のログ ファイルであることを示しています。 このほか、Storage analytics では BLOB のメタデータの一環として、ファイルに保存されている最初と最後のログ メッセージのタイムスタンプを記録します。 BLOB ストレージ用の API を使用すると、名前のプレフィックスに基づいてコンテナーから BLOB を探すことができます。 18:00 から始まる 1 時間のキュー ログ データを含むすべての BLOB を探すには、"queue/2014/07/31/1800" というプレフィックスを使用できます。  

Storage analytics は内部のバッファーにログ メッセージを保管したうえで、ログ エントリのバッチの最新版を使って定期的に BLOB を更新したり、新しい BLOB を作成したりします。 これによって、BLOB ストレージに書き込みを実行する回数が少なくなります。  

独自のアプリケーションに同様のソリューションを実装する場合は、信頼性とコストとスケーラビリティのトレードオフを管理する方法を検討してください。 つまり、すべてのログ エントリを発生次第 BLOB ストレージに書き込む効果を、アプリケーションで更新をバッファリングしてバッチで BLOB ストレージに書き込む場合と比較して評価します。  

#### <a name="issues-and-considerations"></a>問題と注意事項
ログ データの保存方法を決めるときには、以下の点に注意する必要があります。  

* ホット パーティションが発生しないような設計のテーブルを作成すると、ログ データに対するアクセス効率が低下することがあります。  
* ログ データを処理するときには多くの場合、クライアント側で多くのレコードを読み込む必要があります。  
* ログ データは構造化されていることが多いものの、BLOB ストレージの方が優れたソリューションになることがあります。  

### <a name="implementation-considerations"></a>実装時の注意事項
このセクションでは、ここまでのセクションで説明したパターンを実装する際に念頭に置く必要がある点をいくつか説明します。 このセクションで示したコード例は、ほとんどが C# で書かれ、ストレージ クライアント ライブラリ (本稿執筆時点のバージョンは 4.3.0) を使用しています。  

### <a name="retrieve-entities"></a>エンティティの取得
「 [クエリに対応した設計](#design-for-querying)」で説明したように、最も効率的なクエリはポイント クエリです。 ただ、時として多数のエンティティを同時に取得することも必要になります。 このセクションでは、ストレージ クライアント ライブラリを使ってエンティティを取得するときによく使用される方法をいくつか紹介します。  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>ストレージ クライアント ライブラリを使用してポイント クエリを実行する
ポイント クエリを実行する最も簡単な方法は、**Retrieve** テーブル操作を使用することです。 次の C# コード スニペットに示すように、この操作は、`PartitionKey` の値が "Sales"、`RowKey` の値が "212" であるエンティティを取得します。  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

この例では、取得するエンティティが `EmployeeEntity` 型であることをどのように想定しているかに注意してください。  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>LINQ を使用して複数のエンティティを取得する
複数のエンティティを取得するには、ストレージ クライアント ライブラリとともに LINQ を使用し、**where** 句のあるクエリを指定します。 テーブル スキャンを回避するには、where 句の `PartitionKey` 値と、可能であれば `RowKey` 値をインクルードし、テーブルとパーティションのスキャンを避けます。 Table storage は、where 句で一部の比較演算子 (より大きい、以上、より小さい、以下、等しい、等しくない) のみサポートしています。 次の C# のコード スニペットは、Sales 部署 (`PartitionKey` が部署名を格納していると仮定) の中で、姓が "B" (`RowKey` が姓を格納していると仮定) で始まるすべての従業員を検索 します。  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

パフォーマンスを確保するため、クエリで `RowKey` と `PartitionKey` の両方をどのように指定するか注意してください。  

次のコード サンプルは、fluent API を使用したのと同等の機能を示しています (fluent API 全般の詳細については、[fluent API を設計するためのベスト プラクティス](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)に関する記事を参照してください)。  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> このサンプルでは、 3 つのフィルター条件を含んだ複数の `CombineFilters` メソッドをネストしています。  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>1 件のクエリで大量のエンティティを取得する
最適なクエリは `PartitionKey` 値と `RowKey` 値に基づいて個別のエンティティを返します。 ところが、場合によっては同じパーティション、ときには多数のパーティションから、多数のエンティティを返すことが必要になります。 そのようなときには必ず、アプリケーションのパフォーマンスを綿密にテストする必要があります。  

Table storage に対するクエリは、一度に 1,000 件までのエンティティを返すことができ、最大 5 秒間実行できます。 次のいずれかに該当する場合、Table storage は継続トークンを返して、クライアント アプリケーションが次のエンティティ セットを要求できるようにします。

- 結果セットに 1,000 件を超えるエンティティが含まれている。
- クエリが 5 秒以内に完了しなかった。
- クエリがパーティション境界を越えている。 

継続トークンの動作の詳細については、[クエリのタイムアウトと改ページ](https://msdn.microsoft.com/library/azure/dd135718.aspx)に関する記事を参照してください。  

ストレージ クライアント ライブラリを使用している場合には、Table storage からエンティティが返されるたびに継続トークンが自動で処理されます。 たとえば、次の C# コード サンプルは、Table storage が応答で継続トークンを返す場合に、継続トークンを自動的に処理します。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

以下の C# コード サンプルでは、継続トークンの処理を明示的に記述しています。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

継続トークンを明示的に使用すると、アプリケーションが次のセグメントに相当するデータを取得するタイミングを制御できます。 たとえば、クライアント アプリケーションで、テーブルに格納されているエンティティをユーザーがページ表示できる場合に、ユーザーがあえて、クエリによって取得されたすべてのエンティティをページ表示しない場合があります。 アプリケーションは、ユーザーが現在のセグメントのすべてのエンティティをページ表示し終えた時点ではじめて、継続トークンを使用して次のセグメントを取得します。 この方法には、いくつかの利点があります。  

* Table storage から取得する、またネットワーク経由で移動するデータの量を制限できます。  
* .NET で非同期 I/O を実行できます。  
* 継続トークンをシリアル化して永続記憶装置に保存できるため、アプリケーションがクラッシュした場合でも処理を継続できます。  

> [!NOTE]
> 継続トークンは通常、エンティティ 1,000 件を 1 つのセグメントにして返しますが、含まれる数が少なくなることもあります。 これは、検索条件に一致する最初の n 個のエンティティを返すために、**Take** を使用して、クエリが返すエントリの数を制限する場合にも当てはまります。 Table storage は、n 個よりも少ないエンティティを含むセグメントを、残りのエンティティを取得するための継続トークンと共に返す場合があります。  
> 
> 

以下の C# コードは、1 つのセグメントで返されるエンティティの数を変更するためのものです。  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>サーバー側のプロジェクション
1 つのエンティティには最大で 255 個のプロパティを格納でき、エンティティの最大サイズは 1 MB です。 テーブルに対してクエリを実行してエンティティを取得する際、すべてのプロパティが必要ない場合は、データの不要な転送を避けることができます (遅延とコストの削減につながります)。 サーバー側のプロジェクションを使えば、必要なプロパティのみを転送できます。 次の例は、クエリによって選択されたエンティティから `Email` プロパティ (`PartitionKey`、`RowKey`、`Timestamp`、`ETag` と連動) のみを取得しています。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

`RowKey` 値が取得するプロパティのリストに含まれていなくても、どのように利用できるか注意してください。  

### <a name="modify-entities"></a>エンティティの変更
ストレージ クライアント ライブラリを使えば、Table storage に格納されたエンティティを、挿入、削除、更新の各操作によって変更できます。 また、EGT を使えば複数の挿入、更新、削除の操作をバッチ処理で行えるため、必要なラウンド トリップの回数が減り、ソリューションのパフォーマンスが高まります。  

ストレージ クライアント ライブラリが EGT を実行したときにスローされるケースの例外として、通常、バッチ処理の失敗を招いたエンティティのインデックスが含まれます。 これは EGT を使うコードをデバッグする際に役立ちます。  

クライアント アプリケーションでのコンカレンシーと更新操作の処理方法に設計が及ぼす影響についても考慮が必要です。  

#### <a name="managing-concurrency"></a>コンカレンシーを管理する
既定では、Table storage は個々のエンティティのレベルで挿入、マージ、削除の各操作に対してオプティミスティック コンカレンシー チェックを実装しますが、クライアントは、Table storage がこれらのチェックをバイパスするよう強制することもできます。 詳細については、「[Microsoft Azure Storage でのコンカレンシー制御の管理](../storage/common/storage-concurrency.md)」を参照してください。  

#### <a name="merge-or-replace"></a>マージまたは置換
`TableOperation` クラスの `Replace` メソッドは、Table storage 内のエンティティ全体を常に置き換えます。 格納されたエンティティに存在するプロパティを要求に含めない場合、要求により、格納されたエンティティからそのプロパティが削除されます。 格納されたエンティティからプロパティを明示的に削除しない場合は、すべてのプロパティを要求に含める必要があります。  

`TableOperation` クラスの `Merge` メソッドを使用すると、エンティティを更新するときに Table storage に送信するデータの量を削減できます。 `Merge` メソッドは、格納されているエンティティのプロパティを、要求に含まれているエンティティのプロパティ値に置き換えます。 このメソッドは、格納されているエンティティのプロパティで、要求に含まれていないものはそのままにします。 ラージ エンティティがあり、要求で少数のプロパティのみを更新する必要があるときに便利な処理です。  

> [!NOTE]
> エンティティが存在しない場合、`*Replace` および `Merge` メソッドは失敗します。 存在しない場合は、代わりに、`InsertOrReplace` と `InsertOrMerge` メソッドを使用して新しいエンティティを作成します。  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>異種のエンティティ種類を使用する
Table storage は*スキーマレス*のテーブル ストアです。 これは、1 つのテーブルが複数の種類のエンティティを格納できるため、非常に柔軟な設計が提供できることを意味します。 次の例は、従業員エンティティと部署エンティティの両方を格納したテーブルを示しています。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

各エンティティには、`PartitionKey`、`RowKey`、`Timestamp` の値が必要なことは変わりませんが、任意のプロパティ セットを持たせることができます。 さらに、エンティティの種類を示すものがありません (エンティティの種類に関する情報を格納していない場合)。 エンティティの種類を識別する方法は 2 とおりあります。  

* `RowKey` (または `PartitionKey`) にエンティティ型を追加。 たとえば、`RowKey` 値として `EMPLOYEE_000123` または `DEPARTMENT_SALES`。  
* 次の表に示すように、個別のプロパティを使用してエンティティの種類を記録します。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>部署</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

最初のオプションでは、エンティティ型を `RowKey` の先頭に付けると、異なる種類の 2 つのエンティティが同じキー値にある可能性がある場合に便利です。 この方法なら、パーティションに同じ種類のエンティティのグループ化もできます。  

ここで説明する手法は、[継承関係](#inheritance-relationships)に関する説明に特に関連しています。  

> [!NOTE]
> エンティティの種類の値にバージョン番号を追加して、クライアント アプリケーションで POCO オブジェクトを発展させ、さまざまなバージョンを操作できるようにすることを検討してください。  
> 
> 

このセクションの残りの部分では、同じテーブル内の異なる種類のエンティティを操作しやすくするストレージ クライアント ライブラリの機能について説明します。  

#### <a name="retrieve-heterogeneous-entity-types"></a>異なる種類のエンティティを取得する
ストレージ クライアント ライブラリを使えば、3 とおりの方法で複数の種類のエンティティを操作できます。  

特定の `RowKey` と `PartitionKey` の値で格納されているエンティティの型がわかっている場合は、エンティティを取得するときにエンティティ型を指定できます。 このことは、`EmployeeEntity` 型のエンティティを取得する前の 2 つの例で示しました:「[ストレージ クライアント ライブラリを使用してポイント クエリを実行する](#run-a-point-query-by-using-the-storage-client-library)」および「[LINQ を使用して複数のエンティティを取得する](#retrieve-multiple-entities-by-using-linq)」。  

2 番目のオプションは、具象 POCO エンティティ型ではなく `DynamicTableEntity` 型 (プロパティ バッグ) を使用することです。 このオプションを選択すると、エンティティを .NET 型にシリアル化および逆シリアル化する必要がないため、パフォーマンスが向上する場合もあります。 次の C# コードは、テーブルから潜在的にさまざまな種類の複数のエンティティを取得しますが、すべてのエンティティを `DynamicTableEntity` インスタンスとして返します。 `EntityType` プロパティを使用して各エンティティの種類を決定します。  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

その他のプロパティを取得するには、`DynamicTableEntity` クラスの `Properties` プロパティに対して `TryGetValue` メソッドを使用する必要があります。  

3 番目のオプションは、`DynamicTableEntity` 型と `EntityResolver` インスタンスを使用して結合することです。 この方法なら、同じクエリで複数の POCO 型を解決できます。 この例では、`EntityResolver` デリゲートは `EntityType` プロパティを使用して、クエリによって返されるエンティティの 2 つの種類を区別します。 `Resolve` メソッドは `resolver` デリゲートを使用して、`DynamicTableEntity` のインスタンスを `TableEntity` のインスタンスに解決します。  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>異なる種類のエンティティを変更する
エンティティの種類がわからなくても削除はできますが、挿入はできません。 ただし、エンティティの種類がわからない場合は、POCO エンティティ クラスを使用せず、`DynamicTableEntity` 型を使用してエンティティを更新します。 次のコード サンプルでは、1 つのエンティティを取得し、`EmployeeCount` プロパティが存在するか、更新前に確認しています。  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>共有アクセス署名を使用してアクセスを制御する
共有アクセス署名 (SAS) トークンを使用すると、クライアント アプリケーションで、Table storage に対して直接認証しなくてもテーブル エンティティを直接変更 (およびクエリ) できるようになります。 通常、アプリケーションで SAS を使うと、次の 3 つのメリットが得られます。  

* デバイスで Table storage のエンティティにアクセスして変更できるようにするために、安全ではないプラットフォーム (モバイル デバイスなど) にストレージ アカウント キーを配布する必要がありません。  
* エンティティの管理で Web ロールと worker ロールが実行する作業の一部をオフロードできます。 エンド ユーザーのコンピューターやモバイル デバイスなどのクライアント デバイスにオフロードできます。  
* 制約と時間制限のあるアクセス許可のセットをクライアントに割り当てることができる (読み取り専用アクセスを特定のリソースに許可するなど)。  

Table storage での SAS トークンの使用について、詳しくは[共有アクセス署名 (SAS) の使用](../storage/common/storage-dotnet-shared-access-signature-part-1.md)に関するページを参照してください。  

ただし、クライアント アプリケーションを Table storage 内のエンティティに許可する SAS トークンを生成する必要があることは変わりません。 これは、ストレージ アカウント キーに安全にアクセスできる環境で行ってください。 通常は、Web ロールまたは worker ロールを使って SAS トークンを生成し、エンティティへのアクセスを必要とするクライアント アプリケーションに配布します。 SAS トークンの生成とクライアントへの配布にもやはりオーバーヘッドが伴うため、特に大量に扱うシナリオでは、このオーバーヘッドを減らす最適な方法を検討する必要があります。  

テーブル内のエンティティのサブセットへのアクセスを付与する SAS トークンを生成できます。 既定では、テーブル全体に対する SAS トークンを作成します。 ただし、`PartitionKey` 値の範囲、または `PartitionKey` 値と `RowKey` 値の範囲へのアクセスを SAS トークンが許可するように指定することもできます。 システムの個々のユーザーに SAS トークンが生成されるようにすれば、各ユーザーの SAS トークンによってアクセスが許可されるのは、Table storage 内にあるユーザー独自のエンティティだけになります。  

### <a name="asynchronous-and-parallel-operations"></a>非同期と並列操作
要求を複数のパーティションに分散させている場合は、非同期または並列クエリを使ってスループットとクライアントの応答性を向上させることができます。
たとえば、テーブルに並列的にアクセスする複数の worker ロール インスタンスを使用する場合などです。 個別の worker ロールで特定のパーティション セットのみを処理することも可能であるほか、テーブル内のすべてのパーティションにアクセスできる worker ロール インスタンスを複数実装することも可能です。  

クライアント インスタンスでは、ストレージ操作を非同期的に実行することでスループットを高めることができます。 ストレージ クライアント ライブラリを使えば、非同期クエリと変更を簡単に記述できます。 たとえば、次の C# コードに示すように、パーティション内のすべてのエントリを取得する同期メソッドをベースとして利用できます。  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

このコードを次のように少し変更して、クエリが非同期的に実行されるようにします。  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

* メソッドのシグネチャは `async` 修飾子を含み、`Task` インスタンスを返します。  
* メソッドは、`ExecuteSegmented` メソッドを呼び出して結果を取得する代わりに、`ExecuteSegmentedAsync` メソッドを呼び出すようになりました。 メソッドは `await` 修飾子を使用して結果を非同期に取得します。  

クライアント アプリケーションは、`department` パラメーターの値を変えて、このメソッドを複数回呼び出すことができます。 各クエリは個別のスレッドで実行されます。  

`IEnumerable` インターフェイスは非同期列挙型をサポートしていないため、`TableQuery` クラスの `Execute` メソッドには非同期バージョンはありません。  

エンティティを非同期的に挿入、更新、削除できます。 次の C# の例は、従業員エンティティを挿入または置換する単純な同期メソッドです。  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

このコードを次のように少し変更して、更新が非同期的に実行されるようにすることができます。  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

* メソッドのシグネチャは `async` 修飾子を含み、`Task` インスタンスを返します。  
* メソッドは、`Execute` メソッドを呼び出してエンティティを更新する代わりに、`ExecuteAsync` メソッドを呼び出すようになりました。 メソッドは `await` 修飾子を使用して結果を非同期に取得します。  

クライアント アプリケーションは、これと同じように非同期メソッドを複数回呼び出すことができます。各メソッドの呼び出しは別々のスレッドで実行されます。  

