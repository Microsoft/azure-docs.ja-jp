---
title: Azure Cosmos DB インデックス作成ポリシー
description: Azure Cosmos DB でのインデックス作成の自動化とパフォーマンス向上のために、既定のインデックス作成ポリシーを構成および変更する方法について説明します。
author: timsander1
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 08/19/2020
ms.author: tisande
ms.openlocfilehash: f723d7ac218869313f02212d27d9f96b74bb7f0f
ms.sourcegitcommit: d661149f8db075800242bef070ea30f82448981e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/19/2020
ms.locfileid: "88607524"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Azure Cosmos DB でのインデックス作成ポリシー

Azure Cosmos DB では、すべてのコンテナーに、コンテナーの項目のインデックスを作成する方法を指示するインデックス作成ポリシーがあります。 新しく作成したコンテナーの既定のインデックス作成ポリシーでは、あらゆる項目のあらゆるプロパティのインデックスが作成され、任意の文字列または数値に範囲インデックスが適用されます。 これにより、インデックス作成とインデックス管理を事前に考慮することなく、高いクエリ パフォーマンスを得ることができます。

状況によっては、この自動動作を、自分の要件にさらに適合するようにオーバーライドできます。 "*インデックス作成モード*" を設定し、"*プロパティ パス*" を含めるか除外することで、コンテナーのインデックス作成ポリシーをカスタマイズできます。

> [!NOTE]
> この記事で説明するインデックス作成ポリシーの更新方法は、Azure Cosmos DB の SQL (Core) API にのみ適用されます。 インデックス作成については、[Azure Cosmos DB の MongoDB 用 API](mongodb-indexing.md) に関するページを参照してください

## <a name="indexing-mode"></a>インデックス作成モード

Azure Cosmos DB では 2 つのインデックス作成モードがサポートされます。

- **同期**: 項目を作成、更新、削除すると、それに同期してインデックスが更新されます。 つまり、読み取りクエリの一貫性は、[アカウント用に構成された整合性](consistency-levels.md)になります。
- **None**:コンテナーでインデックス作成が無効になっています。 これは、コンテナーがセカンダリ インデックスを必要としない純粋なキー値ストアとして使用される場合に一般的に使用されます。 一括操作のパフォーマンスを改善する目的で使用することもできます。 一括操作が完了したら、インデックス モードを Consistent に設定し、完了まで [IndexTransformationProgress](how-to-manage-indexing-policy.md#dotnet-sdk) を利用して監視できます。

> [!NOTE]
> Azure Cosmos DB では、Lazy インデックス作成モードもサポートされます。 Lazy 方式のインデックスではインデックス更新の優先順位が低く、エンジンが他に何も作業をしていないときに実行されます。 結果的に、クエリの結果に**一貫性がなくなったり、不完全になったり**します。 Cosmos コンテナーに対してクエリを実行する場合は、Lazy インデックス作成を選択しないでください。 2020 年 6 月、新しいコンテナーへの Lazy インデックス作成モードの設定はもう許可されないという変更が導入されました。 Azure Cosmos DB アカウントに、Lazy インデックスが設定されたコンテナーが少なくとも 1 つ含まれている場合、このアカウントは自動的に変更から除外されます。 [Azure サポート](https://portal.azure.com/?#blade/Microsoft_Azure_Support/HelpAndSupportBlade) に連絡して、除外を要求することもできます (Lazy インデックスをサポートしない[サーバーレス](serverless.md) モードで Azure Cosmos アカウントを使用している場合を除きます)。

既定では、インデックス作成ポリシーは `automatic` に設定されます。 これはインデックス作成ポリシーの `automatic` プロパティを `true` に設定することで行います。 このプロパティを `true` に設定すると、Azure Cosmos DB で、ドキュメントが書き込まれたときに自動的にインデックスを作成できます。

## <a name="including-and-excluding-property-paths"></a><a id="include-exclude-paths"></a> プロパティ パスを含める/除外する

カスタム インデックス作成ポリシーには、明示的にインデックス作成に含めるかインデックス作成から除外するプロパティ パスを指定できます。 インデックスが作成されるパスの数を最適化することによって、書き込み操作の待ち時間と RU 料金を大幅に削減できます。 これらのパスは、[インデックス作成の概要内のセクションで説明されている方法](index-overview.md#from-trees-to-property-paths)に従って定義され、以下のように追加されます。

- スカラー値 (文字列または数値) へのパスは `/?` で終わる
- 配列の要素は、(`/0` や `/1` ではなく) `/[]` 表記でまとめて処理される
- `/*` ワイルドカードを使用してノードの下の任意の要素を一致させることができる

同じ例をもう一度使用します。

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters` の `employees` パスは `/headquarters/employees/?`

- `locations` の `country` パスは `/locations/[]/country/?`

- `headquarters` の下にあるもののパスは `/headquarters/*`

たとえば、`/headquarters/employees/?` パスを含めることができます。 このパスにより employees プロパティのインデックスが確実に作成されますが、このプロパティ内で入れ子になっている追加の JSON のインデックスは作成されません。

## <a name="includeexclude-strategy"></a>包含/除外戦略

すべてのインデックス作成ポリシーには、含まれるパスまたは除外されるパスのいずれかとしてルート パス `/*` を指定する必要があります。

- インデックスを作成する必要がないパスを選択的に除外するためにルート パスを指定する。 モデルに追加される可能性がある新しいプロパティのインデックスを Azure Cosmos DB で先を見越して作成できるため、これが推奨される方法です。
- インデックスを作成する必要があるパスを選択的に含めるためにルート パスを除外する。

- 英数字や _ (アンダースコア) を含む通常文字から成るパスの場合は、パス文字列を二重引用符で囲んでエスケープする必要はありません ("/path/?" など)。 他の特殊文字を含むパスの場合は、パス文字列を二重引用符で囲んでエスケープする必要があります ("/\"path-abc\"/?" など)。 パスの中に特殊文字が予測される場合は、安全のために、すべてのパスをエスケープすることができます。 機能的には、すべてのパスをエスケープしても、特殊文字を含むパスだけをエスケープしても何も違いはありません。

- システム プロパティ `_etag` は、etag がインデックス作成対象パスに追加されていない限り、既定でインデックス作成から除外されます。

- インデックス作成モードが **[consistent]\(同期\)** に設定されている場合、システム プロパティ `id` と `_ts` には自動的にインデックスが作成されます。

パスを含めたり除外したりするときに、次の属性が見つかる場合があります。

- `kind` には、`range` または `hash` のいずれかを指定できます。 範囲インデックス機能ではハッシュ インデックスのすべての機能が提供されるため、範囲インデックスを使用することをお勧めします。

- `precision` は、含まれるパスのインデックス レベルで定義された数値です。 値 `-1` は、最大有効桁数を示します。 この値は常に `-1` に設定することをお勧めします。

- `dataType` には、`String` または `Number` のいずれかを指定できます。 これは、インデックスが作成される JSON プロパティの種類を示します。

指定しない場合、これらのプロパティには次の既定値が設定されます。

| **プロパティ名**     | **既定値** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` および `Number` |

パスを含めたり除外したりするためのインデックス作成ポリシーの例については、[こちらのセクション](how-to-manage-indexing-policy.md#indexing-policy-examples)を参照してください。

## <a name="includeexclude-precedence"></a>優先順位を含める、または除外する

含まれるパスと除外されるパスに競合がある場合は、より正確なパスが優先されます。

次に例を示します。

**含まれるパス**: `/food/ingredients/nutrition/*`

**除外されるパス**: `/food/ingredients/*`

この場合、含まれるパスはより正確であるため、除外されるパスよりも優先されます。 これらのパスに基づいて、`food/ingredients` パス内または入れ子になっているすべてのデータは、インデックスから除外されます。 例外は、含まれるパス `/food/ingredients/nutrition/*` 内のデータで、インデックスが作成されます。

Azure Cosmos DB の含まれるパスと除外されるパスの優先順位に関するいくつかの規則を次に示します。

- より深いパスは、浅いパスよりも正確です。 たとえば、`/a/b/?` は `/a/?` よりも正確です。

- `/?` は `/*` よりも正確です。 たとえば `/a/?` は `/a/*` よりも正確であるため、`/a/?` が優先されます。

- パス `/*` には、含まれるパスまたは除外されるパスを指定する必要があります。

## <a name="spatial-indexes"></a>空間インデックス

インデックス作成ポリシーで空間パスを定義する場合は、そのパスに適用するインデックスの ```type``` を定義する必要があります。 空間インデックスには、次のような種類があります。

* ポイント

* 多角形

* MultiPolygon

* LineString

既定では、Azure Cosmos DB では空間インデックスは作成されません。 空間 SQL 組み込み関数を使用する場合は、必要なプロパティに対して空間インデックスを作成する必要があります。 空間インデックスを追加するためのインデックス作成ポリシーの例については、[このセクション](sql-query-geospatial-index.md)を参照してください。

## <a name="composite-indexes"></a>複合インデックス

2 つ以上のプロパティを使用する `ORDER BY` 句が含まれるクエリには、複合インデックスが必要です。 また、複合インデックスを定義して、多くの等値クエリと範囲クエリのパフォーマンスを向上させることもできます。 既定では、複合インデックスは定義されないため、必要に応じて[複合インデックスを追加する](how-to-manage-indexing-policy.md#composite-indexing-policy-examples)必要があります。

含まれるパスまたは除外されるパスとは異なり、`/*` ワイルドカードを使用してパスを作成することはできません。 すべての複合パスには、指定する必要のないパスの末尾に暗黙的な `/?` があります。 複合パスはスカラー値になります。これは、複合インデックスに含まれる唯一の値です。

複合インデックスを定義する場合は、次のものを指定します。

- 2 つ以上のプロパティ パス。 プロパティ パスが定義されるシーケンスが重要です。

- 順序 (昇順または降順)。

> [!NOTE]
> 複合インデックスを追加したとき、新しい複合インデックスの追加が完了するまで、クエリは既存の範囲インデックスを利用します。 そのため、複合インデックスを追加しても、すぐにパフォーマンス向上が見られないことがあります。 [いずれかの SDK を使用して](how-to-manage-indexing-policy.md)、インデックス変換の進行状況を追跡できます。

### <a name="order-by-queries-on-multiple-properties"></a>複数のプロパティに対する ORDER BY クエリ:

2 つ以上のプロパティを使用する `ORDER BY` 句が含まれるクエリに複合インデックスを使用する場合は、次の考慮事項を確認します。

- 複合インデックスのパスが `ORDER BY` 句の中のプロパティのシーケンスに一致しない場合、その複合インデックスはクエリをサポートできません。

- 複合インデックスのパスの順序 (昇順または降順) は、`ORDER BY` 句の中の `order` とも一致する必要があります。

- 複合インデックスはまた、すべてのパスで反対の順序を持つ `ORDER BY` 句もサポートします。

複合インデックスがプロパティ name、age、および _ts に対して定義されている次の例を考えてみます。

| **複合インデックス**     | **サンプルの `ORDER BY` クエリ**      | **複合インデックスでサポートされているか** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

すべての必要な `ORDER BY` クエリに対応できるように、インデックス作成ポリシーをカスタマイズする必要があります。

### <a name="queries-with-filters-on-multiple-properties"></a>複数のプロパティに対するフィルターを含むクエリ

クエリに 2 つ以上のプロパティに対するフィルターが含まれている場合は、これらのプロパティの複合インデックスを作成すると便利な場合があります。

たとえば、2 つのプロパティに対する等値フィルターが含まれている次のクエリについて考えてみます。

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

このクエリは、(name ASC, age ASC) の複合インデックスを利用できる場合、時間が短縮され、RU の消費が少なくなり、より効率的に実行できます。

範囲フィルターが含まれるクエリを複合インデックスを使用して最適化することもできます。 ただし、クエリに含めることができる範囲フィルターは 1 つのみです。 範囲フィルターは、`>`、`<`、`<=`、`>=`、`!=` です。 範囲フィルターは、複合インデックス内で最後に定義する必要があります。

等値フィルターと範囲フィルターの両方が含まれる次のクエリについて考えてみます。

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

このクエリは、(name ASC, age ASC) の複合インデックスを使用すると、より効率的に実行できます。 ただし、等値フィルターは複合インデックス内で最初に定義する必要があるため、クエリでは (age ASC, name ASC) の複合インデックスが使用されません。

複数のプロパティに対するフィルターが含まれるクエリ用に複合インデックスを作成する場合は、次の考慮事項を確認します。

- クエリのフィルター内のプロパティは、複合インデックス内のプロパティと一致している必要があります。 複合インデックスにプロパティが含まれていても、クエリにフィルターとして含まれていない場合、このクエリでは複合インデックスは使用されません。
- 複合インデックスで定義されていない追加のプロパティがフィルターに含まれているクエリの場合は、複合インデックスと範囲インデックスの組み合わせを使用してクエリが評価されます。 この場合、範囲インデックスのみ使用する場合よりも、必要な RU が少なくなります。
- プロパティに範囲フィルター (`>`、`<`、`<=`、`>=`、または `!=`) が含まれている場合、このプロパティは複合インデックス内で最後に定義する必要があります。 クエリに複数の範囲フィルターが含まれている場合、複合インデックスは使用されません。
- 複数のフィルターが含まれるクエリを最適化するために複合インデックスを作成する場合、複合インデックスの `ORDER` は結果に影響しません。 このプロパティは省略可能です。
- 複数のプロパティに対するフィルターが含まれるクエリに対して複合インデックスを定義しなかった場合でも、クエリは成功します。 しかし、複合インデックスを使用すると、クエリの RU コストを削減できます。

複合インデックスがプロパティ name、age、および timestamp に対して定義されている次の例を考えてみます。

| **複合インデックス**     | **サンプル クエリ**      | **複合インデックスでサポートされているか** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>フィルターおよび ORDER BY 句が含まれるクエリ

クエリで 1 つ以上のプロパティがフィルター処理され、ORDER BY 句に異なるプロパティが含まれている場合は、フィルター内のプロパティを `ORDER BY` 句に追加すると便利な場合があります。

たとえば、フィルター内のプロパティを ORDER BY 句に追加すると、複合インデックスを利用するために次のクエリを書き直すことができます。

範囲インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

複合インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

複数の等値フィルターが含まれるクエリに対して、同じパターンおよびクエリの最適化を一般化できます。

範囲インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

複合インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

フィルターと `ORDER BY` 句が含まれるクエリを最適化するために複合インデックスを作成する場合は、次の考慮事項を確認します。

* クエリでプロパティをフィルター処理する場合は、最初に `ORDER BY` 句に含める必要があります。
* 1 つのプロパティに対するフィルターと、異なるプロパティを使用する別の `ORDER BY` 句が含まれるクエリに対して複合インデックスを定義しなかった場合でも、クエリは成功します。 しかし、複合インデックスを使用すると、特に `ORDER BY` 句内のプロパティのカーディナリティが高い場合、クエリの RU コストを削減できます。
* 複合インデックスを、複数のプロパティが含まれる `ORDER BY` クエリ、および複数のプロパティに対するフィルターが含まれるクエリに対して作成する際の考慮事項もすべて、適用されます。


| **複合インデックス**                      | **サンプルの `ORDER BY` クエリ**                                  | **複合インデックスでサポートされているか** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>インデックス作成ポリシーの変更

コンテナーのインデックス作成ポリシーは、[Azure portal またはサポートされている SDK のいずれかを使用して](how-to-manage-indexing-policy.md)いつでも更新できます。 インデックス作成ポリシーを更新すると、古いインデックスから新しいものへの変換がトリガーされ、オンラインでその場で実行されます (そのため、この操作中に記憶域が追加で消費されることはありません)。 古いポリシーのインデックスは新しいポリシーに効率的に変換され、コンテナー上での書き込み可用性、読み取り可用性、またはプロビジョニングされたスループットが影響を受けることはありません。 インデックス変換は非同期操作であり、完了までにかかる時間は、プロビジョニングされたスループット、項目の数、およびそれらのサイズによって決まります。

> [!IMPORTANT]
> インデックス変換は[要求ユニット](request-units.md)を消費する操作です。 [サーバーレス](serverless.md) コンテナーを使用している場合、現在のところ、インデックス変換によって消費される要求単位には課金されません。 これらの要求単位は、サーバーレスが一般提供されるようになったときに課金されます。

> [!NOTE]
> [いずれかの SDK を使用して](how-to-manage-indexing-policy.md)、インデックス変換の進行状況を追跡できます。

インデックス変換中に、書き込み可用性への影響はありません。 インデックス変換にはプロビジョニングされた RU が使用されますが、CRUD 操作やクエリよりも低い優先順位になります。

新しいインデックスを追加するときに、読み取り可用性への影響はありません。 クエリでは、インデックス変換が完了するまで、新しいインデックスを使用しません。 インデックス変換中、クエリ エンジンでは引き続き既存のインデックスを使用します。そのため、インデックスの変更を開始する前と、インデックスの変換中とで、観察される読み取りパフォーマンスは同じです。 新しいインデックスを追加する場合、クエリ結果が不完全または不整合になるリスクもありません。

インデックスを削除し、削除されたインデックスに基づいてフィルター処理を行うクエリをすぐに実行する場合、クエリ結果の整合性や完全性は保証されません。 1 回のインデックス作成ポリシーの変更で、複数のインデックスを削除する場合は、クエリ エンジンによって、インデックス変換全体で結果の整合性と完全性が保証されます。 ただし、複数回のインデックス作成ポリシーの変更を通じてインデックスを削除する場合、クエリ エンジンは、すべてのインデックス変換が完了するまで、結果の整合性または完全性を保証しません。 ほとんどの開発者は、インデックスの削除後、これらのインデックスを使用するクエリをすぐに実行しようとはしません。実際には、このような状況になることはほとんどありません。

> [!NOTE]
> 可能であれば、複数のインデックスの変更を 1 回のインデックス作成ポリシーの変更にグループ化しようとする必要があります

## <a name="indexing-policies-and-ttl"></a>インデックス作成ポリシーと TTL

[Time-to-Live (TTL) 機能](time-to-live.md)を使用するには、インデックス作成が必要です。 これは、次のことを意味します。

- インデックス作成モードが [なし] に設定されているコンテナーで TTL をアクティブにすることはできません。
- TTL がアクティブになっているコンテナーで、インデックス作成モードを [なし] に設定することはできません。

インデックス作成が必要なプロパティ パスはないが、TTL が必要なシナリオでは、次のようなインデックス作成ポリシーを使用できます。

- インデックス作成モードが [同期] に設定されている
- パスが含まれていない
- 唯一の除外パスとして `/*` が指定されている

## <a name="next-steps"></a>次のステップ

以下の記事で、インデックス作成についての詳細を参照してください。

- [インデックス作成の概要](index-overview.md)
- [インデックス作成ポリシーを管理する方法](how-to-manage-indexing-policy.md)
