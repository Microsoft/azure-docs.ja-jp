---
title: Azure Cosmos DB Gremlin API でのデータのパーティション分割
description: Azure Cosmos DB でパーティション分割されたグラフを使用する方法について説明します。 この記事では、パーティション分割されたグラフの要件とベスト プラクティスについても説明します。
author: luisbosquez
ms.author: lbosq
ms.service: cosmos-db
ms.subservice: cosmosdb-graph
ms.topic: conceptual
ms.date: 12/06/2018
ms.custom: seodec18
ms.openlocfilehash: f1e486a302b440d819e15ef86f8d76ea5e50d201
ms.sourcegitcommit: 8330a262abaddaafd4acb04016b68486fba5835b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/04/2019
ms.locfileid: "54036326"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Azure Cosmos DB でのパーティション分割されたグラフの使用

Azure Cosmos DB の Gremlin API の主な特長の 1 つとして、水平スケーリングによって大規模なグラフを処理する機能があります。 水平スケーリングは、[Azure Cosmos DB のパーティション分割機能](partition-data.md)を使用して実現します。 コンテナーは、ストレージとスループットに応じて個別にスケーリングできます。 グラフ データを格納するために自動的にスケーリングできるコンテナーを Azure Cosmos DB で作成できます。 データは、指定された**パーティション キー**に基づいて自動的に分散されます。

このドキュメントでは、グラフ データベースをパーティション分割する方法の詳細に加えて、頂点 (ノード) とエッジの両方に及ぼす影響についても説明します。

## <a name="requirements-for-partitioned-graph"></a>パーティション分割グラフの要件

パーティション分割されたグラフのコンテナーを作成する場合に理解しておく必要がある詳細事項を次に示します。

- コンテナーに格納されるサイズが 10 GB を超えることが予想される場合、または 1 秒間に 10,000 を超える数の要求ユニット (RU) を割り当てたい場合は、**パーティション分割が必要です**。

- **頂点とエッジの両方が、JSON ドキュメントとして格納されます**。

- **頂点にはパーティション キーが必須です**。 このキーによって、ハッシュ アルゴリズムを通して頂点が格納されるパーティションが決定されます。 このパーティション キーの名前は、スペースや特殊文字を含まない 1 語の文字列です。 パーティション キーは、新しいコンテナーを作成するときに定義され、形式は `/partitioning-key-name` です。

- **エッジはソースの頂点と共に格納されます**。 つまり、頂点ごとに、そのパーティション キーによって、頂点がその送信エッジと共に格納される場所が定義されます。 これは、グラフ クエリで `out()` カーディナリティを使用する際にクロス パーティション クエリを回避するために行われます。

- **グラフ クエリではパーティション キーを指定する必要があります**。 Azure Cosmos DB で行方向のパーティション分割を最大限に活用するには、単一の頂点を選択するときに、可能な限り、パーティション キーを指定します。 パーティション分割されたグラフにおいて 1 つまたは複数の頂点を選択するためのクエリを次に示します。

    - `/id` および `/label` は、Gremlin API でのコンテナーに対するパーティション キーとしてサポートされていません。


    - ID によって頂点を選択してから、**`.has()` ステップを使用してパーティション キー プロパティを指定する**: 
    
        ```
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - **パーティション キー値と ID が含まれている組を指定**して頂点を選択する: 
    
        ```
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - **パーティション キー値と ID の組の配列**を指定する:
    
        ```
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - 頂点セットを選択し、**パーティション キー値の一覧を指定する**: 
    
        ```
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>パーティション分割されたグラフを使用する場合のベスト プラクティス

無制限のコンテナーでパーティション分割されたグラフを使用するときは、次のガイドラインを使用してパフォーマンスとスケーラビリティを確保します。

- **頂点に対してクエリを実行するときは常にパーティション キー値を指定します**。 パフォーマンスを実現するには、既知のパーティションから頂点を取得します。

- **エッジに対してクエリを実行する場合は、可能な限り、送信方向を使用します**。 前述のように、エッジは、送信方向のそのソース頂点と一緒に格納されます。 したがって、このパターンを念頭においてデータとクエリを設計すると、クロス パーティション クエリを使用する可能性が最小限に抑えられます。

- **パーティション間でデータを均等に分散するパーティション キーを選択します**。 この決定は、ソリューションのデータ モデルに大きく依存します。 適切なパーティション キーの作成の詳細については、「[Azure Cosmos DB でのパーティション分割とスケーリング](partition-data.md)」を参照してください。

- **パーティションの境界内でデータを取得するようにクエリを最適化します**。 最適なパーティション分割方法を決める場合は、クエリ パターンに合わせます。 1 つのパーティションからデータを取得するクエリでは、最大限のパフォーマンスを実現できます。

## <a name="next-steps"></a>次の手順

次に、以下の記事をお読みください。

* [Azure Cosmos DB でのパーティション分割とスケーリング](partition-data.md)について説明します。
* [Gremlin API での Gremlin のサポート](gremlin-support.md)について説明します。
* [Gremlin API の概要](graph-introduction.md)について説明します。
