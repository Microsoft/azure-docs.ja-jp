---
title: "DMZ の例 - ファイアウォール、UDR、NSG から成る DMZ を構築してネットワークを保護する | Microsoft Docs"
description: "ファイアウォール、ユーザー定義ルーティング (UDR)、ネットワーク セキュリティ グループ (NSG) から成る DMZ を構築する"
services: virtual-network
documentationcenter: na
author: tracsman
manager: rossort
editor: 
ms.assetid: dc01ccfb-27b0-4887-8f0b-2792f770ffff
ms.service: virtual-network
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/01/2016
ms.author: jonor;sivae
ms.translationtype: HT
ms.sourcegitcommit: bde1bc7e140f9eb7bb864c1c0a1387b9da5d4d22
ms.openlocfilehash: fdb3c5cbd3acee90386352c6f180a71aa81f54fe
ms.contentlocale: ja-jp
ms.lasthandoff: 07/21/2017

---
# <a name="example-3--build-a-dmz-to-protect-networks-with-a-firewall-udr-and-nsg"></a>例 3 - ファイアウォール、UDR、NSG から成る DMZ を構築してネットワークを保護する
[セキュリティ境界のベスト プラクティス ページに戻る][HOME]

この例では、ファイアウォールと 4 台の Windows Server、ユーザー定義ルーティング、ネットワーク セキュリティ グループから成る DMZ を作成します。 また、各手順をより深く理解できるように、関連するコマンドを順に説明します。 さらに、「トラフィックに関するシナリオ」セクションでは、DMZ の防御層におけるトラフィックの進行過程を詳しく説明しています。 最後の「参照」セクションでは、さまざまなシナリオでテストおよび実験ができるように、この環境を構築するための完全なコードと手順を紹介します。 

![双方向 DMZ + NVA、NSG、および UDR][1]

## <a name="environment-setup"></a>環境のセットアップ
この例で使用するサブスクリプションには、以下のものが含まれています。

* 3 つのクラウド サービス: “SecSvc001”、“FrontEnd001”、“BackEnd001”
* 3 つのサブネット ("SecNet"、"FrontEnd"、"BackEnd") を含む仮想ネットワーク "CorpNetwork"
* SecNet サブネットに接続されたネットワーク仮想アプライアンス (この例ではファイアウォール)
* アプリケーション Web サーバーを表す Windows サーバー ("IIS01")
* アプリケーション バックエンド サーバーを表す 2 つの Windows サーバー ("AppVM01"、"AppVM02")
* DNS サーバーを表す Windows サーバー ("DNS01")

以上に示した環境の大部分は、このページの「参照」セクションで紹介している PowerShell スクリプトで構築します。 VM と Virtual Network の構築については、スクリプト例には含まれていますが、このドキュメントでは詳細な説明を省略します。

環境を構築するには

1. 「参照」セクションに示しているネットワーク構成用 xml ファイルを保存します (特定のシナリオに一致するように、名前、ロケーション情報、IP アドレスを更新します)。
2. スクリプトを実行する環境に合わせてスクリプト内のユーザー変数を更新します (サブスクリプション、サービス名など)。
3. PowerShell でスクリプトを実行します。

**注**: PowerShell スクリプトで示されたリージョンは、ネットワーク構成用 xml ファイルで示されたリージョンと一致する必要があります。

スクリプトが正常に実行された後、必要に応じて次の手順を別途実行します。

1. ファイアウォール ルールを設定します。この点については、ファイアウォール ルールの説明で取り上げます。
2. この DMZ 構成を使ったテストを実行するために、必要に応じて「参照」セクションにある 2 つのスクリプトを実行します。簡単な Web アプリケーションを含む Web サーバーとアプリケーション サーバーがこれらのスクリプトによってセットアップされます。

スクリプトが正常に実行されたら、ファイアウォール ルールを完成させる必要があります。この点については、「ファイアウォール ルール」セクションで取り上げます。

## <a name="user-defined-routing-udr"></a>ユーザー定義ルーティング (UDR)
既定では、次のシステム ルートが定義されています。

        Effective routes : 
         Address Prefix    Next hop type    Next hop IP address Status   Source     
         --------------    -------------    ------------------- ------   ------     
         {10.0.0.0/16}     VNETLocal                            Active   Default    
         {0.0.0.0/0}       Internet                             Active   Default    
         {10.0.0.0/8}      Null                                 Active   Default    
         {100.64.0.0/10}   Null                                 Active   Default    
         {172.16.0.0/12}   Null                                 Active   Default    
         {192.168.0.0/16}  Null                                 Active   Default

VNETLocal は、特定のネットワークの VNet に対して必ず定義されるアドレス プレフィックスです (つまり、具体的な VNet がそれぞれどのように定義されているかによって変わります)。 その他のシステム ルートは静的ルートで、上記のように既定値となっています。

優先度に関しては、最長プレフィックス一致 (LPM) 方式でルートが処理されます。つまり、テーブルの中で最も具体的に該当するルートが、特定の宛先アドレスに適用されます。

そのため、ローカル ネットワーク (10.0.0.0/16) を対象とした (たとえば DNS01 サーバー 10.0.2.4 宛ての) トラフィックであれば、10.0.0.0/16 ルートにより、VNet を介してその宛先にルーティングされます。 言い換えると、10.0.2.4 にとって、10.0.0.0/16 ルートが最も具体的なルートであるということです。10.0.0.0/8 や 0.0.0.0/0 も該当しますが、これらは相対的に具体性が低く、このトラフィックには作用しません。 したがって、10.0.2.4 宛てのトラフィックであれば、次ホップにはローカル VNet が適用され、単純にその宛先にルーティングされます。

ここでトラフィックの宛先が 10.1.1.1 である場合、10.0.0.0/16 ルートは選択されず、10.0.0.0/8 が最も具体的なルートとなりますが、次ホップが Null であるために、トラフィックは破棄 ("ブラック ホール") されます。 

宛先がいずれの Null プレフィックスにも該当せず、VNETLocal プレフィックスにも該当しなかった場合は、具体性の最も低いルート (0.0.0.0/0) が選択され、ルーティング先の次ホップはインターネットとなります。つまり、Azure のインターネット エッジの外に送出されます。

まったく同じ 2 つのプレフィックスがルート テーブルに存在した場合、それらのルートの "source" 属性に基づく次の序列が適用されます。

1. "VirtualAppliance" = テーブルに手動で追加されたユーザー定義ルート
2. "VPNGateway" = 動的ネットワーク プロトコルによって追加された動的ルート (ハイブリッド ネットワークで使用しているときは BGP)。動的プロトコルでは、ピア ネットワークの変化が自動的に反映されるため、これらのルートは時間の経過に伴って変わる場合があります。
3. "Default" = 上のルート テーブルに示されているシステム ルート、ローカル VNet、静的エントリ。

> [!NOTE]
> これで、ExpressRoute と VPN Gateway でユーザー定義ルーティング (UDR) を使用して、送信および受信クロスプレミス トラフィックをネットワーク仮想アプライアンス (NVA) に強制的にルーティングできるようになりました。
> 
> 

#### <a name="creating-the-local-routes"></a>ローカル ルートの作成
この例では、フロントエンドとバックエンドのサブネットに対して 1 つずつ、合わせて 2 つのルーティング テーブルが必要となります。 各サブネットに適した静的ルートをそれぞれのテーブルに読み込みます。 この例では、各テーブルに 3 つのルートが存在します。

1. ローカル サブネット トラフィック。次ホップは定義されず、ローカル サブネット トラフィックはファイアウォールをバイパスすることができます。
2. Virtual Network トラフィック。次ホップはファイアウォールとして定義され、ローカル VNet トラフィックの直接ルーティングを許可する既定のルールは上書きされます。
3. その他すべてのトラフィック (0/0)。次ホップはファイアウォールとして定義されます。

ルーティング テーブルは作成されると、対応するサブネットにバインドされます。 フロントエンド サブネットの場合、作成後、サブネットにバインドされたルーティング テーブルは、次のようになります。

        Effective routes : 
         Address Prefix    Next hop type    Next hop IP address Status   Source     
         --------------    -------------    ------------------- ------   ------     
         {10.0.1.0/24}     VNETLocal                            Active 
         {10.0.0.0/16}     VirtualAppliance 10.0.0.4            Active    
         {0.0.0.0/0}       VirtualAppliance 10.0.0.4            Active


この例では、ルート テーブルの作成、ユーザー定義ルートの追加、サブネットへのルート テーブルのバインドを各コマンドを使用して行っています (注: ドル記号で始まる項目 (例: $BESubnet) はユーザー定義変数です。このドキュメントの「参照」セクションのスクリプトで宣言されています)。

1. まず、ベース ルーティング テーブルを作成する必要があります。 このスニペットは、バックエンド サブネット用のテーブルを作成するものです。 対応するフロントエンド サブネット用のテーブルもスクリプトで作成します。
   
     New-AzureRouteTable -Name $BERouteTableName `
   
         -Location $DeploymentLocation `
         -Label "Route table for $BESubnet subnet"
2. ルート テーブルの作成後、具体的なユーザー定義ルートを追加できます。 このスニペットでは、すべてのトラフィック (0.0.0.0/0) が仮想アプライアンスを通じてルーティングされます (スクリプトの前半で仮想アプライアンスの作成時に割り当てた IP アドレスを変数 $VMIP[0] で渡しています)。 フロントエンド テーブルにも対応するルールをスクリプトで作成します。
   
     Get-AzureRouteTable $BERouteTableName | `
   
         Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
         -NextHopType VirtualAppliance `
         -NextHopIpAddress $VMIP[0]
3. 既定の "0.0.0.0/0" ルートは先ほどのルート エントリによって上書きされますが、既定の 10.0.0.0/16 ルールは依然として存在します。このルールによって、VNet 内のトラフィックがネットワーク仮想アプライアンスにではなく直接宛先にルーティングされる可能性があります。 この動作を修正するために、次のルールを追加する必要があります。
   
        Get-AzureRouteTable $BERouteTableName | `
            Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
4. ここで検討事項が生じます。 上の 2 つのルートでは、同じサブネット内のトラフィックも含め、すべてのトラフィックがファイアウォールにルーティングされて評価されます。 場合によってはそれでも問題ありませんが、トラフィックの発信元と宛先とが同じサブネットであるときに、ファイアウォールを介さずローカルでルーティングする場合には、最も具体性のある第 3 のルールを追加します。 このルート指定 (NextHopType = VNETLocal) によって、ローカル サブネット宛てのアドレスはすべてそのサブネット内で直接ルーティングすることができます。
   
        Get-AzureRouteTable $BERouteTableName | `
            Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $BEPrefix `
            -NextHopType VNETLocal
5. ルーティング テーブルを作成し、ユーザー定義ルートを設定したら、最後にそのテーブルをサブネットにバインドする必要があります。 フロント エンド用のルート テーブルも、このスクリプトでフロントエンド サブネットにバインドします。 以下に示したのは、バックエンド サブネット用のバインディング スクリプトです。
   
     Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
   
        -SubnetName $BESubnet `
        -RouteTableName $BERouteTableName

## <a name="ip-forwarding"></a>IP 転送
UDR と併用される機能に IP 転送があります。 実際には自分自身宛てではないトラフィックを受信し、最終的な宛先に転送することができる仮想アプライアンス上の設定です。

たとえば、AppVM01 からのトラフィックが DNS01 サーバーに要求を行う場合、UDR ではこの要求をファイアウォールにルーティングします。 IP 転送が有効になっている場合、DNS01 (10.0.2.4) 宛てのトラフィックはまずアプライアンス (10.0.0.4) で受信されて、最終的な宛先 (10.0.2.4) に転送されます。 ファイアウォールで IP 転送が無効になっている場合、ルート テーブルに次ホップとしてファイアウォールが指定されていても、アプライアンスは、そのトラフィックを受け付けません。 

> [!IMPORTANT]
> 忘れずにユーザー定義ルーティングと併せて IP 転送を有効にすることが重要です。
> 
> 

IP 転送の設定は、VM の作成時に単一のコマンドで実行できます。 このコード スニペットは、スクリプトの最後の方に、一連の UDR コマンドと一緒に記述されます。

1. 仮想アプライアンスである VM インスタンス (このケースではファイアウォール) を呼び出し、IP 転送を有効にします (注: ドル記号で始まる赤色の項目 (例: $VMName[0]) はユーザー定義変数です。このドキュメントの「参照」セクションのスクリプトで宣言されています。 角かっこで囲まれたゼロ ([0]) は、VM の配列の先頭に格納されている VM を表します。このサンプル スクリプトが修正なしで正常に機能するためには、1 番目の VM (VM 0) がファイアウォールである必要があります)。
   
     Get-AzureVM -Name $VMName[0] -ServiceName $ServiceName[0] | `
   
        Set-AzureIPForwarding -Enable

## <a name="network-security-groups-nsg"></a>ネットワーク セキュリティ グループ (NSG)
この例では、NSG グループを作成し、そこに単一のルールを設定します。 このグループは、(SecNet を除いた) フロントエンドとバックエンドのサブネットにのみバインドします。 ここで作成しているルールの内容は次のとおりです。

1. インターネットから VNet 全体 (すべてのサブネット) への任意のトラフィック (すべてのポート) を拒否する。

この例では NSG が使用されていますが、NSG の主な役割は、手動構成のミスに対する第 2 の防御層としての機能です。 ここでは、フロントエンド サブネットまたはバックエンド サブネットへのインターネットからの受信トラフィックをすべてブロックし、必ず SecNet サブネットを介してファイアウォールに (その後必要に応じてフロントエンド サブネットまたはバックエンド サブネットに) トラフィックを流すことを目指しています。 加えて UDR ルールが設定されているので、万一フロントエンド サブネットまたはバックエンド サブネットにうまく到達できたトラフィックも (UDR が設定されているために) すべてファイアウォールへと送信させることができます。 ファイアウォールは、そのようなトラフィックを非対称フローと見なし、その送信トラフィックは破棄されます。 つまり、フロントエンド サブネットとバックエンド サブネットを保護するセキュリティは、1) FrontEnd001 と BackEnd001 のクラウド サービスのエンドポイントをすべて閉じる、2) インターネットからのトラフィックを NSG で拒否する、3) 非対称トラフィックをファイアウォールで破棄する、という 3 層構造になっています。

この例のネットワーク セキュリティ グループに存在するルールは 1 つだけである点に注目してください。セキュリティ サブネットを含め、仮想ネットワーク全体でインターネット トラフィックを拒否する、というルールが 1 つあるだけです (以下のコマンドを参照)。 

    Get-AzureNetworkSecurityGroup -Name $NSGName | `
        Set-AzureNetworkSecurityRule -Name "Isolate the $VNetName VNet `
        from the Internet" `
        -Type Inbound -Priority 100 -Action Deny `
        -SourceAddressPrefix INTERNET -SourcePortRange '*' `
        -DestinationAddressPrefix VIRTUAL_NETWORK `
        -DestinationPortRange '*' `
        -Protocol *

しかし、この NSG がバインドされるのはフロントエンド サブネットとバックエンド サブネットだけです。セキュリティ サブネットに入ってくるトラフィックに対してはルールの処理は適用されません。 その結果、VNet 上の全アドレスに対するインターネット トラフィックが NSG ルールで拒否されていても、その NSG をセキュリティ サブネットにバインドしなければ、トラフィックはセキュリティ サブネットに到達します。

    Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName `
        -SubnetName $FESubnet -VirtualNetworkName $VNetName

    Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName `
        -SubnetName $BESubnet -VirtualNetworkName $VNetName

## <a name="firewall-rules"></a>ファイアウォール ルール
ファイアウォールには、転送ルールを作成する必要があります。 受信トラフィック、送信トラフィック、VNet 間トラフィックをすべてブロックまたは転送する役割を果たすファイアウォールには、多くのファイアウォール ルールが必要です。 また、すべての受信トラフィックは、セキュリティ サービスのパブリック IP アドレス (の各種ポート) に到達し、そこでファイアウォールの処理が適用されます。 手戻り作業をなくすために、あらかじめ論理フローを図式化したうえでサブネットとファイアウォール ルールを設定するようお勧めします。 次の図では、この例で使用するファイアウォール ルールを論理的に示しています。

![ファイアウォール ルールの論理ビュー][2]

> [!NOTE]
> 使用するネットワーク仮想アプライアンスによって管理ポートは異なります。 ここでは、ポート 22、801、807 が使用されている Barracuda NextGen Firewall を例に説明しています。 ご使用のデバイスの管理に使用される実際のポートについては、アプライアンス製造元のマニュアルを参照してください。
> 
> 

### <a name="logical-rule-description"></a>論理規則の説明
セキュリティ サブネットは、ファイアウォールが唯一のリソースであるため、上の論理図では省略しています。この図にはファイアウォール ルールが示されており、実際の経路を指定するのではなく論理的にトラフィック フローを許可または拒否していることがわかります。 また、RDP トラフィック用に選択した外部ポートは、他のトラフィックよりも大きな番号範囲 (8014 ～ 8026) を使用しています。また、見やすくするために、外部ポート番号は、ローカル IP アドレスの最後の 2 オクテットとある程度揃える形で選択しました (たとえば、ローカル サーバー アドレス 10.0.1.4 は外部ポート 8014 に関連付けられています)。ただし、競合さえしなければ、もっと大きなポート番号を使用してもかまいません。

この例では、7 種類のルールが必要です。そのルールについて種類ごとに説明します。

* 外部ルール (受信トラフィック用):
  1. ファイアウォール管理ルール: ネットワーク仮想アプライアンスの管理ポート宛てのトラフィックを通過させるための App Redirect ルールです。
  2. RDP ルール (Windows Server ごと): 個々のサーバーを RDP 経由で管理するためには、この 4 つのルール (サーバー 1 台につき 1 つ) が必要となります。 使用するネットワーク仮想アプライアンスの機能によっては、これを 1 つのルールにまとめることもできます。
  3. アプリケーション トラフィック ルール: フロントエンド Web トラフィック用とバックエンド トラフィック用 (Web サーバーからデータ層など) の 2 つのアプリケーション トラフィック ルールがあります。 これらのルールの構成は、(サーバーが置かれている) ネットワーク アーキテクチャとトラフィック フロー (トラフィック フローの方向と使用ポート) によって異なります。
     * 実際のアプリケーション トラフィックは、1 つ目のルールによってアプリケーション サーバーに到達できます。 ファイアウォール管理ルールと RDP ルールがセキュリティや管理を目的としているのに対し、アプリケーション ルールの目的は、外部のユーザーまたはサービスがアプリケーションにアクセスできるようにすることです。 この例では、Web サーバー (ポート 80) が 1 台であるため、単一のファイアウォール アプリケーション ルールで、外部 IP 宛ての受信トラフィックを Web サーバーの内部 IP アドレスにリダイレクトすることになります。 リダイレクトされたトラフィック セッションは、NAT によって内部サーバーに渡されます。
     * 2 つ目のアプリケーション トラフィック ルールはバック エンド ルールです。任意のポートを介した Web サーバーから AppVM01 サーバー (ただし、AppVM02 は不可) への通信を許可します。
* 内部ルール (VNet 間トラフィック用)
  1. インターネットへの送信ルール: 任意のネットワークから特定のネットワークへのトラフィックの通過を許可するルールです。 通常、ファイアウォールにはこのルールが、既定のルールとして (ただし無効状態で) あらかじめ設定されています。 この例では、このルールを有効にする必要があります。
  2. DNS ルール: DNS (ポート 53) のトラフィックのみに DNS サーバーへの通過を許可するルールです。 この環境では、フロントエンドからバックエンドへのトラフィックの大部分がブロックされるため、このルールによって、任意のローカル サブネットからの DNS を明示的に許可しています。
  3. サブネット間ルール: バックエンド サブネット上の任意のサーバーからフロントエンド サブネット上の任意のサーバーへの接続を許可するルールです (ただしその逆は不可)。
* フェールセーフ ルール (上記のルールに該当しないトラフィック用):
  1. 全トラフィック拒否ルール: このルールは (優先度の観点から) 必ず最後に置く必要があります。先行するいずれのルールにも該当しなかったトラフィック フローが、このルールによって破棄されます。 これは既定のルールであり通常は有効になっているため、一般に変更は不要です。

> [!TIP]
> この例では、わかりやすくするために 2 つ目のアプリケーション トラフィック ルールで任意のポートを許可していますが、実際のシナリオでは、ポートとアドレス範囲をできるだけ具体的に指定して、このルールに対する攻撃対象領域を小さくする必要があります。
> 
> 

<br />

> [!IMPORTANT]
> 以上のルールをすべて作成したら、各ルールの優先度を再確認し、トラフィックの許可または拒否が意図したとおりになっていることを確かめてください。 この例では、各ルールに優先順位が割り当てられています。 ルールの優先順位に間違いがあって、ファイアウォールが適用されないケースが多く見られます。 少なくともファイアウォールそのものを管理するためのルールには、無条件で最も高い優先度を設定してください。
> 
> 

### <a name="rule-prerequisites"></a>ルールの前提条件
ファイアウォールを実行する仮想マシンには、必ずパブリック エンドポイントが必要になります。 ファイアウォールでトラフィックを処理するためには、適切なパブリック エンドポイントを開放する必要があります。 この例で想定されるトラフィックは、1) ファイアウォールとそのルールを制御する管理トラフィック、2) Windows Server を管理するための RDP トラフィック、3) アプリケーション トラフィックの 3 種類です。 先ほどファイアウォール ルールの論理図を示しました。その上半分に記載されている 3 列のトラフィック タイプがそれらに対応します。

> [!IMPORTANT]
> ここでの重要なポイントは、**すべて**のトラフィックはファイアウォールを経由する、ということです。 たとえば、リモート デスクトップで IIS01 サーバーにアクセスするとします。IIS01 サーバーは、実際にはフロント エンド クラウド サービスのフロント エンド サブネット上にありますが、このサーバーにアクセスするためには、RDP でファイアウォールのポート 8014 にアクセスし、ファイアウォールで RDP 要求を内部的に IIS01 RDP ポートにルーティングしてもらう必要があります。 RDP で直接 IIS01 に到達する経路は (ポータルから見える範囲では) 存在しないので、Azure ポータルの [接続] ボタンは機能しません。 つまり、インターネットからのすべての接続は secscv001.cloudapp.net:xxxx (セキュリティ サービスとポート) にリダイレクトされます (外部ポートと内部 IP/ポートの対応関係については上の図を参照)。
> 
> 

エンドポイントの開放は、VM の作成時に行うか、または以下のサンプル スクリプトおよび次のコード スニペットで行っているように構築後に行うこともできます (注: ドル記号で始まる項目 (例: $VMName[$i]) はユーザー定義変数です。このドキュメントの「参照」セクションのスクリプトで宣言されています。 角かっこで囲まれた "$i" ([$i]) は、VM の配列における特定の VM の配列番号を表します)。

    Add-AzureEndpoint -Name "HTTP" -Protocol tcp -PublicPort 80 -LocalPort 80 `
        -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | `
        Update-AzureVM

ここでは変数を使っているためにわかりにくいですが、エンドポイントを開放しているのは、セキュリティ クラウド サービス **のみ** です。 こうすることによって、すべての受信トラフィックが確実にファイアウォールで処理 (ルーティング、NAT 変換、破棄) されます。

ファイアウォールを管理したり、必要な構成を作成したりするには、管理クライアントを PC にインストールする必要があります。 デバイスの管理方法については、ご利用のファイアウォール (または他の NVA) ベンダーのドキュメントを参照してください。 このセクションの残りの部分および次のセクション (「ファイアウォール ルールの作成」) では、ファイアウォールそのものの構成について説明しています。ファイアウォールの構成は、(Azure ポータルや PowerShell ではなく) ベンダーの管理クライアントを使って行います。

この例で使用するクライアントをダウンロードして Barracuda に接続する手順については、 [Barracuda NG Admin](https://techlib.barracuda.com/NG61/NGAdmin)

ファイアウォールへのログオン後、ファイアウォール ルールを作成する前に、Network と Service という 2 つのオブジェクト クラスがあらかじめ必要となります。これらのオブジェクトを使用した方が簡単にルールを作成できます。

この例では、3 つの名前付きネットワーク オブジェクトを定義する必要があります (フロントエンド サブネット用とバックエンド サブネット用に加え、DNS サーバーの IP アドレス用のネットワーク オブジェクト)。 名前付きネットワークを作成するには、Barracuda NG Admin クライアント ダッシュボードの [configuration] タブに移動し、[Operational Configuration] セクションの [Ruleset] をクリックします。続けて、[Firewall Objects] メニューの [Networks] をクリックし、[Edit Networks] メニューの [New] をクリックしてください。 名前とプレフィックスを追加してネットワーク オブジェクトを作成できます。

![フロントエンド ネットワーク オブジェクトの作成][3]

これでフロントエンド サブネット用の名前付きネットワークが作成されます。バックエンド サブネットにも同様のオブジェクトを作成する必要があります。 これでサブネットが参照しやすくなりました。ファイアウォール ルール内から名前で参照することができます。

DNS サーバー オブジェクトの場合:

![DNS サーバー オブジェクトの作成][4]

後で DNS ルールについて取り上げますが、その際にこの単一の IP アドレス参照を利用することになります。

2 つ目に必要なオブジェクトはサービス オブジェクトです。 これらのオブジェクトで各サーバーの RDP 接続ポートを表します。 既にある RDP サービス オブジェクトは既定の RDP ポート (3389) にバインドされているため、外部ポート (8014 ～ 8026) からのトラフィックを許可する新しいサービス オブジェクトを作成します。 既存の RDP サービスに新しいポートを追加することもできますが、やかりやすくするため、サーバーごとに個別のルールを作成しましょう。 サーバーに使用する RDP ルールを新規作成するには、Barracuda NG Admin クライアント ダッシュボードの [configuration] タブに移動し、[Operational Configuration] セクションの [Ruleset] をクリックします。続けて、[Firewall Objects] メニューの [Services] をクリックし、サービスの一覧を下へスクロールして、"RDP" サービスを選択してください。 右クリックして [Copy] を選択し、右クリックして [Paste] を選択します。 これで、RDP-Copy1 というサービス オブジェクトが作成されました。作成したオブジェクトは編集することができます。 [RDP-Copy1] を右クリックして [Edit] を選択してください。以下に示した [Edit Service Object] ウィンドウがポップアップ表示されます。

![既定の RDP ルールのコピー][5]

実際のサーバーの RDP サービスに合わせて値を編集してください。 AppVM01 の場合、上に示した既定の RDP ルールに変更を加え、図 8 で使用されている新しいサービス名、説明、外部 RDP ポートを反映する必要があります (注: ポートは RDP の既定値である 3389 から、この実際のサーバーに使用されている外部ポートに変更します。AppVM01 の場合、外部ポートは 8025 となります)。変更後のサービスは次のとおりです。

![AppVM01 Rule][6]

残りのサーバー (AppVM02、DNS01、IIS01) にも同じ手順を繰り返して、RDP サービスを作成してください。 これらのサービスを作成することによって、次のセクションで行うルールの作成が簡単になり、理解しやすくなります。

> [!NOTE]
> ファイアウォールに対する RDP サービスは必要ありません。これには 2 つの理由があります。まず、ファイアウォールの VM は Linux ベースのイメージであるため、VM の管理には RDP ではなくポート 22 の SSH が使用されます。また、ポート 22 と他の 2 つの管理ポートは、管理接続用に、以下に説明する 1 つ目の管理ルールで許可されるためです。
> 
> 

### <a name="firewall-rules-creation"></a>ファイアウォール ルールの作成
この例には 3 種類のファイアウォール ルールが使われており、それぞれ以下のアイコンで明確に区別されています。

アプリケーション リダイレクト ルール: ![アプリケーション リダイレクト アイコン][7]

送信先 NAT ルール: ![送信先 NAT アイコン][8]

パス ルール: ![パス アイコン][9]

これらのルールの詳細については、Barracuda の Web サイトを参照してください。

以下の各ルールを作成するには (または既にある既定のルールを確認するには)、Barracuda NG Admin クライアント ダッシュボードの [configuration] タブに移動し、[Operational Configuration] セクションの [Ruleset] をクリックします。 ファイアウォールに対して既にアクティブになっているルールと非アクティブのルールとが "Main Rules" というグリッドに表示されます。 このグリッドの右上隅に小さな緑色の "+" ボタンがあります。新しいルールはこのボタンをクリックして作成します (注: ファイアウォールが変更できないように "ロック" されている場合があります。ボタンに "Lock" と表示されていてルールを作成したり編集したりできない場合は、このボタンをクリックしてルールセットの "ロックを解除" し、編集できる状態にしてください)。 既存のルールを編集するには、そのルールを選択して右クリックし、[Edit Rule] を選択します。

作成または編集したルールは、ファイアウォールにプッシュしたうえでアクティブにする必要があります。その作業を行わないと、ルールの変更が反映されません。 プッシュとアクティブ化のプロセスについては、以下、ルールの説明の中で詳しく説明します。

この例を完成させるために必要な各ルールの仕様は以下のとおりです。

* **ファイアウォール管理ルール**: ネットワーク仮想アプライアンス (この例では Barracuda NextGen Firewall) の管理ポート宛てのトラフィックを通過させるための App Redirect ルールです。 管理ポートは 801 と 807、および (必要に応じて) 22 です。 外部ポートと内部ポートは同じです (ポートの変換は使用しません)。 この SETUP-MGMT-ACCESS は既定のルールであり、初期設定で有効になっています (Barracuda NextGen Firewall Version 6.1)。
  
    ![ファイアウォール管理ルール][10]

> [!TIP]
> このルールの発信元 (Source) アドレス空間は Any です。管理 IP アドレス範囲が不明である場合には、このスコープを狭めることで管理ポートへの攻撃対象領域を小さくすることもできます。
> 
> 

* **RDP ルール**: RDP 経由で個々のサーバーを管理するために必要な Destination NAT ルールです。
  このルールを作成するうえで重要となるフィールドは 4 つです。
  
  1. [Source] - 任意の発信元からの RDP を許可するには、[Source] フィールドに "Any" を指定します。
  2. [Service] - 先ほど作成した適切なサービス オブジェクト (このケースでは "AppVM01 RDP")、外部ポートからサーバーのローカル IP アドレスおよびポート 3386 (既定の RDP ポート) へのリダイレクトを指定します。 ここに示したルールは、AppVM01 への RDP アクセス用です。
  3. [Destination] - *ファイアウォールのローカル ポート*、"DCHP 1 Local IP"、eth0 (静的 IP を使用する場合) のいずれかを指定します。 ご使用のネットワーク アプライアンスが複数のローカル インターフェイスを備えている場合、序数 (eth0、eth1 など) は異なる場合があります。 これは、ファイアウォールからの送信ポートになります (受信ポートと同じ場合もあります)。実際のルーティング先は [Target List] フィールドで指定します。
  4. [Redirection] - このトラフィックの最終的なリダイレクト先を仮想アプライアンスに伝えるセクションです。 リダイレクトとしては、[Target List] フィールドに IP とポート (省略可) を設定するのが最も単純です。 ポートを指定しなかった場合、受信要求の宛先ポートが使用されます (つまりポート変換は不使用)。ポートを指定した場合、IP アドレスと共にポートも NAT 変換されます。
     
     ![ファイアウォール RDP ルール][11]
     
     作成する必要のある RDP ルールは合わせて 4 つです。 
     
     | 規則の名前 | サーバー | サービス | ターゲット リスト |
     | --- | --- | --- | --- |
     | RDP-to-IIS01 |IIS01 |IIS01 RDP |10.0.1.4:3389 |
     | RDP-to-DNS01 |DNS01 |DNS01 RDP |10.0.2.4:3389 |
     | RDP-to-AppVM01 |AppVM01 |AppVM01 RDP |10.0.2.5:3389 |
     | RDP-to-AppVM02 |AppVM02 |AppVm02 RDP |10.0.2.6:3389 |

> [!TIP]
> [Source] フィールドと [Service] フィールドのスコープを狭くすると、攻撃対象領域が小さくなります。 正常な機能を維持できる範囲で最も限定的なスコープを使用してください。
> 
> 

* **アプリケーション トラフィック ルール**: フロント エンド Web トラフィック用とバックエンド トラフィック用 (Web サーバーからデータ層など) の 2 つのアプリケーション トラフィック ルールがあります。 これらのルールは、(サーバーが置かれている) ネットワーク アーキテクチャとトラフィック フロー (トラフィック フローの方向と使用ポート) によって異なります。
  
    まず、Web トラフィック用のフロント エンド ルールから説明します。
  
    ![ファイアウォール Web ルール][12]
  
    実際のアプリケーション トラフィックは、この Destination NAT ルールによってアプリケーション サーバーに到達できます。 ファイアウォール管理ルールと RDP ルールがセキュリティや管理を目的としているのに対し、アプリケーション ルールの目的は、外部のユーザーまたはサービスがアプリケーションにアクセスできるようにすることです。 この例では、Web サーバー (ポート 80) が 1 台であるため、単一のファイアウォール アプリケーション ルールで、外部 IP 宛ての受信トラフィックを Web サーバーの内部 IP アドレスにリダイレクトすることになります。
  
    **注**: [Target List] フィールドにポート指定がないことに注意してください。そのため、受信ポートである 80 (一部のサービスでは 443) が Web サーバーのリダイレクトに使用されます。 それ以外の待機ポートが Web サーバーに使用されている場合 (たとえばポート 8080 など)、[Target List] フィールドに「10.0.1.4:8080」と指定することで、ポートのリダイレクトも行うことができます。
  
    次のアプリケーション トラフィック ルールは、バックエンド ルールです。Web サーバーから AppVM01 サーバー (ただし AppVM02 は不可) への、任意のサービスを介した通信を許可します。
  
    ![ファイアウォール AppVM01 ルール][13]
  
    この Pass ルールによって、フロントエンド サブネット上の IIS サーバーが任意のプロトコルで AppVM01 (IP アドレス: 10.0.2.5) の任意のポートに到達し、Web アプリケーションに必要なデータにアクセスすることができます。
  
    このスクリーン ショットでは、[Destination] フィールドに "\<explicit-dest\>" が使用され、宛先として 10.0.2.5 が指定されています。 ここは、この例のように明示的に指定してもかまいませんが、(DNS サーバーの前提条件で作成した) 名前付きネットワーク オブジェクトを指定することもできます。 どちらの方法を使用するかは、ファイアウォールの管理者が決めます。 10.0.2.5 を明示的な宛先として追加するには、\<explicit-dest\> の下にある 1 つ目の空白行をダブルクリックし、表示されたウィンドウにアドレスを入力します。
  
    内部トラフィックが対象となるため、この Pass ルールに NAT は不要です。[Connection Method] は "No SNAT" に設定してください。
  
    **注**: このルールにおける発信元ネットワークは、FrontEnd サブネット上の任意のリソースです。リソースが 1 つしか存在しない場合や、特定の数の Web サーバーが把握できている場合は、フロントエンド サブネット全体を指定するのではなく、ネットワーク オブジェクト リソースを作成して、具体的に IP アドレスを指定することもできます。

> [!TIP]
> サンプル アプリケーションの設定と使用を単純化するために、このルールではサービスとして "Any" を使用し、1 つのルールで ICMPv4 (ping) も許可しています。 しかし、このような設定は推奨されません。 ポートとプロトコル ("Services") は、アプリケーションが正常に動作する範囲で可能な限り狭くし、この領域への攻撃対象領域を小さくすることをお勧めします。
> 
> 

<br />

> [!TIP]
> このルールでは explicit-dest 参照を使用していますが、この点についてはファイアウォールの構成全体で一貫した方法を用いてください。 可読性と保守性の点から、名前付きネットワーク オブジェクトの使用をお勧めします。 ここで explicit-dest を使っているのは、あくまで代替の参照方法を示すことが目的であり、一般にはお勧めできません (特に複雑な構成の場合)。
> 
> 

* **インターネットへの送信ルール**: 任意の発信元ネットワークから特定の宛先ネットワークへのトラフィックの通過を許可する Pass ルールです。 通常、Barracuda NextGen Firewall にはこのルールが、既定のルールとして (ただし無効状態で) あらかじめ設定されています。 このルールを右クリックすると、[Activate Rule] コマンドにアクセスできます。 ここに示したルールの Source 属性には、このドキュメントの前提条件セクションで参考用として作成した 2 つのローカル サブネットを追加しています。
  
    ![ファイアウォール送信ルール][14]
* **DNS ルール**: DNS (ポート 53) のトラフィックのみ DNS サーバーへの通過を許可する Pass ルールです。 この環境では、フロントエンドからバックエンドへのトラフィックは大部分がブロックされるので、このルールによって DNS を明示的に許可しています。
  
    ![ファイアウォール DNS ルール][15]
  
    **注**: このスクリーン ショットには [Connection Method] が含まれています。 このルールは内部 IP アドレス間のトラフィックを対象としているため、NAT 変換は不要です。そのため、この Pass ルールでは [Connection Method] を "No SNAT" に設定しています。
* **サブネット間ルール**: この Pass ルールは、最初から有効になっている既定のルールです。バックエンド サブネット上の任意のサーバーからフロント エンド サブネット上の任意のサーバーへのトラフィックを許可するように変更を加えています。 すべて内部トラフィックが対象となるため、[Connection Method] は [No SNAT] に設定してください。
  
    ![ファイアウォール VNet 間ルール][16]
  
    **注**: [Bi-Directional] チェック ボックスがオフになっていることに注意してください (ほとんどのルールでオフにします)。これをオフにすることによって、ルールが "一方向" に適用されます。つまりバックエンド サブネットからフロント エンド ネットワークへの接続を開始することはできますが、その逆はできません。 このチェック ボックスがオンの場合、双方向のトラフィックにルールが適用されます。論理図の仕様の観点からそれは望ましくありません。
* **全トラフィック拒否ルール**: このルールは (優先度の観点から) 必ず最後に置く必要があります。先行するいずれのルールにも該当しなかったトラフィック フローが、このルールによって破棄されます。 これは既定のルールであり通常は有効になっているため、一般に変更は不要です。 
  
    ![ファイアウォール拒否ルール][17]

> [!IMPORTANT]
> 以上のルールをすべて作成したら、各ルールの優先度を再確認し、トラフィックの許可または拒否が意図したとおりになっていることを確かめてください。 この例では、Barracuda 管理クライアントにおける転送ルールの順序、つまり、そのメイン グリッドに表示させる順序でルールを記載しています。
> 
> 

## <a name="rule-activation"></a>ルールのアクティブ化
論理図の仕様に合わせてルールセットに変更を加えたら、そのルールセットをファイアウォールにアップロードしてアクティブ化する必要があります。

![ファイアウォール ルールのアクティブ化][18]

管理クライアントの右上隅に一連のボタンがあります。 [Send Changes] ボタンをクリックして、変更済みのルールをファイアウォールに送信し、そのうえで [Activate] ボタンをクリックしてください。

ファイアウォールのルールセットをアクティブ化すれば、この例における環境の構築は完了です。

## <a name="traffic-scenarios"></a>トラフィックのシナリオ
> [!IMPORTANT]
> ここでの重要なポイントは、**すべて**のトラフィックはファイアウォールを経由する、ということです。 たとえば、リモート デスクトップで IIS01 サーバーにアクセスするとします。IIS01 サーバーは、実際にはフロント エンド クラウド サービスのフロント エンド サブネット上にありますが、このサーバーにアクセスするためには、RDP でファイアウォールのポート 8014 にアクセスし、ファイアウォールで RDP 要求を内部的に IIS01 RDP ポートにルーティングしてもらう必要があります。 RDP で直接 IIS01 に到達する経路は (ポータルから見える範囲では) 存在しないので、Azure ポータルの [接続] ボタンは機能しません。 つまり、インターネットからのすべての接続は secscv001.cloudapp.net:xxxx (セキュリティ サービスとポート) にリダイレクトされます。
> 
> 

以下のシナリオでは、次のファイアウォール ルールが設定されている必要があります。

1. ファイアウォール管理
2. IIS01 への RDP
3. DNS01 への RDP
4. AppVM01 への RDP
5. AppVM02 への RDP
6. Web へのアプリ トラフィック
7. AppVM01 へのアプリ トラフィック
8. インターネットへの送信
9. フロントエンドから DNS01
10. サブネット間トラフィック (バックエンドからフロント エンドのみ)
11. すべて拒否

実際のファイアウォール ルールセットは通常、ここに挙げた以外にも、数多くのルールを含んでいます。ファイアウォールに設定されるルールの優先番号も、ここに記載されている番号とは異なります。 このルール一覧とそこに割り当てられている数字は、この限られた 11 個のルール間の関連性と相対的な優先度とを示すものです。 つまり、実際のファイアウォールでは、"IIS01 への RDP" のルール番号が 5 になる場合もあるが、それが "ファイアウォール管理" ルールよりも下でかつ "DNS01 への RDP" ルールよりも上であれば、このルール一覧の意図と合致する、ということです。 また、以下のシナリオではこの一覧に沿ってルールが略記されています ("FW ルール 9 (DNS)" など)。 また、トラフィックのシナリオが RDP とは無関係であるときは、簡潔にするために 4 つの RDP ルールを総称して "RDP ルール" と表記しています。

また、ネットワーク セキュリティ グループの適用先は、フロントエンド サブネットとバックエンド サブネットの受信インターネット トラフィックであることに留意してください。

#### <a name="allowed-internet-to-web-server"></a>(許可) インターネットから Web サーバー
1. インターネット ユーザーが、SecSvc001.CloudApp.Net (インターネットに接続されたクラウド サービス) にある HTTP ページを要求します。
2. クラウド サービスは、ポート 80 で開放されているエンドポイントを介して、ファイアウォールのインターフェイス 10.0.0.4:80 にトラフィックを渡します。
3. セキュリティ サブネットに NSG は割り当てられていないため、システムの NSG ルールによってファイアウォールへのトラフィックが許可されます。
4. トラフィックがファイアウォールの内部 IP アドレス (10.0.1.4) に到達します。
5. ファイアウォール ルールの処理が開始されます。
   1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
   2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
   3. FW ルール 6 (Web へのアプリ) が該当し、トラフィックが許可され、ファイアウォールの NAT で 10.0.1.4 (IIS01) に変換されます。
6. フロントエンド サブネットが、以下に示す受信ルールの処理を開始します。
   1. NSG ルール 1 (インターネットをブロック) は該当しません (このトラフィックはファイアウォールによって NAT 変換されます。その時点で発信元アドレスはファイアウォールになっています。ファイアウォールは、セキュリティ サブネット上にあり、フロントエンド サブネットの NSG からは "ローカル" トラフィックに見えるため、このトラフィックは許可されます)。次のルールに進みます。
   2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
7. Web トラフィックをリッスンしている IIS01 が、この要求を受け取って、その処理を開始します。
8. IIS01 が、バックエンド サブネットにある AppVM01 への FTP セッションを開始します。
9. フロントエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
10. フロントエンド サブネットに送信ルールはないので、トラフィックは許可されます。
11. ファイアウォール ルールの処理が開始されます。
    1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
    2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
    3. FW ルール 6 (Web へのアプリ) は該当しません。次のルールに進みます。
    4. FW ルール 7 (バックエンドへのアプリ) が該当し、トラフィックが許可され、ファイアウォールから 10.0.2.5 (AppVM01) に転送されます。
12. バックエンド サブネットが、以下に示す受信ルールの処理を開始します。
    1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
    2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
13. AppVM01 が要求を受信し、セッションを開始して応答します。
14. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
15. バックエンド サブネットに送信 NSG ルールは存在しないので、応答は許可されます。
16. これは、確立済みのセッション上の戻りトラフィックであるため、ファイアウォールは、Web サーバー (IIS01) への応答を許可します。
17. フロントエンド サブネットが、以下に示す受信ルールの処理を開始します。
    1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
    2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
18. IIS サーバーが応答を受信し、AppVM01 とのトランザクションを終了して、HTTP 応答を構築します。要求元にはこの HTTP 応答が返されます。
19. フロントエンド サブネットに送信 NSG ルールは存在しないので、応答は許可されます。
20. HTTP 応答がファイアウォールに到達します。これは確立済みの NAT セッションへの応答であるため、ファイアウォールはこれを許可します。
21. ファイアウォールは応答をリダイレクトしてインターネット ユーザーに返します。
22. フロント エンド サブネットには送信 NSG ルールも UDR ホップも存在しないので、この応答は許可され、インターネット ユーザーは要求した Web ページを受信します。

#### <a name="allowed-internet-rdp-to-backend"></a>(許可) インターネットからバックエンドへの RDP
1. インターネット上のサーバー管理者が、SecSvc001.CloudApp.Net:8025 経由で AppVM01 への RDP セッションを要求します。8025 は、"AppVM01 への RDP" ファイアウォール ルールでユーザーが割り当てたポート番号です。
2. クラウド サービスは、ポート 8025 で開放されているエンドポイントを介して、ファイアウォールのインターフェイス 10.0.0.4:8025 にトラフィックを渡します。
3. セキュリティ サブネットに NSG は割り当てられていないため、システムの NSG ルールによってファイアウォールへのトラフィックが許可されます。
4. ファイアウォール ルールの処理が開始されます。
   1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
   2. FW ルール 2 (RDP IIS) は該当しません。次のルールに進みます。
   3. FW ルール 3 (RDP DNS01) は該当しません。次のルールに進みます。
   4. FW ルール 4 (RDP AppVM01) が該当し、トラフィックが許可され、ファイアウォールの NAT で 10.0.2.5:3386 (AppVM01 の RDP ポート) に変換されます。
5. バックエンド サブネットが、以下に示す受信ルールの処理を開始します。
   1. NSG ルール 1 (インターネットをブロック) は該当しません (このトラフィックはファイアウォールによって NAT 変換されます。その時点で発信元アドレスはファイアウォールになっています。ファイアウォールは、セキュリティ サブネット上にあり、バックエンド サブネットの NSG からは "ローカル" トラフィックに見えるため、このトラフィックは許可されます)。次のルールに進みます。
   2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
6. RDP トラフィックをリッスンしている AppVM01 が応答します。
7. 送信 NSG ルールはないので既定のルールが適用され、戻りトラフィックが許可されます。
8. 送信トラフィックの次ホップは、UDR によってファイアウォールに設定されます。
9. これは、確立済みのセッション上の戻りトラフィックであるため、ファイアウォールは、インターネット ユーザーへの応答を許可します。
10. RDP セッションが可能な状態になります。
11. AppVM01 はユーザー名とパスワードを求めるメッセージを表示します。

#### <a name="allowed-web-server-dns-lookup-on-dns-server"></a>(許可) DNS サーバーに対する Web サーバーの DNS 参照
1. Web サーバーである IIS01 が、www.data.gov にあるデータ フィードを必要としています。そのためにはアドレスを解決する必要があります。
2. VNet 用のネットワーク構成にはプライマリ DNS サーバーとして、DNS01 (バックエンド サブネット上の 10.0.2.4) がリストされており、IIS01 は DNS 要求を DNS01 に送信します。
3. 送信トラフィックの次ホップは、UDR によってファイアウォールに設定されます。
4. フロントエンド サブネットに送信 NSG ルールはバインドされていないので、トラフィックは許可されます。
5. ファイアウォール ルールの処理が開始されます。
   1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
   2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
   3. FW ルール 6 ～ 7 (アプリ ルール) は該当しません。次のルールに進みます。
   4. FW ルール 8 (インターネットへの送信) は該当しません。次のルールに進みます。
   5. FW ルール 9 (DNS) が該当し、トラフィックが許可され、ファイアウォールから 10.0.2.4 (DNS01) に転送されます。
6. バックエンド サブネットが、以下に示す受信ルールの処理を開始します。
   1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
   2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
7. DNS サーバーが要求を受信します。
8. DNS サーバーは、アドレスがキャッシュされていないことがわかると、インターネット上のルート DNS サーバーに要求します。
9. 送信トラフィックの次ホップは、UDR によってファイアウォールに設定されます。
10. バックエンド サブネットに送信 NSG ルールはないので、トラフィックは許可されます。
11. ファイアウォール ルールの処理が開始されます。
    1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
    2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
    3. FW ルール 6 ～ 7 (アプリ ルール) は該当しません。次のルールに進みます。
    4. FW ルール 8 (インターネットへの送信) が該当し、トラフィックが許可されます。セッションは SNAT 変換されて、インターネット上のルート DNS サーバーに転送されます。
12. インターネット DNS サーバーが応答します。このセッションはファイアウォールから開始されたため、ファイアウォールはこの応答を許可します。
13. これは確立済みのセッションであるため、ファイアウォールは、開始元のサーバーである DNS01 に応答を転送します。
14. バックエンド サブネットが、以下に示す受信ルールの処理を開始します。
    1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
    2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
15. DNS サーバーが応答を受信し、キャッシュした後、最初の要求への応答を IIS01 に返します。
16. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
17. バックエンド サブネットに送信 NSG ルールは存在しないので、トラフィックは許可されます。
18. これはファイアウォールで確立済みのセッションであるため、応答は、ファイアウォールから IIS サーバーに転送されます。
19. フロントエンド サブネットが、以下に示す受信ルールの処理を開始します。
    1. バックエンド サブネットからフロントエンド サブネットへの受信トラフィックに適用される NSG ルールは存在しません。つまり、該当する NSG ルールはありません。
    2. サブネット間のトラフィックを許可する既定のシステム ルールであれば、このトラフィックを許可するので、トラフィックは許可されます。
20. IIS01 が DNS01 から応答を受信します。

#### <a name="allowed-backend-server-to-frontend-server"></a>(許可) バックエンド サーバーからフロントエンド サーバー
1. AppVM02 にログオンしている管理者が RDP 経由で、IIS01 サーバーにあるファイルを Windows エクスプローラーで直接要求します。
2. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
3. バックエンド サブネットに送信 NSG ルールは存在しないので、応答は許可されます。
4. ファイアウォール ルールの処理が開始されます。
   1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
   2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
   3. FW ルール 6 ～ 7 (アプリ ルール) は該当しません。次のルールに進みます。
   4. FW ルール 8 (インターネットへの送信) は該当しません。次のルールに進みます。
   5. FW ルール 9 (DNS) は該当しません。次のルールに進みます。
   6. FW ルール 10 (サブネット間) が該当し、トラフィックが許可され、ファイアウォールから 10.0.1.4 (IIS01) に転送されます。
5. フロントエンド サブネットが、以下に示す受信ルールの処理を開始します。
   1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
   2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
6. しかるべき認証と承認を経て、IIS01 が要求を受け付け、応答します。
7. フロントエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
8. フロントエンド サブネットに送信 NSG ルールは存在しないので、応答は許可されます。
9. これはファイアウォールの既存セッションであるため、ファイアウォールはこの応答を許可して、AppVM02 に返します。
10. バックエンド サブネットが、以下に示す受信ルールの処理を開始します。
    1. NSG ルール 1 (インターネットをブロック) は該当しません。次のルールに進みます。
    2. 既定の NSG ルールではサブネット間トラフィックが許可されます。トラフィックは許可され、NSG ルールの処理はここで終了します。
11. AppVM02 が応答を受信します。

#### <a name="denied-internet-direct-to-web-server"></a>(拒否) Web サーバーへの直接インターネット アクセス
1. インターネット ユーザーが、FrontEnd001.CloudApp.Net サービスを介して Web サーバー (IIS01) へのアクセスを試みます。
2. HTTP トラフィック用に開放されたエンドポイントがないので、このアクセスはクラウド サービスを通過できず、サーバーに到達しません。
3. 仮に何らかの理由でエンドポイントが開放されていた場合、フロントエンド サブネットの NSG (インターネット ブロック) によってこのトラフィックはブロックされます。
4. 最終的に、IIS01 からの送信トラフィックはすべて、フロントエンド サブネットの UDR ルートによって、その次ホップであるファイアウォールに送信されます。ファイアウォールは、これを非対称トラフィックと見なし、送信応答を破棄します。このように、インターネットと IIS01 間には、クラウド サービスを挟んで、少なくとも 3 つの独立した防御層が存在し、未承認/不適切なアクセスを防止しています。

#### <a name="denied-internet-to-backend-server"></a>(拒否) インターネットからバックエンド サーバー
1. インターネット ユーザーが、BackEnd001.CloudApp.Net サービスを介して AppVM01 上のファイルにアクセスを試みます。
2. ファイル共有用に開放されたエンドポイントがないので、このアクセスはクラウド サービスを通過できず、サーバーに到達しません。
3. 仮に何らかの理由でエンドポイントが開放されていた場合、NSG (インターネット ブロック) によってこのトラフィックはブロックされます。
4. 最終的に、AppVM01 からの送信トラフィックはすべて、UDR ルートによって、その次ホップであるファイアウォールに送信されます。ファイアウォールは、これを非対称トラフィックと見なし、送信応答を破棄します。このように、インターネットと AppVM01 間には、クラウド サービスを挟んで、少なくとも 3 つの独立した防御層が存在し、未承認/不適切なアクセスを防止しています。

#### <a name="denied-frontend-server-to-backend-server"></a>(拒否) フロントエンド サーバーからバックエンド サーバー
1. IIS01 のセキュリティが侵害され、バックエンド サブネットのサーバーをスキャンする悪質なコードが実行されているとします。
2. フロントエンド サブネットの UDR ルートに従い、IIS01 からの送信トラフィックはすべて、次ホップであるファイアウォールに送信されます。 侵入を受けた VM が、この部分に手を加えることはできません。
3. トラフィックにはファイアウォールの処理が適用されます。仮に要求の宛先が AppVM01 または DNS サーバー (DNS 参照) であった場合、そのトラフィックはファイアウォール (FW ルール 7 および 9) によって許可される可能性があります。 それ以外のトラフィックは、FW ルール 11 (すべて拒否) によってすべてブロックされます。
4. ファイアウォールで ATD (Advanced Threat Detection) が有効になっていた場合 (このドキュメントでは詳しい説明は省略します。実際のネットワーク アプライアンスの ATD 機能については、ベンダーのドキュメントを参照してください)、このドキュメントで触れた基本的な転送ルールでは許可されてしまうようなトラフィックでも、そのトラフィックに既知のシグネチャ (攻撃パターン) が含まれていてそのルールで検出されれば防ぐことが可能です。

#### <a name="denied-internet-dns-lookup-on-dns-server"></a>(拒否) インターネットから DNS サーバーへの DNS 参照
1. インターネット ユーザーが、BackEnd001.CloudApp.Net サービスを介して DNS01 上の内部 DNS レコードを参照しようとしています。 
2. DNS トラフィック用に開放されたエンドポイントがないので、このアクセスはクラウド サービスを通過できず、サーバーに到達しません。
3. 仮に何らかの理由でエンドポイントが開放されていた場合、フロントエンド サブネットの NSG (インターネット ブロック) ルールによってこのトラフィックはブロックされます。
4. 最終的に、DNS01 からの送信トラフィックはすべて、バックエンド サブネットの UDR ルートによって、その次ホップであるファイアウォールに送信されます。ファイアウォールは、これを非対称トラフィックと見なし、送信応答を破棄します。このように、インターネットと DNS01 間には、クラウド サービスを挟んで、少なくとも 3 つの独立した防御層が存在し、未承認/不適切なアクセスを防止しています。

#### <a name="denied-internet-to-sql-access-through-firewall"></a>(拒否) インターネットからファイアウォールを経由して SQL にアクセス
1. インターネット ユーザーが、SecSvc001.CloudApp.Net (インターネットに接続されたクラウド サービス) にある SQL データを要求します。
2. SQL 用に開放されているエンドポイントがないので、このアクセスはクラウド サービスを通過できず、ファイアウォールに到達しません。
3. 仮に何らかの理由で SQL エンドポイントが開放されていた場合、ファイアウォールでルールの処理が開始されます。
   1. FW ルール 1 (FW 管理) は該当しません。次のルールに進みます。
   2. FW ルール 2 ～ 5 (RDP ルール) は該当しません。次のルールに進みます。
   3. FW ルール 6 ～ 7 (アプリケーション ルール) は該当しません。次のルールに進みます。
   4. FW ルール 8 (インターネットへの送信) は該当しません。次のルールに進みます。
   5. FW ルール 9 (DNS) は該当しません。次のルールに進みます。
   6. FW ルール 10 (サブネット間) は該当しません。次のルールに進みます。
   7. FW ルール 11 (すべて拒否) が該当し、トラフィックはブロックされ、ルールの処理はここで終了します。

## <a name="references"></a>参照
### <a name="main-script-and-network-config"></a>主要なスクリプトとネットワーク構成
PowerShell スクリプト ファイルに完全なスクリプトを保存します。 "NetworkConf2.xml" という名前のファイルにネットワーク構成を保存します。
必要に応じて、ユーザー定義の変数を変更します。 スクリプトを実行し、前述のファイアウォール ルールのセットアップ手順に従ってください。

#### <a name="full-script"></a>完全なスクリプト
このスクリプトは、ユーザー定義の変数に基づいています。

1. Azure サブスクリプションに接続する
2. 新しいストレージ アカウントの作成
3. ネットワーク構成ファイルの定義に従って VNet を 1 つ、サブネットを 3 つ新規に作成する
4. 仮想マシンを 5 つ作成する (ファイアウォール用に 1 つと Windows Server 用に 4 つ)
5. UDR を構成する
   1. 新しいルート テーブルを 2 つ作成
   2. テーブルにルートを追加
   3. 適切なサブネットにテーブルをバインド
6. ネットワーク仮想アプライアンスで IP 転送を有効にする
7. NSG を構成する
   1. NSG を作成
   2. ルールを追加
   3. 適切なサブネットに NSG をバインド

この PowerShell スクリプトは、インターネットに接続されている PC またはサーバー上でローカルに実行する必要があります。

> [!IMPORTANT]
> このスクリプトを実行すると、PowerShell に警告またはその他の情報メッセージが表示される場合があります。 赤色のエラー メッセージのみが問題の原因となります。
> 
> 

    <# 
     .SYNOPSIS
      Example of DMZ and User Defined Routing in an isolated network (Azure only, no hybrid connections)

     .DESCRIPTION
      This script will build out a sample DMZ setup containing:
       - A default storage account for VM disks
       - Three new cloud services
       - Three Subnets (SecNet, FrontEnd, and BackEnd subnets)
       - A Network Virtual Appliance (NVA), in this case a Barracuda NextGen Firewall
       - One server on the FrontEnd Subnet
       - Three Servers on the BackEnd Subnet
       - IP Forwading from the FireWall out to the internet
       - User Defined Routing FrontEnd and BackEnd Subnets to the NVA

      Before running script, ensure the network configuration file is created in
      the directory referenced by $NetworkConfigFile variable (or update the
      variable to reflect the path and file name of the config file being used).

     .Notes
      Everyone's security requirements are different and can be addressed in a myriad of ways.
      Please be sure that any sensitive data or applications are behind the appropriate
      layer(s) of protection. This script serves as an example of some of the techniques
      that can be used, but should not be used for all scenarios. You are responsible to
      assess your security needs and the appropriate protections needed, and then effectively
      implement those protections.

      Security Service (SecNet subnet 10.0.0.0/24)
       myFirewall - 10.0.0.4

      FrontEnd Service (FrontEnd subnet 10.0.1.0/24)
       IIS01      - 10.0.1.4

      BackEnd Service (BackEnd subnet 10.0.2.0/24)
       DNS01      - 10.0.2.4
       AppVM01    - 10.0.2.5
       AppVM02    - 10.0.2.6

    #>

    # Fixed Variables
        $LocalAdminPwd = Read-Host -Prompt "Enter Local Admin Password to be used for all VMs"
        $VMName = @()
        $ServiceName = @()
        $VMFamily = @()
        $img = @()
        $size = @()
        $SubnetName = @()
        $VMIP = @()

    # User Defined Global Variables
      # These should be changes to reflect your subscription and services
      # Invalid options will fail in the validation section

      # Subscription Access Details
        $subID = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

      # VM Account, Location, and Storage Details
        $LocalAdmin = "theAdmin"
        $DeploymentLocation = "Central US"
        $StorageAccountName = "vmstore02"

      # Service Details
        $SecureService = "SecSvc001"
        $FrontEndService = "FrontEnd001"
        $BackEndService = "BackEnd001"

      # Network Details
        $VNetName = "CorpNetwork"
        $VNetPrefix = "10.0.0.0/16"
        $SecNet = "SecNet"
        $FESubnet = "FrontEnd"
        $FEPrefix = "10.0.1.0/24"
        $BESubnet = "BackEnd"
        $BEPrefix = "10.0.2.0/24"
        $NetworkConfigFile = "C:\Scripts\NetworkConf3.xml"

      # VM Base Disk Image Details
        $SrvImg = Get-AzureVMImage | Where {$_.ImageFamily -match 'Windows Server 2012 R2 Datacenter'} | sort PublishedDate -Descending | Select ImageName -First 1 | ForEach {$_.ImageName}
        $FWImg = Get-AzureVMImage | Where {$_.ImageFamily -match 'Barracuda NextGen Firewall'} | sort PublishedDate -Descending | Select ImageName -First 1 | ForEach {$_.ImageName}

      # UDR Details
        $FERouteTableName = "FrontEndSubnetRouteTable"
        $BERouteTableName = "BackEndSubnetRouteTable"

      # NSG Details
        $NSGName = "MyVNetSG"

    # User Defined VM Specific Config
        # Note: To ensure UDR and IP forwarding is setup
        # properly this script requires VM 0 be the NVA.

        # VM 0 - The Network Virtual Appliance (NVA)
          $VMName += "myFirewall"
          $ServiceName += $SecureService
          $VMFamily += "Firewall"
          $img += $FWImg
          $size += "Small"
          $SubnetName += $SecNet
          $VMIP += "10.0.0.4"

        # VM 1 - The Web Server
          $VMName += "IIS01"
          $ServiceName += $FrontEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $FESubnet
          $VMIP += "10.0.1.4"

        # VM 2 - The First Appliaction Server
          $VMName += "AppVM01"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.5"

        # VM 3 - The Second Appliaction Server
          $VMName += "AppVM02"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.6"

        # VM 4 - The DNS Server
          $VMName += "DNS01"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.4"

    # ----------------------------- #
    # No User Defined Varibles or   #
    # Configuration past this point #
    # ----------------------------- #

      # Get your Azure accounts
        Add-AzureAccount
        Set-AzureSubscription –SubscriptionId $subID -ErrorAction Stop
        Select-AzureSubscription -SubscriptionId $subID -Current -ErrorAction Stop

      # Create Storage Account
        If (Test-AzureName -Storage -Name $StorageAccountName) { 
            Write-Host "Fatal Error: This storage account name is already in use, please pick a diffrent name." -ForegroundColor Red
            Return}
        Else {Write-Host "Creating Storage Account" -ForegroundColor Cyan 
              New-AzureStorageAccount -Location $DeploymentLocation -StorageAccountName $StorageAccountName}

      # Update Subscription Pointer to New Storage Account
        Write-Host "Updating Subscription Pointer to New Storage Account" -ForegroundColor Cyan 
        Set-AzureSubscription –SubscriptionId $subID -CurrentStorageAccountName $StorageAccountName -ErrorAction Stop

    # Validation
    $FatalError = $false

    If (-Not (Get-AzureLocation | Where {$_.DisplayName -eq $DeploymentLocation})) {
         Write-Host "This Azure Location was not found or available for use" -ForegroundColor Yellow
         $FatalError = $true}

    If (Test-AzureName -Service -Name $SecureService) { 
        Write-Host "The SecureService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The FrontEndService service name is valid for use." -ForegroundColor Green}

    If (Test-AzureName -Service -Name $FrontEndService) { 
        Write-Host "The FrontEndService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The FrontEndService service name is valid for use" -ForegroundColor Green}

    If (Test-AzureName -Service -Name $BackEndService) { 
        Write-Host "The BackEndService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The BackEndService service name is valid for use." -ForegroundColor Green}

    If (-Not (Test-Path $NetworkConfigFile)) { 
        Write-Host 'The network config file was not found, please update the $NetworkConfigFile variable to point to the network config xml file.' -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The network config file was found" -ForegroundColor Green
            If (-Not (Select-String -Pattern $DeploymentLocation -Path $NetworkConfigFile)) {
                Write-Host 'The deployment location was not found in the network config file, please check the network config file to ensure the $DeploymentLocation varible is correct and the netowrk config file matches.' -ForegroundColor Yellow
                $FatalError = $true}
            Else { Write-Host "The deployment location was found in the network config file." -ForegroundColor Green}}

    If ($FatalError) {
        Write-Host "A fatal error has occured, please see the above messages for more information." -ForegroundColor Red
        Return}
    Else { Write-Host "Validation passed, now building the environment." -ForegroundColor Green}

    # Create VNET
        Write-Host "Creating VNET" -ForegroundColor Cyan 
        Set-AzureVNetConfig -ConfigurationPath $NetworkConfigFile -ErrorAction Stop

    # Create Services
        Write-Host "Creating Services" -ForegroundColor Cyan
        New-AzureService -Location $DeploymentLocation -ServiceName $SecureService -ErrorAction Stop
        New-AzureService -Location $DeploymentLocation -ServiceName $FrontEndService -ErrorAction Stop
        New-AzureService -Location $DeploymentLocation -ServiceName $BackEndService -ErrorAction Stop

    # Build VMs
        $i=0
        $VMName | Foreach {
            Write-Host "Building $($VMName[$i])" -ForegroundColor Cyan
            If ($VMFamily[$i] -eq "Firewall") 
                { 
                New-AzureVMConfig -Name $VMName[$i] -ImageName $img[$i] –InstanceSize $size[$i] | `
                    Add-AzureProvisioningConfig -Linux -LinuxUser $LocalAdmin -Password $LocalAdminPwd  | `
                    Set-AzureSubnet  –SubnetNames $SubnetName[$i] | `
                    Set-AzureStaticVNetIP -IPAddress $VMIP[$i] | `
                    New-AzureVM –ServiceName $ServiceName[$i] -VNetName $VNetName -Location $DeploymentLocation
                # Set up all the EndPoints we'll need once we're up and running
                # Note: All traffic goes through the firewall, so we'll need to set up all ports here.
                #       Also, the firewall will be redirecting traffic to a new IP and Port in a forwarding
                #       rule, so all of these endpoint have the same public and local port and the firewall
                #       will do the mapping, NATing, and/or redirection as declared in the firewall rules.
                Add-AzureEndpoint -Name "MgmtPort1" -Protocol tcp -PublicPort 801  -LocalPort 801  -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "MgmtPort2" -Protocol tcp -PublicPort 807  -LocalPort 807  -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "HTTP"      -Protocol tcp -PublicPort 80   -LocalPort 80   -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPWeb"    -Protocol tcp -PublicPort 8014 -LocalPort 8014 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPApp1"   -Protocol tcp -PublicPort 8025 -LocalPort 8025 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPApp2"   -Protocol tcp -PublicPort 8026 -LocalPort 8026 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPDNS01"  -Protocol tcp -PublicPort 8024 -LocalPort 8024 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                # Note: A SSH endpoint is automatically created on port 22 when the appliance is created.
                }
            Else
                {
                New-AzureVMConfig -Name $VMName[$i] -ImageName $img[$i] –InstanceSize $size[$i] | `
                    Add-AzureProvisioningConfig -Windows -AdminUsername $LocalAdmin -Password $LocalAdminPwd  | `
                    Set-AzureSubnet  –SubnetNames $SubnetName[$i] | `
                    Set-AzureStaticVNetIP -IPAddress $VMIP[$i] | `
                    Set-AzureVMMicrosoftAntimalwareExtension -AntimalwareConfiguration '{"AntimalwareEnabled" : true}' | `
                    Remove-AzureEndpoint -Name "RemoteDesktop" | `
                    Remove-AzureEndpoint -Name "PowerShell" | `
                    New-AzureVM –ServiceName $ServiceName[$i] -VNetName $VNetName -Location $DeploymentLocation
                }
            $i++
        }

    # Configure UDR and IP Forwarding
        Write-Host "Configuring UDR" -ForegroundColor Cyan

      # Create the Route Tables
        Write-Host "Creating the Route Tables" -ForegroundColor Cyan 
        New-AzureRouteTable -Name $BERouteTableName `
            -Location $DeploymentLocation `
            -Label "Route table for $BESubnet subnet"
        New-AzureRouteTable -Name $FERouteTableName `
            -Location $DeploymentLocation `
            -Label "Route table for $FESubnet subnet"

      # Add Routes to Route Tables
        Write-Host "Adding Routes to the Route Tables" -ForegroundColor Cyan 
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $BEPrefix `
            -NextHopType VNETLocal
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $FEPrefix `
            -NextHopType VNETLocal

      # Assoicate the Route Tables with the Subnets
        Write-Host "Binding Route Tables to the Subnets" -ForegroundColor Cyan 
        Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
            -SubnetName $BESubnet `
            -RouteTableName $BERouteTableName
        Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
            -SubnetName $FESubnet `
            -RouteTableName $FERouteTableName

     # Enable IP Forwarding on the Virtual Appliance
        Get-AzureVM -Name $VMName[0] -ServiceName $ServiceName[0] `
            |Set-AzureIPForwarding -Enable

    # Configure NSG
        Write-Host "Configuring the Network Security Group (NSG)" -ForegroundColor Cyan

      # Build the NSG
        Write-Host "Building the NSG" -ForegroundColor Cyan
        New-AzureNetworkSecurityGroup -Name $NSGName -Location $DeploymentLocation -Label "Security group for $VNetName subnets in $DeploymentLocation"

      # Add NSG Rule
        Write-Host "Writing rules into the NSG" -ForegroundColor Cyan
        Get-AzureNetworkSecurityGroup -Name $NSGName | Set-AzureNetworkSecurityRule -Name "Isolate the $VNetName VNet from the Internet" -Type Inbound -Priority 100 -Action Deny `
            -SourceAddressPrefix INTERNET -SourcePortRange '*' `
            -DestinationAddressPrefix VIRTUAL_NETWORK -DestinationPortRange '*' `
            -Protocol *

      # Assign the NSG to two Subnets
        # The NSG is *not* bound to the Security Subnet. The result
        # is that internet traffic flows only to the Security subnet
        # since the NSG bound to the Frontend and Backback subnets
        # will Deny internet traffic to those subnets.
        Write-Host "Binding the NSG to two subnets" -ForegroundColor Cyan
        Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName -SubnetName $FESubnet -VirtualNetworkName $VNetName
        Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName -SubnetName $BESubnet -VirtualNetworkName $VNetName

    # Optional Post-script Manual Configuration
      # Configure Firewall
      # Install Test Web App (Run Post-Build Script on the IIS Server)
      # Install Backend resource (Run Post-Build Script on the AppVM01)
      Write-Host
      Write-Host "Build Complete!" -ForegroundColor Green
      Write-Host
      Write-Host "Optional Post-script Manual Configuration Steps" -ForegroundColor Gray
      Write-Host " - Configure Firewall" -ForegroundColor Gray
      Write-Host " - Install Test Web App (Run Post-Build Script on the IIS Server)" -ForegroundColor Gray
      Write-Host " - Install Backend resource (Run Post-Build Script on the AppVM01)" -ForegroundColor Gray
      Write-Host


#### <a name="network-config-file"></a>ネットワーク構成ファイル
この xml ファイルに実際のロケーション情報に反映して保存し、このファイルへのリンクを上記スクリプト内の $NetworkConfigFile 変数に追加します。

    <NetworkConfiguration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/ServiceHosting/2011/07/NetworkConfiguration">
      <VirtualNetworkConfiguration>
        <Dns>
          <DnsServers>
            <DnsServer name="DNS01" IPAddress="10.0.2.4" />
            <DnsServer name="Level3" IPAddress="209.244.0.3" />
          </DnsServers>
        </Dns>
        <VirtualNetworkSites>
          <VirtualNetworkSite name="CorpNetwork" Location="Central US">
            <AddressSpace>
              <AddressPrefix>10.0.0.0/16</AddressPrefix>
            </AddressSpace>
            <Subnets>
              <Subnet name="SecNet">
                <AddressPrefix>10.0.0.0/24</AddressPrefix>
              </Subnet>
              <Subnet name="FrontEnd">
                <AddressPrefix>10.0.1.0/24</AddressPrefix>
              </Subnet>
              <Subnet name="BackEnd">
                <AddressPrefix>10.0.2.0/24</AddressPrefix>
              </Subnet>
            </Subnets>
            <DnsServersRef>
              <DnsServerRef name="DNS01" />
              <DnsServerRef name="Level3" />
            </DnsServersRef>
          </VirtualNetworkSite>
        </VirtualNetworkSites>
      </VirtualNetworkConfiguration>
    </NetworkConfiguration>

#### <a name="sample-application-scripts"></a>サンプル アプリケーション スクリプト
これに対応するサンプル アプリケーション、およびその他の DMZ の例をインストールしたい場合は、[サンプル アプリケーション スクリプト][SampleApp]をご利用ください。

<!--Image References-->
[1]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/example3design.png "双方向 DMZ + NVA、NSG、および UDR"
[2]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/example3firewalllogical.png "ファイアウォール ルールの論理ビュー"
[3]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectfrontend.png "フロントエンド ネットワーク オブジェクトの作成"
[4]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectdns.png "DNS サーバー オブジェクトの作成"
[5]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectrdpa.png "既定の RDP ルールのコピー"
[6]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectrdpb.png "AppVM01 ルール"
[7]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/iconapplicationredirect.png "アプリケーション リダイレクト アイコン"
[8]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/icondestinationnat.png "送信先 NAT アイコン"
[9]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/iconpass.png "Pass アイコン"
[10]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/rulefirewall.png "ファイアウォール管理ルール"
[11]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/rulerdp.png "ファイアウォール RDP ルール"
[12]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleweb.png "ファイアウォール Web ルール"
[13]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleappvm01.png "ファイアウォール AppVM01 ルール"
[14]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleoutbound.png "ファイアウォール送信ルール"
[15]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruledns.png "ファイアウォール DNS ルール"
[16]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleintravnet.png "ファイアウォール VNet 間ルール"
[17]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruledeny.png "ファイアウォール拒否ルール"
[18]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/firewallruleactivate.png "ファイアウォール ルールのアクティブ化"

<!--Link References-->
[HOME]: ../best-practices-network-security.md
[SampleApp]: ./virtual-networks-sample-app.md

