---
title: 境界ネットワークの例 – ファイアウォール、UDR、および NSG で構成される境界ネットワークを使用してネットワークを保護する | Microsoft Docs
description: ファイアウォール、ユーザー定義ルーティング (UDR)、ネットワーク セキュリティ グループ (NSG) を含む境界ネットワーク (DMZ ともいう) を構築します。
services: virtual-network
documentationcenter: na
author: tracsman
manager: rossort
editor: ''
ms.assetid: dc01ccfb-27b0-4887-8f0b-2792f770ffff
ms.service: virtual-network
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/01/2016
ms.author: jonor;sivae
ms.openlocfilehash: 668862714b416bd89d3b5f82caf8b0305fccae54
ms.sourcegitcommit: ef20235daa0eb98a468576899b590c0bc1a38394
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2019
ms.locfileid: "59426530"
---
# <a name="example-3-build-a-perimeter-network-to-protect-networks-with-a-firewall-udr-and-nsgs"></a>例 3:境界ネットワークを構築し、ファイアウォール、UDR、および NSG を使用してネットワークを保護する

[セキュリティ境界のベスト プラクティス ページに戻る][HOME]

この例では、境界ネットワーク (DMZ、非武装地帯、スクリーン サブネットともいう) を作成します。 例では、ファイアウォール、4 台の Windows サーバー、ユーザー定義ルーティング (UDR)、IP 転送、およびネットワーク セキュリティ グループ (NSG) を実装します。 この記事では、各手順をより深く理解できるように、関連するコマンドを順に説明します。 また、トラフィック シナリオ セクションでは、トラフィックが境界ネットワークの防御層を通過する過程を詳しく説明します。 最後の「参照」セクションには、さまざまなシナリオでテストおよび実験ができるように、この環境を構築するためのすべてのコードと手順が含まれています。

![NVA、NSG、UDR を含む双方向境界ネットワーク][1]

## <a name="environment-setup"></a>環境のセットアップ

この例では、以下のコンポーネントを含むサブスクリプションを使用します。

* 3 つのクラウド サービス:SecSvc001、FrontEnd001、BackEnd001
* 次の 3 つのサブネットを含む仮想ネットワーク (CorpNetwork):SecNet、FrontEnd、BackEnd
* ネットワーク仮想アプライアンス: SecNet サブネットに接続されたファイアウォール
* アプリケーション Web サーバーを表す Windows サーバー:IIS01
* アプリケーション バックエンド サーバーを表す 2 つの Windows サーバー:AppVM01、AppVM02
* DNS サーバーを表す Windows サーバー:DNS01

[「参照」セクション](#references)には、ここで説明しているほとんどの環境を構築する PowerShell スクリプトが含まれます。 それ以外、この記事では仮想マシン (VM) と仮想ネットワークを構築するための詳しい手順は示されていません。

環境を構築するには

1. [「参照」セクション](#references)に含まれるネットワーク構成 XML ファイルを保存します。 特定のシナリオと一致するように、名前、場所、および IP アドレスで更新する必要があります。
1. 完全なスクリプトでユーザー変数を更新し、自分の特定の環境 (サブスクリプション、サービス名など) と一致させます。
1. PowerShell でスクリプトを実行します。

> [!NOTE]
> PowerShell スクリプトで指定されたリージョンと、ネットワーク構成 XML ファイルで指定されたリージョンが一致している必要があります。

スクリプトが正常に実行された後、次の手順を行います。

1. ファイアウォール ルールを設定します。 「[ファイアウォール規則](#firewall-rules)」セクションを参照してください。
1. 必要に応じて、「参照」セクションの 2 つのスクリプトを使用して、Web サーバーとアプリ サーバーで Web アプリケーションを設定し、この DMZ 構成をテストできるようにします。

## <a name="user-defined-routing"></a>ユーザー定義のルーティング

既定では、次のシステム ルートが定義されています。

    Effective routes :
     Address Prefix    Next hop type    Next hop IP address Status   Source
     --------------    -------------    ------------------- ------   ------
     {10.0.0.0/16}     VNETLocal                            Active   Default
     {0.0.0.0/0}       internet                             Active   Default
     {10.0.0.0/8}      Null                                 Active   Default
     {100.64.0.0/10}   Null                                 Active   Default
     {172.16.0.0/12}   Null                                 Active   Default
     {192.168.0.0/16}  Null                                 Active   Default

VNETLocal は常に、その特定の仮想ネットワークに対して定義されるアドレス プレフィックスです。 たとえば、特定の各仮想ネットワークの定義方法に応じて、仮想ネットワーク間で変わります。 その他のシステム ルートは静的なものであり、上記のように既定値となっています。

優先順位に関しては、ルートは最長プレフィックス マッチ (LPM) 方法を使用して処理されます。 そのため、テーブル内で最も具体的なルートが、特定の宛先アドレスに適用されます。

したがって、ローカル ネットワーク (10.0.0.0/16) 上の DNS01 (10.0.2.4) のようなサーバーを対象としたトラフィックは、ルートが 10.0.0.0/16 であるため、仮想ネットワークを介してルーティングされます。  10.0.2.4 の場合、10.0.0.0/16 ルートが最も具体的なルートです。 10.0.0.0/8 と 0.0.0.0/0 も適用可能な場合でも、このルールが適用されます。 しかし、これらは具体性が低いため、このトラフィックには影響しません。 10.0.2.4 へのトラフィックでは次ホップとしてローカル仮想ネットワークが指定されているため、宛先にルーティングされます。

たとえば、10.0.0.0/16 ルートは、10.1.1.1 を対象とするトラフィックには適用されません。 10.0.0.0/8 システム ルートは最も具体的なものであり、次ホップが Null であるため、トラフィックは破棄されるか "ブラックホール" されます。

宛先がいずれの Null プレフィックスにも VNETLocal プレフィックスにも適用されない場合、トラフィックは具体性の最も低いルート (0.0.0.0/0) に従います。 次ホップであるインターネットにルーティングされ、Azure のインターネット エッジの外に送出されます。

まったく同じ 2 つのプレフィックスがルート テーブルに存在した場合、優先順はルートのソース属性に基づきます。

1. VirtualAppliance:テーブルに手動で追加されたユーザー定義ルート。
1. VPNGateway:動的ネットワーク プロトコルによって追加された動的ルート (ハイブリッド ネットワークで使用される場合は BGP)。 動的プロトコルではピア ネットワークの変更が自動的に反映されるため、これらのルートは時間の経過と共に変わる場合があります。
1. 既定値は上記のルート テーブルに示されているシステム ルート、ローカル仮想ネットワーク、静的エントリ。

> [!NOTE]
> これで、ExpressRoute と VPN Gateway でユーザー定義ルーティング (UDR) を使用して、アウトバウンドおよびインバウンド クロスプレミス トラフィックをネットワーク仮想アプライアンス (NVA) に強制的にルーティングできるようになりました。

### <a name="create-local-routes"></a>ローカル ルートを作成する

この例では、フロントエンドとバックエンドのサブネットに対して 1 つずつ、2 つのルーティング テーブルを使用します。 各サブネットに適した静的ルートをそれぞれのテーブルに読み込みます。 この例では、各テーブルに 3 つのルートが存在します。

1. 次ホップが定義されていないローカル サブネット トラフィック。 このルートでは、ローカル サブネット トラフィックでファイアウォールをバイパスできます。
2. 次ホップがファイアウォールとして定義されている仮想ネットワーク トラフィック。 このルートでは、ローカル仮想ネットワーク トラフィックによる直接ルーティングを許可する既定のルールがオーバーライドされます。
3. 次ホップがファイアウォールとして定義されている他のすべてのトラフィック (0/0)。

ルーティング テーブルが作成された後、対応するサブネットにバインドされます。 フロントエンド サブネット ルーティング テーブルは次のようになります。

    Effective routes :
     Address Prefix    Next hop type       Next hop IP address  Status   Source
     --------------    ------------------  -------------------  ------   ------
     {10.0.1.0/24}     VNETLocal                                Active
     {10.0.0.0/16}     VirtualAppliance    10.0.0.4             Active
     {0.0.0.0/0}       VirtualAppliance    10.0.0.4             Active

この例では以下のコマンドを使用して、ルート テーブルを構築し、ユーザー定義ルートを追加してから、ルート テーブルをサブネットにバインドします。 `$BESubnet` など、`$` で始まる項目は、「参照」セクションのスクリプトからのユーザー定義変数です。

1. まず、ベース ルーティング テーブルを作成します。 次のコード スニペットでは、バックエンド サブネット用のテーブルを作成します。 また、完全なスクリプトでは、フロントエンド サブネット用の対応するテーブルを作成します。

   ```powershell
   New-AzureRouteTable -Name $BERouteTableName `
       -Location $DeploymentLocation `
       -Label "Route table for $BESubnet subnet"
   ```

1. ルート テーブルを作成した後、特定のユーザー定義ルートを追加できます。 次のコード スニペットでは、すべてのトラフィック (0.0.0.0/0) が仮想アプライアンス経由でルーティングされることを指定します。 変数 `$VMIP[0]` は、スクリプトの前半で仮想アプライアンスが作成されたときに割り当てられた IP アドレスを渡すために使用されます。 また、完全なスクリプトでは、フロントエンド テーブルの対応するルールを作成します。

   ```powershell
   Get-AzureRouteTable $BERouteTableName | `
       Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
       -NextHopType VirtualAppliance `
       -NextHopIpAddress $VMIP[0]
   ```

1. 前述のルート エントリによって既定の "0.0.0.0/0" ルートはオーバーライドされますが、既定の 10.0.0.0/16 ルールでは引き続き、仮想ネットワーク内のトラフィックを、ネットワーク仮想アプライアンスにではなく、直接宛先にルーティングできます。 この動作を修正するには、次のルールを追加する必要があります。

   ```powershell
   Get-AzureRouteTable $BERouteTableName | `
       Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
       -NextHopType VirtualAppliance `
       -NextHopIpAddress $VMIP[0]
   ```

1. この時点で、選択する必要があります。 前述の 2 つのルールでは、単一サブネット内のトラフィックを含む、すべてのトラフィックが評価のためにファイアウォールにルーティングされます。 この動作が必要な場合があります。 ただし、必要でない場合は、ファイアウォールを介さずに、サブネット内のトラフィックをローカルでルーティングすることができます。 3 つ目の特定のルールを追加します。このルールでは、ローカル サブネット宛てのすべてのアドレスを直接ルーティングします (NextHopType = VNETLocal)。

   ```powershell
   Get-AzureRouteTable $BERouteTableName | `
       Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $BEPrefix `
           -NextHopType VNETLocal
   ```

1. 最後に、ルーティング テーブルが作成され、ユーザー定義ルートが設定された後、そのテーブルをサブネットにバインドする必要があります。 次のコード スニペットでは、バックエンド サブネット用のテーブルをバインドします。 また、完全なスクリプトでは、フロントエンド ルート テーブルをフロントエンド サブネットにバインドします。

   ```powershell
   Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
       -SubnetName $BESubnet `
       -RouteTableName $BERouteTableName
   ```

## <a name="ip-forwarding"></a>IP 転送

IP 転送は、UDR と併用される機能です。 仮想アプライアンス上のこの設定では、アプライアンス宛てではないトラフィックを受信してから、最終的な宛先にそのトラフィックを転送することができます。

たとえば、AppVM01 からのトラフィックで DNS01 サーバーに要求を行う場合、UDR ではトラフィックをファイアウォールにルーティングします。 IP 転送が有効になっている場合、DNS01 (10.0.2.4) 宛てのトラフィックはファイアウォール アプライアンス (10.0.0.4) で受け入れられてから、最終的な宛先 (10.0.2.4) に転送されます。 ファイアウォールで IP 転送が無効になっている場合、ルート テーブルに次ホップとしてファイアウォールが指定されていても、トラフィックはアプライアンスで受け入れられません。

> [!IMPORTANT]
> 必ず、ユーザー定義ルーティングと併せて IP 転送を有効にしてください。

VM の作成時に、単一のコマンドで IP 転送を有効にすることができます。 ファイアウォール仮想アプライアンスである VM インスタンスを呼び出し、IP 転送を有効にします。 `$VMName[0]` など、`$` で始まる赤色の項目は、このドキュメントの「参照」セクションのスクリプトからのユーザー定義変数であることに注意してください。 角かっこで囲まれたゼロ `[0]` は、VM の配列内の最初の VM を表します。 このスクリプト例を変更せずに機能させるには、最初の VM (VM 0) がファイアウォールである必要があります。 完全なスクリプトでは、関連するコード スニペットが末尾付近の UDR コマンドでグループ化されます。

```powershell
Get-AzureVM -Name $VMName[0] -ServiceName $ServiceName[0] | `
    Set-AzureIPForwarding -Enable
```

## <a name="network-security-groups"></a>ネットワーク セキュリティ グループ

この例では、ネットワーク セキュリティ グループ (NSG) を構築してから、そこに単一のルールを読み込みます。 その後、この例では、(SecNet ではない) フロントエンドとバックエンドのサブネットにのみ、NSG をバインドします。 NSG に読み込むルールは次のとおりです。

* インターネットから仮想ネットワーク全体 (すべてのサブネット) への任意のトラフィック (すべてのポート) を拒否する

この例では NSG が使用されていますが、その主な目的は、手動構成のミスに対する第 2 の防御層としての機能です。 フロントエンド サブネットまたはバックエンド サブネットへのインターネットからのインバウンド トラフィックをすべてブロックする必要があります。 トラフィックは SecNet サブネットを介してのみファイアウォールに流し、その後、適切なトラフィックのみをフロントエンド サブネットまたはバックエンド サブネットにルーティングする必要があります。 また、UDR ルールでは、フロントエンドまたはバックエンドのサブネットに到達するすべてのトラフィックをファイアウォールにルーティングします。 ファイアウォールではそれが非対称フローと見なされ、アウトバウンド トラフィックは破棄されます。

次の 3 層のセキュリティで、フロントエンドとバックエンドのサブネットが保護されます。

1. FrontEnd001 と BackEnd001 のクラウド サービスのエンドポイントをすべて閉じる
1. インターネットからのトラフィックを NSG で拒否する
1. 非対称トラフィックをファイアウォールで破棄する

この例の NSG に関する興味深い点は、以下に示すように、1 つのルールのみが含まれていることです。 このルールでは、セキュリティ サブネットを含む、仮想ネットワーク全体へのインターネット トラフィックが拒否されます。

```powershell
Get-AzureNetworkSecurityGroup -Name $NSGName | `
    Set-AzureNetworkSecurityRule -Name "Isolate the $VNetName VNet `
    from the internet" `
    -Type Inbound -Priority 100 -Action Deny `
    -SourceAddressPrefix INTERNET -SourcePortRange '*' `
    -DestinationAddressPrefix VIRTUAL_NETWORK `
    -DestinationPortRange '*' `
    -Protocol *
```

NSG がバインドされるのはフロントエンド サブネットとバックエンド サブネットのみであるため、セキュリティ サブネットに入ってくるトラフィックに対してルールは適用されません。 その結果、トラフィックはセキュリティ サブネットに到達します。

```powershell
Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName `
    -SubnetName $FESubnet -VirtualNetworkName $VNetName

Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName `
    -SubnetName $BESubnet -VirtualNetworkName $VNetName
```

## <a name="firewall-rules"></a>ファイアウォール規則

ファイアウォールには、転送ルールを作成する必要があります。 ファイアウォールではすべてのインバウンド トラフィック、アウトバウンド トラフィック、仮想ネットワーク間トラフィックがブロックまたは転送されるため、多くのファイアウォール規則が必要です。 また、ファイアウォールでは、(さまざまなポート上の) セキュリティ サービスのパブリック IP アドレスへのすべてのインバウンド トラフィックを処理する必要があります。 後で作業し直さなくても済むように、サブネットとファイアウォール規則を設定する前に論理フローを図式化し、ベスト プラクティスに従います。 次の図では、この例で使用するファイアウォール ルールを論理的に示しています。

![Logical View of the Firewall Rules][2]

> [!NOTE]
> ネットワーク仮想アプライアンスによって、管理ポートは異なります。 この例では、ポート 22、801、807 を使用する Barracuda NextGen Firewall を示します。 デバイスを管理するための実際のポートについては、アプライアンス ベンダーのドキュメントを参照してください。

### <a name="logical-rule-description"></a>論理規則の説明

上の論理図にはセキュリティ サブネットが示されていません。これはファイアウォールがそのサブネットの唯一のリソースであるためです。 この図にはファイアウォール規則が示されています。また、実際の経路ではなく、論理的にトラフィック フローがどのように許可または拒否されるかが示されています。 また、リモート デスクトップ プロトコル (RDP) トラフィック用に選択された外部ポートは、より大きな番号範囲のポート (8014 から 8026) になっています。これらは、ローカル IP アドレスの最後の 2 つのオクテットに合わせ、見やすくするために選択されています。 たとえば、ローカル サーバー アドレス 10.0.1.4 は外部ポート 8014 に関連付けられています。 ただし、競合しなければ、もっと大きなポート番号を使用してもかまいません。

この例では、以下の種類のルールが必要です。

* インバウンド トラフィック用の外部ルール:
  1. ファイアウォール管理ルール: ネットワーク仮想アプライアンスの管理ポートへのトラフィックの通過を許可します。
  2. Windows サーバーごとの RDP ルール: 個々のサーバーを RDP 経由で管理できるようにします。  ネットワーク仮想アプライアンスの機能によっては、ルールを 1 つにバンドルできる場合があります。
  3. アプリケーション トラフィック ルール: フロントエンド Web トラフィック用に 1 つとバックエンド トラフィック用に 1 つ (Web サーバーからデータ層など)。 これらのルールの構成は、ネットワーク アーキテクチャおよびトラフィック フローによって異なります。

     * 最初のルールでは、実際のアプリケーション トラフィックがアプリケーション サーバーに到達できます。 セキュリティや管理などのルールとは異なり、アプリケーション ルールでは、外部のユーザーまたはサービスがアプリケーションにアクセスできるようにします。 この例ではポート 80 に単一の Web サーバーがあります。これにより、単一のファイアウォール アプリケーション ルールでは、外部 IP アドレス宛てのトラフィックをリダイレクトし、代わりに Web サーバーの内部 IP アドレスにルーティングできます。 リダイレクトされたトラフィック セッションは、NAT によって内部サーバーに再マッピングされます。
     * 2 つ目のアプリケーション トラフィック ルールはバックエンド ルールです。Web サーバーで任意のポートを使用して、AppVM02 サーバーではなく、AppVM01 サーバーにトラフィックをルーティングできるようにします。

* 仮想ネットワーク間トラフィック用の内部ルール:
  1. インターネットへのアウトバウンド規則: 任意のネットワークから選択されたネットワークへのトラフィックの通過を許可します。 ファイアウォールでは通常、これが既定のルールですが、無効状態の場合です。 この例では、このルールを有効にします。
  2. DNS ルール: DNS (ポート 53) トラフィックのみに DNS サーバーへの通過を許可します。 この環境では、フロントエンドからバックエンドへのトラフィックの大部分がブロックされます。 このルールによって、任意のローカル サブネットからの DNS を明示的に許可します。
  3. サブネット間ルール: バックエンド サブネット上の任意のサーバーから、フロントエンド サブネット上の任意のサーバーへの接続を許可します。ただし、その逆は許可されません。

* 上記のどの基準も満たしていないトラフィック用のフェールセーフ ルール:
  1. 全トラフィック拒否ルール: 優先度の観点から、これが常に最後のルールとなります。 トラフィック フローが上記のいずれのルールにも一致しなかった場合、このルールでブロックされます。 これが既定のルールになります。 通常はアクティブ化されているため、変更は必要ありません。

> [!TIP]
> 2 つ目のアプリケーション トラフィック ルールでは、この例を簡潔にするために任意のポートが許可されています。 実際のシナリオでは、特定のポートとアドレス範囲を使用して、このルールに対する攻撃面を小さくする必要があります。


> [!IMPORTANT]
> ルールを作成した後、各ルールの優先度を確認し、トラフィックの許可または拒否が意図したとおりになっていることを確かめることが重要です。 この例では、各ルールに優先順位が割り当てられています。 ルールの優先順位に間違いがある場合、ファイアウォールからロックアウトされやすくなります。 ファイアウォール管理ルールには必ず、最も高い絶対優先順位を設定してください。

### <a name="rule-prerequisites"></a>ルールの前提条件

ファイアウォールを実行する仮想マシンには、パブリック エンドポイントが必要になります。 ファイアウォールでトラフィックを処理できるように、これらのパブリック エンドポイントを開く必要があります。 この例には、次の 3 種類のトラフィックがあります。

1. ファイアウォールとファイアウォール規則を制御する管理トラフィック
1. Windows サーバーを制御する RDP トラフィック
1. アプリケーション トラフィック

トラフィックの種類は、上記のファイアウォール規則の論理図の上半分に示されています。

> [!IMPORTANT]
> *すべて*のトラフィックがファイアウォールを経由することに注意してください。 IIS01 サーバーにリモート デスクトップ接続するには、ポート 8014 上のファイアウォールに接続してから、ファイアウォールで IIS01 RDP ポートに内部的に RDP 要求をルーティングできるようにします。 Azure ポータルの **[接続]** ボタンは機能しません。これは、RDP で直接 IIS01 に到達する経路が、ポータルから見える範囲では存在しないためです。 インターネットからのすべての接続は、セキュリティ サービスとポート (secscv001.cloudapp.net:xxxx など) に対するものです。 外部ポートおよび内部 IP とポートのマッピングについては、上の図を参照してください。

エンドポイントは、VM の作成時、または構築後に開くことができます。 スクリプト例と以下のコード スニペットでは、VM の作成後にエンドポイントが開かれます。

`$VMName[$i]` など、`$` で始まる項目は、「参照」セクションのスクリプトからのユーザー定義変数であることに注意してください。 `[$i]` は、VM の配列における特定の VM の配列番号を表します。

```powershell
Add-AzureEndpoint -Name "HTTP" -Protocol tcp -PublicPort 80 -LocalPort 80 `
    -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | `
    Update-AzureVM
```

ここでは変数が示されているためわかりにくいですが、エンドポイントはセキュリティ クラウド サービスでのみ開いてください。 この予防措置は、ファイアウォールですべてのインバウンド トラフィックが必ず処理されるようにするのに役立ちます。ルーティングされるか、NAT によって再マッピングされるか、破棄されるかは関係ありません。

ファイアウォールを管理し、必要な構成を作成するには、PC 上に管理クライアントをインストールします。 ファイアウォールまたは他の NVA を管理する方法の詳細については、ベンダーのドキュメントを参照してください。 このセクションの残りの部分と、「**ファイアウォール規則の作成**」セクションでは、ファイアウォールの構成について説明します。 Azure ポータルや PowerShell ではなく、ベンダーの管理クライアントを使用します。

「[Barracuda NG Admin](https://techlib.barracuda.com/NG61/NGAdmin)」に移動して管理クライアントをダウンロードし、Barracuda ファイアウォールへの接続方法を学習します。

ファイアウォールにログインした後、ファイアウォール規則を作成する前に、ネットワークとサービス オブジェクトを定義します。 これら 2 つの前提条件となるオブジェクト クラスでは、ルールをより簡単に作成できます。

この例では、それぞれに次の 3 つの名前付きネットワーク オブジェクトを定義します。

* フロントエンド サブネット
* バックエンド サブネット
* DNS サーバーの IP アドレス

Barracuda NG Admin クライアント ダッシュボードから名前付きネットワークを作成するには、次のようにします。

1. **[構成] タブ**に移動します。
1. **[Operational Configuration]\(操作の構成\)** セクションで **[Ruleset]\(ルールセット\)** を選択します
1. **[Firewall Objects]\(ファイアウォール オブジェクト\)** メニューで **[ネットワーク]** を選択します。
1. **[ネットワークの編集]** メニューで **[新規]** を選択します。
1. 名前とプレフィックスを追加して、ネットワーク オブジェクトを作成します。

   ![フロントエンド ネットワーク オブジェクトを作成する][3]

上記の手順では、フロントエンド サブネットの名前付きネットワークを作成します。 バックエンド サブネットにも同様のオブジェクトを作成します。 これでサブネットが参照しやすくなりました。ファイアウォール ルール内から名前で参照することができます。

DNS サーバー オブジェクトの場合:

![DNS サーバー オブジェクトを作成する][4]

この単一の IP アドレス参照は、ドキュメントの後半の DNS ルールで使用されます。

その他のオブジェクト クラスには、サーバーごとの RDP 接続ポートを表す、サービス オブジェクトが含まれます。 既存の RDP サービス オブジェクトは、既定の RDP ポートである 3389 にバインドされます。 したがって、外部ポート (8014 から 8026) からのトラフィックを許可するために新しいサービスを作成できます。 既存の RDP サービスに新しいポートを追加することもできます。 しかし、デモをわかりやすくするため、サーバーごとに個々のルールを作成できます。 Barracuda NG Admin クライアント ダッシュボードからサーバーの新しい RDP ルールを作成するには、次のようにします。

1. **[構成] タブ**に移動します。
1. **[Operational Configuration]\(操作の構成\)** セクションで **[Ruleset]\(ルールセット\)** を選択します。
1. **[Firewall Objects]\(ファイアウォール オブジェクト\)** メニューで **[サービス]** を選択します。
1. サービス リストを下にスクロールして、**[RDP]** を選択します。
1. 右クリックして [コピー] を選択してから、右クリックして [貼り付け] を選択します。
1. これで、編集可能な RDP-Copy1 というサービス オブジェクトが作成されました。 **[RDP-Copy1]** を右クリックし、**[編集]** を選択します。
1. 以下のように、**[Edit Service Object]\(サービス オブジェクトの編集\)** ウィンドウがポップアップ表示されます。

   ![Copy of Default RDP Rule][5]

1. 特定のサーバーの RDP サービスを表すように値を編集します。 AppVM01 の場合、既定の RDP ルールを変更して、図 8 で使用されている新しいサービスの**名前**、**説明**、および外部 RDP ポートを反映する必要があります。 ポートは、RDP の既定値である 3389 から、この特定のサーバーの外部ポートに変更されることに注意してください。 たとえば、AppVM01 の外部ポートは 8025 となります。 変更されたサービス ルールを以下に示します。

   ![AppVM01 Rule][6]

残りのサーバー (AppVM02、DNS01、IIS01) の RDP サービスを作成するには、このプロセスを繰り返します。 これらのサービスを利用すれば、次のセクションのルールを作成しやすくなり、わかりやすくなります。

> [!NOTE]
> ファイアウォール VM が Linux ベースのイメージであるため、ファイアウォールの RDP サービスは必要ありません。したがって、VM 管理用のポート 22 では、RDP ではなく、SSH が使用されます。 また、ポート 22 と他の 2 つのポートが、管理接続用に許可されます。 次のセクションの「**ファイアウォール管理ルール**」を参照してください。

### <a name="firewall-rules-creation"></a>ファイアウォール規則の作成

この例には 3 種類のファイアウォール ルールが使われており、以下のように、すべて異なるアイコンで示されています。

アプリケーション リダイレクト ルール:![アプリケーション リダイレクト アイコン][7]

送信先 NAT ルール:![Destination NAT アイコン][8]

通過ルール:![Pass アイコン][9]

これらのルールの詳細については、Barracuda の Web サイトを参照してください。

以下のルールを作成するか、既存の既定のルールを確認するには、次のようにします。

1. Barracuda NG Admin クライアント ダッシュボードから、**[構成]** タブに移動します。
1. **[Operational Configuration]\(操作の構成\)** セクションで **[Ruleset]\(ルールセット\)** を選択します。
1. **[Main Rules]\(メイン ルール\)** グリッドには、このファイアウォールの既存のアクティブおよび非アクティブ ルールが表示されます。 新しいルールを作成するには、右上隅にある緑色の **[+]** を選択します。 変更のためにファイアウォールがロックされている場合、**[ロック]** とマークされたボタンが表示され、ルールを作成したり、編集したりすることはできません。 **[ロック]** ボタンを選択し、ルール セットのロックを解除して、編集を許可します。 編集するルールを右クリックし、**[ルールの編集]** を選択します。

ルールを作成または変更した後、ファイアウォールにプッシュしてアクティブ化します。 そうしないと、ルール変更は有効になりません。 プッシュとアクティブ化のプロセスについては、「[ルールのアクティブ化](#rule-activation)」で説明します。

この例を完了するために必要な各ルールの仕様を以下に示します。

* **ファイアウォール管理ルール**:このアプリ リダイレクト ルールでは、ネットワーク仮想アプライアンス (この例では Barracuda NextGen Firewall) の管理ポート宛てのトラフィックが通過できるようにします。 管理ポートは 801 と 807、および (必要に応じて) 22 です。 外部ポートと内部ポートは同じです (ポートの変換は使用しません)。 このルールを SETUP-MGMT-ACCESS といいます。 これは既定のルールであり、Barracuda NextGen Firewall バージョン 6.1 では既定で有効になります。
  
    ![ファイアウォール管理ルール][10]

  > [!TIP]
  > このルールのソース アドレス空間は **Any** です。 管理 IP アドレス範囲がわかっている場合、このスコープを減らすと、管理ポートへの攻撃面も減ります。

* **RDP ルール**:これらの送信先 NAT ルールでは、RDP 経由で個々のサーバーを管理できるようにします。 これらのルールの重要なフィールドは次のとおりです。
  * ソース。 任意の場所からの RDP を許可するには、[ソース] フィールドで参照 **[Any]** を使用します。
  * サービス。 先ほど作成した RDP サービス オブジェクトの **AppVM01 RDP** を使用します。 外部ポートでは、サーバーのローカル IP アドレスおよび既定の RDP ポート 3386 にリダイレクトします。 ここに示したルールは、AppVM01 への RDP アクセス用です。
  * 宛先。 ファイアウォールのローカル ポートには、**DCHP 1 ローカル IP** または **eth0** (静的 IP を使用している場合) を使用します。 ご使用のネットワーク アプライアンスが複数のローカル インターフェイスを備えている場合、序数 (eth0、eth1 など) は異なる場合があります。 ファイアウォールでは送信用にこのポートを使用します。これは受信ポートと同じである場合があります。 実際のルーティング先は、**[ターゲット リスト]** フィールドにあります。
  * リダイレクト。 このトラフィックの最終的なリダイレクト先を仮想アプライアンスに指示するように構成します。 最もシンプルなリダイレクトは、[ターゲット リスト] フィールドに IP を配置することです。 ポートを指定することもでき、NAT ではポートと IP アドレスの両方を再ルーティングします。 ポートを指定しない場合、仮想アプライアンスではインバウンド要求で宛先ポートが使用されます。

    ![Firewall RDP Rule][11]

    次の 4 つの RDP ルールを作成します。

    | 規則の名前 | サーバー | Service | ターゲット リスト |
    | --- | --- | --- | --- |
    | RDP-to-IIS01 |IIS01 |IIS01 RDP |10.0.1.4:3389 |
    | RDP-to-DNS01 |DNS01 |DNS01 RDP |10.0.2.4:3389 |
    | RDP-to-AppVM01 |AppVM01 |AppVM01 RDP |10.0.2.5:3389 |
    | RDP-to-AppVM02 |AppVM02 |AppVm02 RDP |10.0.2.6:3389 |

  > [!TIP]
  > [ソース] フィールドと [サービス] フィールドのスコープを狭くすると、攻撃面が小さくなります。 機能を許可する最も限定的なスコープを使用します。

* **アプリケーション トラフィック ルール**:2 つのアプリケーション トラフィック ルールがあります。 1 つはフロントエンド Web トラフィック用です。 もう 1 つでは、Web サーバーからデータ層などのバックエンド トラフィックが対象となります。 これらのルールは、ネットワーク アーキテクチャおよびトラフィック フローによって異なります。
  
  * Web トラフィック用のフロントエンド ルール:
  
    ![Firewall Web Rule][12]
  
    この宛先 NAT ルールでは、実際のアプリケーション トラフィックがアプリケーション サーバーに到達できるようにします。 セキュリティや管理などのルールとは異なり、アプリケーション ルールでは、外部のユーザーまたはサービスがアプリケーションにアクセスできるようにします。 この例ではポート 80 に単一の Web サーバーがあります。これにより、単一のファイアウォール アプリケーション ルールでは、外部 IP アドレス宛てのトラフィックをリダイレクトし、代わりに Web サーバーの内部 IP アドレスにルーティングできます。 リダイレクトされたトラフィック セッションは、NAT によって内部サーバーに再マッピングされます。

    > [!NOTE]
    > **[ターゲット リスト]** フィールドで割り当てられているポートはありません。 そのため、インバウンド ポート 80 (選択されたサービスでは 443) は、Web サーバーのリダイレクトに使用されます。 Web サーバーで 8080 などの異なるポートがリッスンされている場合、[ターゲット リスト] フィールドを 10.0.1.4:8080 に更新して、ポートのリダイレクトも行うことができます。
  
  * バックエンド ルールでは、**任意**のサービスを介した Web サーバーから AppVM01 サーバー (AppVM02 ではない) への通信を許可します。
  
    ![Firewall AppVM01 Rule][13]
  
    この通過ルールでは、フロントエンド サブネット上の IIS サーバーで任意のプロトコルを使用して任意のポートの AppVM01 (10.0.2.5) に到達し、Web アプリケーションでデータにアクセスできるようにします。
  
    このスクリーンショットでは、**[宛先]** フィールドに `<explicit-dest>` が使用され、宛先として 10.0.2.5 が示されています。 スクリーンショットに示すように、明示的に IP アドレスを指定できます。 DNS サーバーの前提条件と同様に、名前付きネットワーク オブジェクトを使用することもできます。 ファイアウォール管理者は、使用する方法を選択できます。 10.0.2.5 を明示的な宛先として追加するには、`<explicit-dest>` の下にある 1 つ目の空白行をダブルクリックし、開いたダイアログ ボックスにアドレスを入力します。
  
    この通過ルールでは、内部トラフィックが処理されるため、NAT は必要ありません。 **[接続方法]** を [`No SNAT`] に設定できます。
  
    > [!NOTE]
    > このルールのソース ネットワークはフロントエンド サブネットの任意のリソースです (1 つしかない場合)。 アーキテクチャが既知の数の Web サーバーを指定している場合は、ネットワーク オブジェクト リソースを作成し、フロントエンド サブネット全体ではなく、具体的に IP アドレスを指定することができます。

    > [!TIP]
    > サンプル アプリケーションをより簡単に設定して使用できるように、このルールではサービスとして **[Any]** を使用します。 これにより、単一ルールで ICMPv4 (ping) が許可されます。 しかし、この境界への攻撃面を減らすために、ポートとプロトコル サービスは、アプリケーションを操作できる可能な限り小さい値に制限することをお勧めします。

    > [!TIP]
    > このルール例では `<explicit-dest>` 参照を使用しますが、ファイアウォール構成全体で一貫した方法を使用する必要があります。 可読性と保守性の点から、名前付きネットワーク オブジェクトの使用をお勧めします。 ここで示す `<explicit-dest>` は、単に代替参照方法を示すためのものです。 通常、これは、特に複雑な構成ではお勧めできません。

* **インターネットへのアウトバウンド規則**:この通過ルールでは、任意のソース ネットワークから選択された宛先ネットワークへのトラフィックの通過を許可します。 Barracuda NextGen Firewall では、通常、既定でこのルールが "オン" になりますが、無効状態の場合です。 このルールを右クリックして、**Activate Rule** コマンドにアクセスします。 スクリーンショットに示されているルールを変更し、バックエンドとフロントエンドのサブネットのネットワーク オブジェクトを、このルールのソース属性に追加します。 この記事の前提条件セクションで、これらのネットワーク オブジェクトを作成しました。
  
    ![Firewall Outbound Rule][14]

* **DNS ルール**:この通過ルールでは、DNS サーバーへの DNS (ポート 53) のトラフィックのみの通過を許可します。 この環境では、フロントエンドからバックエンドへのトラフィックは大部分がブロックされるため、このルールによって DNS トラフィックが明示的に許可されます。
  
    ![Firewall DNS Rule][15]
  
    > [!NOTE]
    > このルールは内部 IP アドレス間のトラフィックを対象としており、NAT 経由の再ルーティングは不要であるため、**[接続方法]** は [`No SNAT`] に設定されています。

* **サブネット間ルール**:この既定の通過ルールは有効になっており、バックエンド サブネット上の任意のサーバーから、フロントエンド サブネット上の任意のサーバーへの接続を許可するように変更が加えられています。 このルールの対象は内部トラフィックのみであるため、**[接続方法]** は [`No SNAT`] に設定できます。

    ![Firewall Intra-VNet Rule][16]
  
    > [!NOTE]
    > **[双方向]** チェック ボックスがここではオンになっていないため、このルールは一方向のみで適用されます。 バックエンド サブネットからフロントエンド ネットワークへの接続は開始できますが、その逆の接続は開始できません。 そのチェック ボックスがオンになっていた場合、このルールによって、双方向トラフィックが有効になります。これは、論理図では望ましくないものとして示されています。

* **全トラフィック拒否ルール**:優先度の観点から、これは常に最後のルールにする必要があります。 トラフィック フローが上記のいずれのルールとも一致しない場合、このルールによって破棄されます。 通常、ルールは既定でアクティブ化されているため、変更は必要ありません。
  
    ![Firewall Deny Rule][17]

> [!IMPORTANT]
> 上記のルールがすべて作成された後、各ルールの優先度を確認し、トラフィックの許可または拒否が意図したとおりになっていることを確かめてください。 この例では、Barracuda 管理クライアントのメイン グリッドの転送ルールで表示される順序でルールがリストされています。

## <a name="rule-activation"></a>ルールのアクティブ化

論理図の仕様を満たすためにルール セットを変更した後、ルール セットをファイアウォールにアップロードしてアクティブ化する必要があります。

![Firewall Rule Activation][18]

管理クライアント ウィンドウの右上隅を確認し、**[Send Changes]\(変更の送信\)** を選択して、変更されたルールをファイアウォールにアップロードします。 **[アクティブ化]** を選択します。

ファイアウォール規則セットをアクティブ化したら、この例の環境は完了です。

## <a name="traffic-scenarios"></a>トラフィックのシナリオ

> [!IMPORTANT]
> *すべて*のトラフィックがファイアウォールを経由することに注意してください。 IIS01 サーバーにリモート デスクトップ接続するには、ポート 8014 上のファイアウォールに接続してから、ファイアウォールで IIS01 RDP ポートに内部的に RDP 要求をルーティングできるようにします。 Azure ポータルの **[接続]** ボタンは機能しません。これは、RDP で直接 IIS01 に到達する経路が、ポータルから見える範囲では存在しないためです。 インターネットからのすべての接続は、セキュリティ サービスとポート (secscv001.cloudapp.net:xxxx など) に対するものです。 外部ポートおよび内部 IP とポートのマッピングについては、上の図を参照してください。

以下のシナリオでは、次のファイアウォール ルールが設定されている必要があります。

1. ファイアウォール管理 (FW Mgmt)
2. IIS01 への RDP
3. DNS01 への RDP
4. AppVM01 への RDP
5. AppVM02 への RDP
6. Web へのアプリ トラフィック
7. AppVM01 へのアプリ トラフィック
8. インターネットへのアウトバウンド
9. フロントエンドから DNS01
10. サブネット間トラフィック (バックエンドからフロント エンドのみ)
11. すべて拒否

実際のファイアウォール規則セットではほとんどの場合、この例のルールより多くのルールが必要になります。 異なる優先順位番号が使用される場合もあります。 互いに相対的な優先順位について、このリストと関連する番号を参照する必要があります。 たとえば、"IIS01 への RDP" ルールは実際のファイアウォールでは番号が 5 である場合がありますが、それが "ファイアウォール管理" ルールよりも下でかつ "DNS01 への RDP" ルールよりも上であれば、セットはこのリストの意図と一致します。 このリストは、以降のシナリオの手順を簡略化するのにも役立ちます。 たとえば、"ファイアウォール ルール 9 (DNS)" です。 トラフィック シナリオが RDP とは無関係である場合、4 つの RDP ルールを総称して "RDP ルール" と表記していることに注意してください。

また、ネットワーク セキュリティ グループ (NSG) の適用先は、フロントエンド サブネットとバックエンド サブネットのインバウンド インターネット トラフィックであることを思い出してください。

### <a name="allowed-internet-to-web-server"></a>(許可) インターネットから Web サーバー

1. インターネット ユーザーが、SecSvc001.CloudApp.Net (インターネットに接続されたクラウド サービス) にある HTTP ページを要求します。
1. クラウド サービスでは、ポート 80 上の開いているエンドポイントを介して、10.0.0.4:80 のファイアウォール インターフェイスにトラフィックを渡します。
1. セキュリティ サブネットに NSG は割り当てられていないため、システムの NSG ルールによってファイアウォールへのトラフィックが許可されます。
1. トラフィックはファイアウォールの内部 IP アドレス (10.0.1.4) に到達します。
1. ファイアウォールではルールの処理を行います。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 (アプリ:Web) が適用されます。 トラフィックは許可されます。 ファイアウォールでは、10.0.1.4 (IIS01) に NAT 経由でトラフィックを再ルーティングします。
1. フロントエンド サブネットでは、インバウンド ルールの処理を行います。
   1. NSG ルール 1 (インターネットをブロック) は適用されません。 ファイアウォールでこのトラフィックが NAT 経由で再ルーティングされたため、ソース アドレスは現在、ファイアウォールです。 ファイアウォールはセキュリティ サブネット上にあり、フロントエンド サブネットの NSG へのローカル トラフィックとして表示されるため、トラフィックは許可されます。 次のルールに進みます。
   1. 既定の NSG ルールではサブネット間トラフィックが許可されるため、このトラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. IIS01 では Web トラフィックをリッスンします。 この要求を受信し、要求の処理を開始します。
1. IIS01 で、バックエンド サブネットにある AppVM01 への FTP セッションの開始を試みます。
1. フロントエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
1. フロントエンド サブネットにアウトバウンド規則はないので、トラフィックは許可されます。
1. ファイアウォール ルールの処理が開始されます。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 (アプリ:Web) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 7 (アプリ: バックエンド) が適用されます。 トラフィックは許可されます。 ファイアウォールで 10.0.2.5 (AppVM01) にトラフィックが転送されます。
1. バックエンド サブネットでは、インバウンド規則の処理を行います。
    1. NSG ルール 1 (インターネットをブロック) は適用されません。 次のルールに進みます。
    1. 既定の NSG ルールではサブネット間トラフィックが許可されます。 トラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. AppVM01 で要求を受信し、セッションを開始して応答します。
1. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
1. バックエンド サブネットにアウトバウンド NSG ルールは存在しないので、応答は許可されます。
1. これは、確立済みのセッション上の戻りトラフィックであるため、ファイアウォールでは Web サーバー (IIS01) に応答を戻します。
1. フロントエンド サブネットでは、インバウンド規則の処理を行います。
    1. NSG ルール 1 (インターネットをブロック) は適用されません。 次のルールに進みます。
    1. 既定の NSG ルールではサブネット間トラフィックが許可されるため、このトラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. IIS サーバーで応答を受信し、AppVM01 とのトランザクションを完了します。 その後、サーバーで HTTP 応答の構築を完了し、要求元に送信します。
1. フロントエンド サブネットにアウトバウンド NSG ルールは存在しないので、応答は許可されます。
1. HTTP 応答がファイアウォールに到達します。 これは確立済みの NAT セッションへの応答であるため、ファイアウォールでこれを受け入れます。
1. ファイアウォールで応答をリダイレクトしてインターネット ユーザーに返します。
1. フロントエンド サブネットにアウトバウンド NSG ルールや UDR ホップは存在しないので、応答は許可されます。 インターネット ユーザーは要求された Web ページを受信します。

### <a name="allowed-internet-rdp-to-back-end"></a>(許可) インターネットからバックエンドへの RDP

1. インターネット上のサーバー管理者は、SecSvc001.CloudApp.Net:8025 経由で AppVM01 への RDP セッションを要求します。 8025 は、ファイアウォール規則 4 (RDP AppVM01) でユーザーが割り当てたポート番号です。
1. クラウド サービスでは、ポート 8025 上の開いているエンドポイントを介して、10.0.0.4:8025 のファイアウォール インターフェイスにトラフィックを渡します。
1. セキュリティ サブネットに NSG は割り当てられていないため、システムの NSG ルールによってファイアウォールへのトラフィックが許可されます。
1. ファイアウォールではルールの処理を行います。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 (RDP IIS) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 3 (RDP DNS01) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 4 (RDP AppVM01) が適用されるため、トラフィックは許可されます。 ファイアウォールでは、それを NAT 経由で 10.0.2.5:3386 (AppVM01 の RDP ポート) に再ルーティングします。
1. バックエンド サブネットでは、インバウンド規則の処理を行います。
   1. NSG ルール 1 (インターネットをブロック) は適用されません。 ファイアウォールでこのトラフィックが NAT 経由で再ルーティングされたため、ソース アドレスは現在、セキュリティ サブネット上にあるファイアウォールです。 これは、バックエンド サブネットの NSG によってローカル トラフィックと見なされ、許可されます。 次のルールに進みます。
   1. 既定の NSG ルールではサブネット間トラフィックが許可されるため、このトラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. AppVM01 が RDP トラフィックをリッスンして応答します。
1. アウトバウンド NSG ルールはないため、既定のルールが適用されます。 戻りトラフィックは許可されます。
1. UDR では、アウトバウンド トラフィックを次ホップであるファイアウォールにルーティングします。
1. これは、確立済みのセッション上の戻りトラフィックであるため、ファイアウォールではインターネット ユーザーに応答を戻します。
1. RDP セッションが有効になります。
1. AppVM01 でユーザー名とパスワードを求めるメッセージが表示されます。

### <a name="allowed-web-server-dns-lookup-on-dns-server"></a>(許可) DNS サーバーに対する Web サーバーの DNS 参照

1. Web サーバー IIS01 で http\:\/\/www.data.gov にあるデータ フィードを要求していますが、アドレスを解決する必要があります。
1. 仮想ネットワーク用のネットワーク構成では、プライマリ DNS サーバーとして DNS01 (バックエンド サブネット上の 10.0.2.4) がリストされています。 IIS01 は DNS 要求を DNS01 に送信します。
1. UDR では、アウトバウンド トラフィックを次ホップであるファイアウォールにルーティングします。
1. フロントエンド サブネットにアウトバウンド NSG ルールはバインドされません。 トラフィックは許可されます。
1. ファイアウォールでルールの処理を行います。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 と 7 (アプリ ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 8 (インターネットへの) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 9 (DNS) は適用されます。 トラフィックは許可されます。 ファイアウォールで 10.0.2.4 (DNS01) にトラフィックが転送されます。
1. バックエンド サブネットでは、インバウンド規則の処理を行います。
   1. NSG ルール 1 (インターネットをブロック) は適用されません。 次のルールに進みます。
   1. 既定の NSG ルールではサブネット間トラフィックが許可されます。 トラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. DNS サーバーが要求を受信します。
1. DNS サーバーではアドレスがキャッシュされておらず、インターネット上のルート DNS サーバーに要求します。
1. UDR ではアウトバウンド トラフィックを、次ホップであるファイアウォールにルーティングします。
1. バックエンド サブネットにアウトバウンド NSG ルールはないので、トラフィックは許可されます。
1. ファイアウォールでルールの処理を行います。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 と 7 (アプリ ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 8 (インターネットへの) は適用されます。 トラフィックは許可されます。 セッションは SNAT 経由で、インターネット上のルート DNS サーバーに再ルーティングされます。
1. インターネット DNS サーバーが応答します。 このセッションはファイアウォールから開始されたため、ファイアウォールで応答が受け入れられます。
1. このセッションは既に確立されているため、ファイアウォールで開始元のサーバーである DNS01 に応答が転送されます。
1. バックエンド サブネットでは、インバウンド規則の処理を行います。
    1. NSG ルール 1 (インターネットをブロック) は適用されません。 次のルールに進みます。
    1. 既定の NSG ルールではサブネット間トラフィックが許可されるため、このトラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. DNS サーバーで応答を受信し、キャッシュしてから、最初の要求に応答して IIS01 に戻します。
1. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
1. バックエンド サブネットにアウトバウンド NSG ルールは存在しないので、トラフィックは許可されます。
1. このセッションはファイアウォール上で既に確立されているため、ファイアウォールで応答が再ルーティングされ、IIS サーバーに戻されます。
1. フロントエンド サブネットでは、インバウンド ルールの処理を行います。
    1. バックエンド サブネットからフロントエンド サブネットへのインバウンド トラフィックの NSG ルールはないため、どの NSG ルールも適用されません。
    1. 既定のシステム ルールでは、サブネット間トラフィックが許可されます。 トラフィックは許可されます。
1. IIS01 が DNS01 から応答を受信します。

### <a name="allowed-back-end-server-to-front-end-server"></a>(許可) バックエンド サーバーからフロントエンド サーバー

1. RDP 経由で AppVM02 にログオンしている管理者は、Windows エクスプローラーで IIS01 サーバーから直接ファイルを要求します。
1. バックエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
1. バックエンド サブネットにアウトバウンド NSG ルールは存在しないので、応答は許可されます。
1. ファイアウォールではルールの処理を行います。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 と 7 (アプリ ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 8 (インターネットへの) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 9 (DNS) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 10 (サブネット間) が適用されます。 トラフィックは許可されます。 ファイアウォールで 10.0.1.4 (IIS01) にトラフィックが渡されます。
1. フロントエンド サブネットで、以下に示すインバウンド規則の処理が開始されます。
   1. NSG ルール 1 (インターネットをブロック) は適用されません。次のルールに進みます
   1. 既定の NSG ルールではサブネット間トラフィックが許可されるため、トラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. 適切な認証および承認であると仮定し、IIS01 で要求を受け入れて応答します。
1. フロントエンド サブネット上の UDR ルートによって、ファイアウォールが次ホップに設定されます。
1. フロントエンド サブネットにアウトバウンド NSG ルールはないため、応答は許可されます。
1. このセッションは既にファイアウォール上に存在するため、この応答は許可されます。 ファイアウォールで AppVM02 に応答が返されます。
1. バックエンド サブネットでは、インバウンド規則の処理を行います。
    1. NSG ルール 1 (インターネットをブロック) は適用されません。 次のルールに進みます。
    2. 既定の NSG ルールではサブネット間トラフィックが許可されるため、トラフィックは許可されます。 NSG ルールの処理はここで終了します。
1. AppVM02 で応答が受信されます。

### <a name="denied-internet-direct-to-web-server"></a>(拒否) Web サーバーへの直接インターネット アクセス

1. インターネット ユーザーが、FrontEnd001.CloudApp.Net サービスを介して IIS01 Web サーバーへのアクセスを試みます。
1. HTTP トラフィック用に開かれたエンドポイントはないため、このトラフィックはクラウドサービスを通過しません。 トラフィックはサーバーに到達しません。
1. 何らかの理由でエンドポイントが開かれている場合、フロントエンド サブネットの NSG (インターネットをブロック) によって、このトラフィックはブロックされます。
1. 最後に、フロントエンド サブネットの UDR ルートで、IIS01 からのアウトバウンド トラフィックはすべて、次ホップであるファイアウォールに送信されます。 ファイアウォールではそれが非対称トラフィックと見なされ、アウトバウンド応答は破棄されます。

>そのため、インターネットと IIS01 間には、少なくとも 3 つの独立した防御層があります。 クラウド サービスで、未承認アクセスや不適切なアクセスを防ぎます。

### <a name="denied-internet-to-back-end-server"></a>(拒否) インターネットからバックエンド サーバー

1. インターネット ユーザーが、BackEnd001.CloudApp.Net サービスを介して AppVM01 上のファイルにアクセスを試みます。
2. ファイル共有のために開かれたエンドポイントはないため、この要求でクラウド サービスは渡されません。 トラフィックはサーバーに到達しません。
3. 何らかの理由でエンドポイントが開かれている場合、NSG (インターネットをブロック) でこのトラフィックはブロックされます。
4. 最後に、UDR ルートで、AppVM01 からのアウトバウンド トラフィックはすべて、次ホップであるファイアウォールに送信されます。 ファイアウォールではそれが非対称トラフィックと見なされ、アウトバウンド応答は破棄されます。

> そのため、インターネットと AppVM01 間には、少なくとも 3 つの独立した防御層があります。 クラウド サービスで、未承認アクセスや不適切なアクセスを防ぎます。

### <a name="denied-front-end-server-to-back-end-server"></a>(拒否) フロントエンド サーバーからバックエンド サーバー

1. IIS01 のセキュリティが侵害され、バックエンド サブネット サーバーをスキャンしようとする悪質なコードが実行されています。
1. フロントエンド サブネットの UDR ルートで、IIS01 からのアウトバウンド トラフィックはすべて、次ホップであるファイアウォールに送信されます。 侵害された VM でこのルーティングを変更することはできません。
1. ファイアウォールでトラフィックが処理されます。 要求が AppVM01、または DNS ルックアップ用の DNS サーバーに対するものである場合、ファイアウォールでトラフィックが許可される可能性があります。これは、ファイアウォール規則 7 と 9 によるものです。 他のすべてのトラフィックは、ファイアウォール規則 11 (すべて拒否) によってブロックされます。
1. ファイアウォールで高度な脅威検出を有効にすると、高度な脅威ルールにフラグを付ける既知のシグネチャまたはパターンを含むトラフィックを防ぐことができます。 この記事で説明されている基本的な転送ルールに従って、トラフィックが許可されている場合でも、この方法を使用できます。 高度な脅威検出については、このドキュメントでは説明しません。 特定のネットワーク アプライアンスの高度な脅威機能については、ベンダーのドキュメントを参照してください。

### <a name="denied-internet-dns-lookup-on-dns-server"></a>(拒否) インターネットから DNS サーバーへの DNS 参照

1. インターネット ユーザーが、BackEnd001.CloudApp.Net サービスを介して、DNS01 上の内部 DNS レコードを参照しようとしています。
1. DNS トラフィック用に開かれたエンドポイントはないため、このトラフィックはクラウドサービスを通過しません。 サーバーには到達しません。
1. 何らかの理由でエンドポイントが開かれている場合、フロントエンド サブネットの NSG ルール (インターネットをブロック) によって、このトラフィックはブロックされます。
1. 最後に、バックエンド サブネットの UDR ルートで、DNS01 からのアウトバウンド トラフィックはすべて、次ホップであるファイアウォールに送信されます。 ファイアウォールではこれが非対称トラフィックと見なされ、アウトバウンド応答は破棄されます。

> そのため、インターネットと DNS01 間には、少なくとも 3 つの独立した防御層があります。 クラウド サービスで、未承認アクセスや不適切なアクセスを防ぎます。

#### <a name="denied-internet-to-sql-access-through-firewall"></a>(拒否) インターネットからファイアウォールを経由して SQL にアクセス

1. インターネット ユーザーが、SecSvc001.CloudApp.Net というインターネットに接続されたクラウド サービスにある SQL データを要求します。
1. SQL 用に開かれたエンドポイントはないため、このトラフィックはクラウド サービスを通過しません。 ファイアウォールには到達しません。
1. 何らかの理由で SQL エンドポイントが開かれている場合、ファイアウォールでルールの処理が行われます。
   1. ファイアウォール規則 1 (FW Mgmt) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 2 から 5 (RDP ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 6 と 7 (アプリケーション ルール) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 8 (インターネットへの) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 9 (DNS) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 10 (サブネット間) は適用されません。 次のルールに進みます。
   1. ファイアウォール規則 11 (すべて拒否) が適用されます。 トラフィックはブロックされます。 ルールの処理はここで終了します。

## <a name="references"></a>参照

このセクションには以下の項目が含まれます。

* 完全なスクリプト。 PowerShell スクリプト ファイルに保存します。
* ネットワーク構成。NetworkConf2.xml という名前のファイルに保存します。

必要に応じて、ファイル内のユーザー定義変数を変更します。 スクリプトを実行してから、この記事の前半でリストされているファイアウォール規則の設定手順に従ってください。

### <a name="full-script"></a>完全なスクリプト

ユーザー定義変数を設定した後、このスクリプトを実行して以下のことを行います。

1. Azure サブスクリプションに接続する
1. 新しいストレージ アカウントの作成
1. ネットワーク構成ファイルの定義に従って、新しい仮想ネットワークを 1 つと、サブネットを 3 つ作成する
1. 仮想マシンを 5 つ構築する: ファイアウォール用に 1 つと Windows Server VM 用に 4 つ
1. UDR を構成する:
   1. 新しいルート テーブルを 2 つ作成する
   1. テーブルにルートを追加
   1. 適切なサブネットにテーブルをバインド
1. ネットワーク仮想アプライアンスで IP 転送を有効にする
1. NSG を構成する:
   1. NSG を作成する
   1. 規則を追加する
   1. 適切なサブネットに NSG をバインドする

この PowerShell スクリプトを、インターネットに接続されている PC またはサーバー上でローカルに実行します。

> [!IMPORTANT]
> このスクリプトを実行すると、PowerShell に警告またはその他の情報メッセージがポップアップ表示される場合があります。 赤色のエラー メッセージのみが問題の原因となります。

```powershell
    <#
     .SYNOPSIS
      Example of DMZ and User Defined Routing in an isolated network (Azure only, no hybrid connections)

     .DESCRIPTION
      This script will build out a sample DMZ setup containing:
       - A default storage account for VM disks
       - Three new cloud services
       - Three Subnets (SecNet, FrontEnd, and BackEnd subnets)
       - A Network Virtual Appliance (NVA), in this case a Barracuda NextGen Firewall
       - One server on the FrontEnd Subnet
       - Three Servers on the BackEnd Subnet
       - IP Forwarding from the FireWall out to the internet
       - User Defined Routing FrontEnd and BackEnd Subnets to the NVA

      Before running script, ensure the network configuration file is created in
      the directory referenced by $NetworkConfigFile variable (or update the
      variable to reflect the path and file name of the config file being used).

     .Notes
      Everyone's security requirements are different and can be addressed in a myriad of ways.
      Please be sure that any sensitive data or applications are behind the appropriate
      layer(s) of protection. This script serves as an example of some of the techniques
      that can be used, but should not be used for all scenarios. You are responsible to
      assess your security needs and the appropriate protections needed, and then effectively
      implement those protections.

      Security Service (SecNet subnet 10.0.0.0/24)
       myFirewall - 10.0.0.4

      FrontEnd Service (FrontEnd subnet 10.0.1.0/24)
       IIS01      - 10.0.1.4

      BackEnd Service (BackEnd subnet 10.0.2.0/24)
       DNS01      - 10.0.2.4
       AppVM01    - 10.0.2.5
       AppVM02    - 10.0.2.6

    #>

    # Fixed Variables
        $LocalAdminPwd = Read-Host -Prompt "Enter Local Admin Password to be used for all VMs"
        $VMName = @()
        $ServiceName = @()
        $VMFamily = @()
        $img = @()
        $size = @()
        $SubnetName = @()
        $VMIP = @()

    # User Defined Global Variables
      # These should be changes to reflect your subscription and services
      # Invalid options will fail in the validation section

      # Subscription Access Details
        $subID = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

      # VM Account, Location, and Storage Details
        $LocalAdmin = "theAdmin"
        $DeploymentLocation = "Central US"
        $StorageAccountName = "vmstore02"

      # Service Details
        $SecureService = "SecSvc001"
        $FrontEndService = "FrontEnd001"
        $BackEndService = "BackEnd001"

      # Network Details
        $VNetName = "CorpNetwork"
        $VNetPrefix = "10.0.0.0/16"
        $SecNet = "SecNet"
        $FESubnet = "FrontEnd"
        $FEPrefix = "10.0.1.0/24"
        $BESubnet = "BackEnd"
        $BEPrefix = "10.0.2.0/24"
        $NetworkConfigFile = "C:\Scripts\NetworkConf3.xml"

      # VM Base Disk Image Details
        $SrvImg = Get-AzureVMImage | Where {$_.ImageFamily -match 'Windows Server 2012 R2 Datacenter'} | sort PublishedDate -Descending | Select ImageName -First 1 | ForEach {$_.ImageName}
        $FWImg = Get-AzureVMImage | Where {$_.ImageFamily -match 'Barracuda NextGen Firewall'} | sort PublishedDate -Descending | Select ImageName -First 1 | ForEach {$_.ImageName}

      # UDR Details
        $FERouteTableName = "FrontEndSubnetRouteTable"
        $BERouteTableName = "BackEndSubnetRouteTable"

      # NSG Details
        $NSGName = "MyVNetSG"

    # User Defined VM Specific Config
        # Note: To ensure UDR and IP forwarding is setup
        # properly this script requires VM 0 be the NVA.

        # VM 0 - The Network Virtual Appliance (NVA)
          $VMName += "myFirewall"
          $ServiceName += $SecureService
          $VMFamily += "Firewall"
          $img += $FWImg
          $size += "Small"
          $SubnetName += $SecNet
          $VMIP += "10.0.0.4"

        # VM 1 - The Web Server
          $VMName += "IIS01"
          $ServiceName += $FrontEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $FESubnet
          $VMIP += "10.0.1.4"

        # VM 2 - The First Application Server
          $VMName += "AppVM01"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.5"

        # VM 3 - The Second Application Server
          $VMName += "AppVM02"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.6"

        # VM 4 - The DNS Server
          $VMName += "DNS01"
          $ServiceName += $BackEndService
          $VMFamily += "Windows"
          $img += $SrvImg
          $size += "Standard_D3"
          $SubnetName += $BESubnet
          $VMIP += "10.0.2.4"

    # ----------------------------- #
    # No User Defined Variables or   #
    # Configuration past this point #
    # ----------------------------- #

      # Get your Azure accounts
        Add-AzureAccount
        Set-AzureSubscription –SubscriptionId $subID -ErrorAction Stop
        Select-AzureSubscription -SubscriptionId $subID -Current -ErrorAction Stop

      # Create Storage Account
        If (Test-AzureName -Storage -Name $StorageAccountName) {
            Write-Host "Fatal Error: This storage account name is already in use, please pick a different name." -ForegroundColor Red
            Return}
        Else {Write-Host "Creating Storage Account" -ForegroundColor Cyan
              New-AzureStorageAccount -Location $DeploymentLocation -StorageAccountName $StorageAccountName}

      # Update Subscription Pointer to New Storage Account
        Write-Host "Updating Subscription Pointer to New Storage Account" -ForegroundColor Cyan 
        Set-AzureSubscription –SubscriptionId $subID -CurrentStorageAccountName $StorageAccountName -ErrorAction Stop

    # Validation
    $FatalError = $false

    If (-Not (Get-AzureLocation | Where {$_.DisplayName -eq $DeploymentLocation})) {
         Write-Host "This Azure Location was not found or available for use" -ForegroundColor Yellow
         $FatalError = $true}

    If (Test-AzureName -Service -Name $SecureService) { 
        Write-Host "The SecureService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The FrontEndService service name is valid for use." -ForegroundColor Green}

    If (Test-AzureName -Service -Name $FrontEndService) { 
        Write-Host "The FrontEndService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The FrontEndService service name is valid for use" -ForegroundColor Green}

    If (Test-AzureName -Service -Name $BackEndService) { 
        Write-Host "The BackEndService service name is already in use, please pick a different service name." -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The BackEndService service name is valid for use." -ForegroundColor Green}

    If (-Not (Test-Path $NetworkConfigFile)) { 
        Write-Host 'The network config file was not found, please update the $NetworkConfigFile variable to point to the network config xml file.' -ForegroundColor Yellow
        $FatalError = $true}
    Else { Write-Host "The network config file was found" -ForegroundColor Green
            If (-Not (Select-String -Pattern $DeploymentLocation -Path $NetworkConfigFile)) {
                Write-Host 'The deployment location was not found in the network config file, please check the network config file to ensure the $DeploymentLocation variable is correct and the network config file matches.' -ForegroundColor Yellow
                $FatalError = $true}
            Else { Write-Host "The deployment location was found in the network config file." -ForegroundColor Green}}

    If ($FatalError) {
        Write-Host "A fatal error has occurred, please see the above messages for more information." -ForegroundColor Red
        Return}
    Else { Write-Host "Validation passed, now building the environment." -ForegroundColor Green}

    # Create VNET
        Write-Host "Creating VNET" -ForegroundColor Cyan 
        Set-AzureVNetConfig -ConfigurationPath $NetworkConfigFile -ErrorAction Stop

    # Create Services
        Write-Host "Creating Services" -ForegroundColor Cyan
        New-AzureService -Location $DeploymentLocation -ServiceName $SecureService -ErrorAction Stop
        New-AzureService -Location $DeploymentLocation -ServiceName $FrontEndService -ErrorAction Stop
        New-AzureService -Location $DeploymentLocation -ServiceName $BackEndService -ErrorAction Stop

    # Build VMs
        $i=0
        $VMName | Foreach {
            Write-Host "Building $($VMName[$i])" -ForegroundColor Cyan
            If ($VMFamily[$i] -eq "Firewall") 
                { 
                New-AzureVMConfig -Name $VMName[$i] -ImageName $img[$i] –InstanceSize $size[$i] | `
                    Add-AzureProvisioningConfig -Linux -LinuxUser $LocalAdmin -Password $LocalAdminPwd  | `
                    Set-AzureSubnet  –SubnetNames $SubnetName[$i] | `
                    Set-AzureStaticVNetIP -IPAddress $VMIP[$i] | `
                    New-AzureVM –ServiceName $ServiceName[$i] -VNetName $VNetName -Location $DeploymentLocation
                # Set up all the EndPoints we'll need once we're up and running
                # Note: All traffic goes through the firewall, so we'll need to set up all ports here.
                #       Also, the firewall will be redirecting traffic to a new IP and Port in a forwarding
                #       rule, so all of these endpoint have the same public and local port and the firewall
                #       will do the mapping, NATing, and/or redirection as declared in the firewall rules.
                Add-AzureEndpoint -Name "MgmtPort1" -Protocol tcp -PublicPort 801  -LocalPort 801  -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "MgmtPort2" -Protocol tcp -PublicPort 807  -LocalPort 807  -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "HTTP"      -Protocol tcp -PublicPort 80   -LocalPort 80   -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPWeb"    -Protocol tcp -PublicPort 8014 -LocalPort 8014 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPApp1"   -Protocol tcp -PublicPort 8025 -LocalPort 8025 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPApp2"   -Protocol tcp -PublicPort 8026 -LocalPort 8026 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                Add-AzureEndpoint -Name "RDPDNS01"  -Protocol tcp -PublicPort 8024 -LocalPort 8024 -VM (Get-AzureVM -ServiceName $ServiceName[$i] -Name $VMName[$i]) | Update-AzureVM
                # Note: A SSH endpoint is automatically created on port 22 when the appliance is created.
                }
            Else
                {
                New-AzureVMConfig -Name $VMName[$i] -ImageName $img[$i] –InstanceSize $size[$i] | `
                    Add-AzureProvisioningConfig -Windows -AdminUsername $LocalAdmin -Password $LocalAdminPwd  | `
                    Set-AzureSubnet  –SubnetNames $SubnetName[$i] | `
                    Set-AzureStaticVNetIP -IPAddress $VMIP[$i] | `
                    Set-AzureVMMicrosoftAntimalwareExtension -AntimalwareConfiguration '{"AntimalwareEnabled" : true}' | `
                    Remove-AzureEndpoint -Name "RemoteDesktop" | `
                    Remove-AzureEndpoint -Name "PowerShell" | `
                    New-AzureVM –ServiceName $ServiceName[$i] -VNetName $VNetName -Location $DeploymentLocation
                }
            $i++
        }

    # Configure UDR and IP Forwarding
        Write-Host "Configuring UDR" -ForegroundColor Cyan

      # Create the Route Tables
        Write-Host "Creating the Route Tables" -ForegroundColor Cyan 
        New-AzureRouteTable -Name $BERouteTableName `
            -Location $DeploymentLocation `
            -Label "Route table for $BESubnet subnet"
        New-AzureRouteTable -Name $FERouteTableName `
            -Location $DeploymentLocation `
            -Label "Route table for $FESubnet subnet"

      # Add Routes to Route Tables
        Write-Host "Adding Routes to the Route Tables" -ForegroundColor Cyan 
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $BERouteTableName `
            |Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $BEPrefix `
            -NextHopType VNETLocal
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "All traffic to FW" -AddressPrefix 0.0.0.0/0 `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "Internal traffic to FW" -AddressPrefix $VNetPrefix `
            -NextHopType VirtualAppliance `
            -NextHopIpAddress $VMIP[0]
        Get-AzureRouteTable $FERouteTableName `
            |Set-AzureRoute -RouteName "Allow Intra-Subnet Traffic" -AddressPrefix $FEPrefix `
            -NextHopType VNETLocal

      # Associate the Route Tables with the Subnets
        Write-Host "Binding Route Tables to the Subnets" -ForegroundColor Cyan 
        Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
            -SubnetName $BESubnet `
            -RouteTableName $BERouteTableName
        Set-AzureSubnetRouteTable -VirtualNetworkName $VNetName `
            -SubnetName $FESubnet `
            -RouteTableName $FERouteTableName

     # Enable IP Forwarding on the Virtual Appliance
        Get-AzureVM -Name $VMName[0] -ServiceName $ServiceName[0] `
            |Set-AzureIPForwarding -Enable

    # Configure NSG
        Write-Host "Configuring the Network Security Group (NSG)" -ForegroundColor Cyan

      # Build the NSG
        Write-Host "Building the NSG" -ForegroundColor Cyan
        New-AzureNetworkSecurityGroup -Name $NSGName -Location $DeploymentLocation -Label "Security group for $VNetName subnets in $DeploymentLocation"

      # Add NSG Rule
        Write-Host "Writing rules into the NSG" -ForegroundColor Cyan
        Get-AzureNetworkSecurityGroup -Name $NSGName | Set-AzureNetworkSecurityRule -Name "Isolate the $VNetName VNet from the Internet" -Type Inbound -Priority 100 -Action Deny `
            -SourceAddressPrefix INTERNET -SourcePortRange '*' `
            -DestinationAddressPrefix VIRTUAL_NETWORK -DestinationPortRange '*' `
            -Protocol *

      # Assign the NSG to two Subnets
        # The NSG is *not* bound to the Security Subnet. The result
        # is that internet traffic flows only to the Security subnet
        # since the NSG bound to the FrontEnd and BackEnd subnets
        # will Deny internet traffic to those subnets.
        Write-Host "Binding the NSG to two subnets" -ForegroundColor Cyan
        Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName -SubnetName $FESubnet -VirtualNetworkName $VNetName
        Set-AzureNetworkSecurityGroupToSubnet -Name $NSGName -SubnetName $BESubnet -VirtualNetworkName $VNetName

    # Optional Post-script Manual Configuration
      # Configure Firewall
      # Install Test Web App (Run Post-Build Script on the IIS Server)
      # Install BackEnd resource (Run Post-Build Script on the AppVM01)
      Write-Host
      Write-Host "Build Complete!" -ForegroundColor Green
      Write-Host
      Write-Host "Optional Post-script Manual Configuration Steps" -ForegroundColor Gray
      Write-Host " - Configure Firewall" -ForegroundColor Gray
      Write-Host " - Install Test Web App (Run Post-Build Script on the IIS Server)" -ForegroundColor Gray
      Write-Host " - Install Backend resource (Run Post-Build Script on the AppVM01)" -ForegroundColor Gray
      Write-Host
```

### <a name="network-config-file"></a>ネットワーク構成ファイル

場所を更新して、この XML ファイルを保存します。 上記の完全なスクリプトで `$NetworkConfigFile` 変数を変更し、保存されたネットワーク構成ファイルにリンクします。

```xml
    <NetworkConfiguration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/ServiceHosting/2011/07/NetworkConfiguration">
      <VirtualNetworkConfiguration>
        <Dns>
          <DnsServers>
            <DnsServer name="DNS01" IPAddress="10.0.2.4" />
            <DnsServer name="Level3" IPAddress="209.244.0.3" />
          </DnsServers>
        </Dns>
        <VirtualNetworkSites>
          <VirtualNetworkSite name="CorpNetwork" Location="Central US">
            <AddressSpace>
              <AddressPrefix>10.0.0.0/16</AddressPrefix>
            </AddressSpace>
            <Subnets>
              <Subnet name="SecNet">
                <AddressPrefix>10.0.0.0/24</AddressPrefix>
              </Subnet>
              <Subnet name="FrontEnd">
                <AddressPrefix>10.0.1.0/24</AddressPrefix>
              </Subnet>
              <Subnet name="BackEnd">
                <AddressPrefix>10.0.2.0/24</AddressPrefix>
              </Subnet>
            </Subnets>
            <DnsServersRef>
              <DnsServerRef name="DNS01" />
              <DnsServerRef name="Level3" />
            </DnsServersRef>
          </VirtualNetworkSite>
        </VirtualNetworkSites>
      </VirtualNetworkConfiguration>
    </NetworkConfiguration>
```

## <a name="next-steps"></a>次の手順

この境界ネットワーク例に役立つ、サンプル アプリケーションをインストールできます。

> [!div class="nextstepaction"]
> [サンプル アプリケーション スクリプト](./virtual-networks-sample-app.md)

<!--Image References-->
[1]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/example3design.png "双方向 DMZ + NVA、NSG、および UDR"
[2]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/example3firewalllogical.png "ファイアウォール ルールの論理ビュー"
[3]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectfrontend.png "フロントエンド ネットワーク オブジェクトの作成"
[4]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectdns.png "DNS サーバー オブジェクトの作成"
[5]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectrdpa.png "既定の RDP ルールのコピー"
[6]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/createnetworkobjectrdpb.png "AppVM01 ルール"
[7]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/iconapplicationredirect.png "アプリケーション リダイレクト アイコン"
[8]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/icondestinationnat.png "送信先 NAT アイコン"
[9]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/iconpass.png "Pass アイコン"
[10]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/rulefirewall.png "ファイアウォール管理ルール"
[11]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/rulerdp.png "ファイアウォール RDP ルール"
[12]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleweb.png "ファイアウォール Web ルール"
[13]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleappvm01.png "ファイアウォール AppVM01 ルール"
[14]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleoutbound.png "ファイアウォール送信ルール"
[15]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruledns.png "ファイアウォール DNS ルール"
[16]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruleintravnet.png "ファイアウォール VNet 間ルール"
[17]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/ruledeny.png "ファイアウォール拒否ルール"
[18]: ./media/virtual-networks-dmz-nsg-fw-udr-asm/firewallruleactivate.png "ファイアウォール ルールのアクティブ化"

<!--Link References-->
[HOME]: ../best-practices-network-security.md
