---
title: インクリメンタル エンリッチメントの概念 (プレビュー)
titleSuffix: Azure Cognitive Search
description: AI エンリッチメント パイプラインからの中間コンテンツと増分変更を Azure Storage にキャッシュして、既存の処理済みドキュメントへの投資を維持します。 現在、この機能はパブリック プレビュー段階にあります。
manager: nitinme
author: Vkurpad
ms.author: vikurpad
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 06/18/2020
ms.openlocfilehash: 5596a2db32a0fe5b6b5eddf3ae20501e6edb0b99
ms.sourcegitcommit: 62e1884457b64fd798da8ada59dbf623ef27fe97
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/26/2020
ms.locfileid: "88935383"
---
# <a name="incremental-enrichment-and-caching-in-azure-cognitive-search"></a>Azure Cognitive Search のインクリメンタル エンリッチメントとキャッシュ

> [!IMPORTANT] 
> インクリメンタル エンリッチメントは現在、パブリック プレビューの段階です。 このプレビュー バージョンはサービス レベル アグリーメントなしで提供されています。運用環境のワークロードに使用することはお勧めできません。 詳しくは、[Microsoft Azure プレビューの追加使用条件](https://azure.microsoft.com/support/legal/preview-supplemental-terms/)に関するページをご覧ください。 [REST API バージョン 2019-05-06-Preview および 2020-06-30-Preview](search-api-preview.md) がこの機能を提供します。 現時点で、ポータルまたは .NET SDK はサポートされていません。

*インクリメンタル エンリッチメント*は[スキルセット](cognitive-search-working-with-skillsets.md)を対象とする機能です。 Azure Storage を活用して、今後のインデクサーの実行時に再利用するために、エンリッチメント パイプラインによる処理出力を保存します。 可能な限り、インデクサーはキャッシュされているすべての有効な出力を再利用します。 

インクリメンタル エンリッチメントにより、処理 (特に、OCR および画像処理) に対する金銭的投資を維持できるだけでなく、より効率的なシステムを実現できます。 構造とコンテンツがキャッシュされるときに、インデクサーは、どのスキルが変更されたかを判断し、変更されたスキルとそのダウンストリームの従属スキルのみを実行することができます。 

増分キャッシュを使用するワークフローには、次の手順が含まれます。

1. キャッシュを格納するための [Azure Storage アカウントを作成または識別します](../storage/common/storage-account-create.md)。
1. インデクサーで[インクリメンタル エンリッチメントを有効にします](search-howto-incremental-index.md)。
1. [インデクサー](/rest/api/searchservice/create-indexer)と[スキルセット](/rest/api/searchservice/create-skillset)を作成して、パイプラインを呼び出します。 処理中は、将来使用するために、エンリッチメントのステージが BLOB ストレージのドキュメントごとに保存されます。
1. コードをテストし、変更を行った後、[スキルセットの更新](/rest/api/searchservice/update-skillset)を使用して定義を変更します。
1. [インデクサーを実行](/rest/api/searchservice/run-indexer)してパイプラインを呼び出し、キャッシュされた出力を取得して高速でコスト効率の高い処理を実現します。

既存のインデクサーを使用する場合の手順と考慮事項の詳細については、[インクリメンタル エンリッチメントの設定](search-howto-incremental-index.md)に関する記事を参照してください。

## <a name="indexer-cache"></a>インデクサー キャッシュ

インクリメンタル エンリッチメントでは、エンリッチメント パイプラインにキャッシュが追加されます。 インデクサーは、ドキュメント解析から得られた結果に加え、ドキュメントごとの各スキルの出力をキャッシュします。 スキルセットが更新されたときには、変更済み (またはダウンストリーム) のスキルのみが再実行されます。 更新された結果がキャッシュに書き込まれ、検索インデックスまたはナレッジ ストア内のドキュメントが更新されます。

物理的には、キャッシュはご使用の Azure Storage アカウントの BLOB コンテナーに格納されます。 キャッシュでは、更新処理の内部レコードにテーブル ストレージも使用されます。 インデクサー キャッシュには、Search サービス内のすべてのインデックスが同じストレージ アカウントを共有できます。 それぞれのインデクサーには、使用しているコンテナーに対する一意かつ不変のキャッシュ識別子が割り当てられます。

## <a name="cache-configuration"></a>キャッシュの構成

インクリメンタル エンリッチメントによる恩恵を受けるためには、インデクサーの `cache` プロパティを設定する必要があります。 次の例は、キャッシュが有効になっているインデクサーを示しています。 この構成の特定の部分については、次のセクションで説明します。 詳細については、[インクリメンタル エンリッチメントの設定](search-howto-incremental-index.md)に関する記事を参照してください。

```json
{
    "name": "myIndexerName",
    "targetIndexName": "myIndex",
    "dataSourceName": "myDatasource",
    "skillsetName": "mySkillset",
    "cache" : {
        "storageConnectionString" : "Your storage account connection string",
        "enableReprocessing": true
    },
    "fieldMappings" : [],
    "outputFieldMappings": [],
    "parameters": []
}
```

既存のインデクサーでこのプロパティを設定する場合は、インデクサーをリセットして再実行する必要があります。これにより、データ ソース内のすべてのドキュメントが再度処理されます。 この手順は、以前のバージョンのスキルセットによってエンリッチされたドキュメントを排除するために必要です。 

## <a name="cache-management"></a>キャッシュ管理

キャッシュのライフサイクルは、インデクサーによって管理されます。 インデクサーの `cache` プロパティが null に設定されるか、接続文字列が変更された場合、既存のキャッシュはインデクサーの次回の実行時に削除されます。 キャッシュのライフサイクルは、インデクサーのライフサイクルにも関係しています。 インデクサーが削除されると、関連付けられているキャッシュも削除されます。

インクリメンタル エンリッチメントはユーザーの介入なしに変更を検出して対応するように設計されています。その一方で、既定の動作をオーバーライドするために使用できるパラメーターが用意されています。

+ 新しいドキュメントを優先する
+ スキルセットのチェックをバイパスする
+ データ ソースのチェックをバイパスする
+ スキルセットの評価を強制的に実行する

### <a name="prioritize-new-documents"></a>新しいドキュメントを優先する

キャッシュに既に示されている受信ドキュメントの処理を制御するには、`enableReprocessing` プロパティを設定します。 `true` (既定値) の場合、インデクサーを再実行すると、キャッシュ内に既にあるドキュメントが再処理されます。これは、スキルの更新によってそのドキュメントが影響を受けると仮定されるためです。 

`false` の場合、既存のドキュメントは再処理されず、新しい受信コンテンツが既存のコンテンツよりも実質的に優先されます。 `enableReprocessing` を `false` に設定するのは一時的な措置にしてください。 コーパス全体の整合性を確保するには、ほとんどの場合 `enableReprocessing` を `true` にして、現在のスキルセット定義に従って新規および既存のすべてのドキュメントを有効な状態にする必要があります。

### <a name="bypass-skillset-evaluation"></a>スキルセットの評価をバイパスする

通常、スキルセットの変更とそのスキルセットの再処理は連動します。 ただし、スキルセットを変更しても再処理が発生しない場合があります (たとえば、カスタム スキルを新しい場所にデプロイした場合や、新しいアクセス キーを使用した場合)。 ほとんどの場合、これらは、スキルセットの実体そのものに実際の影響を与えない末梢的な変更です。 

スキルセットに対する変更が実際は皮相的なものであることがわかっている場合は、`disableCacheReprocessingChangeDetection` パラメーターを `true` に設定して、スキルセット評価をオーバーライドする必要があります。

1. スキルセットの更新を呼び出し、スキルセット定義を変更します。
1. 要求に `disableCacheReprocessingChangeDetection=true` パラメーターを追加します。
1. 変更を送信します。

このパラメーターを設定すると、スキルセット定義に対する更新だけがコミットされ、変更が既存のコーパスに及ぼす影響は評価されません。

次の例は、このパラメーターを使用したスキルセットの更新要求を示しています。

```http
PUT https://customerdemos.search.windows.net/skillsets/callcenter-text-skillset?api-version=2020-06-30-Preview&disableCacheReprocessingChangeDetection=true
```

### <a name="bypass-data-source-validation-checks"></a>データ ソースの検証チェックをバイパスする

ほとんどの場合、データ ソース定義を変更すると、キャッシュが無効になります。 ただし、接続文字列の変更やストレージ アカウントのキーのローテーションなど、変更によってキャッシュが無効にならないことがわかっているシナリオでは、データ ソースの更新時に `ignoreResetRequirement` パラメーターを追加します。 このパラメーターを `true` に設定すると、リセット条件 (結果的にすべてのオブジェクトが最初から再構築されて設定される条件) をトリガーすることなく、コミットを実行できます。

```http
PUT https://customerdemos.search.windows.net/datasources/callcenter-ds?api-version=2020-06-30-Preview&ignoreResetRequirement=true
```

### <a name="force-skillset-evaluation"></a>スキルセットの評価を強制的に実行する

キャッシュの目的は不必要な処理を回避することにあります。ここで、インデクサーによって検出されない変更 (たとえば、カスタム スキルなどの外部コード内の変更) をスキルに加えるケースを考えてみましょう。

この場合は、[スキルのリセット](/rest/api/searchservice/preview-api/reset-skills)を使用して、特定のスキル (そのスキルの出力に依存するダウンストリームのスキルも含まれます) を強制的に再処理することができます。 この API は、無効にして再処理用にマークする必要があるスキルのリストが含まれた POST 要求を受け取ります。 スキルのリセット後、インデクサーを実行してパイプラインを起動します。

## <a name="change-detection"></a>変更検出

キャッシュを有効にすると、インデクサーによってパイプライン構成の変更が評価され、再利用できるコンテンツと再処理が必要なコンテンツが特定されます。 このセクションでは、キャッシュが完全に無効になる変更を示した後、増分処理がトリガーされる変更を示します。 

### <a name="changes-that-invalidate-the-cache"></a>キャッシュが無効になる変更

無効化につながる変更とは、キャッシュ全体の有効性が失われる変更をいいます。 たとえばデータ ソースの更新は、無効化につながる変更です。 以下、キャッシュが無効化される可能性のある変更をすべて列挙します。

* データ ソースの種類に対する変更
* データ ソース コンテナーに対する変更
* データ ソースの資格情報
* データ ソースの変更検出ポリシー
* データ ソースの削除検出ポリシー
* インデクサーのフィールドのマッピング
* インデクサーのパラメーター
    * 解析モード
    * ファイル名拡張子を除外
    * ファイル名拡張子のインデックスを作成
    * サイズの大きいドキュメントのストレージ メタデータのみのインデックスを作成
    * 区切りテキストのヘッダー
    * 区切りテキストの区切り記号
    * ドキュメントのルート
    * 画像操作 (画像の抽出方法に対する変更)

### <a name="changes-that-trigger-incremental-processing"></a>増分処理がトリガーされる変更

増分処理では、対象のスキルセット定義が評価された後、再実行する必要があるスキルが特定され、ドキュメント ツリーの影響を受ける部分が選択的に更新されます。 結果的にインクリメンタル エンリッチメントが発生する変更の完全な一覧を次に示します。

* スキルセットに種類の異なるスキルがある。 スキルの OData 型が更新された。
* スキルに固有のパラメーター (url、defaults など) が更新された。
* スキルの出力が変更 (スキルから返される出力が追加または変更) された。
* 先祖の変更を伴うスキルの更新があった。スキルのチェーン (つまりスキルの入力) が変更された。
* アップストリームのスキルが無効化された (このスキルへの入力となっているスキルが更新された場合)。
* ドキュメントの再プロジェクションを伴う更新がナレッジ ストアのプロジェクション場所に生じた。
* ドキュメントの再プロジェクションを伴う変更がナレッジ ストアのプロジェクションに生じた。
* インデックスに対するドキュメントの再プロジェクションを伴う変更が、インデクサーの出力フィールドのマッピングに生じた。

## <a name="api-reference"></a>API リファレンス

REST API バージョン `2020-06-30-Preview` では、インデクサーの追加のプロパティを使用して、インクリメンタル エンリッチメントが提供されます。 スキルセットとデータ ソースは、一般公開されているバージョンを使用できます。 API の呼び出し方法の詳細については、リファレンス ドキュメントに加えて、[インクリメンタル エンリッチメント用のキャッシュの構成](search-howto-incremental-index.md)に関するページを参照してください。

+ [インデクサーの作成 (api-version=2020-06-30-Preview)](/rest/api/searchservice/create-indexer) 

+ [インデクサーの更新 (api-version=2020-06-30-Preview)](/rest/api/searchservice/update-indexer) 

+ [スキルセットの更新 (api-version=2020-06-30)](/rest/api/searchservice/update-skillset) (要求での新しい URI パラメーター)

+ [スキルのリセット (api-version=2020-06-30)](/rest/api/searchservice/preview-api/reset-skills)

+ データベースのインデクサー (Azure SQL、Cosmos DB)。 一部のインデクサーでは、クエリを使用してデータを取得します。 データを取得するクエリ用に、[データ ソースの更新](/rest/api/searchservice/update-data-source)では、要求の新しいパラメーター **ignoreResetRequirement** がサポートされています。更新アクションによってキャッシュが無効にされないようにするには、これを `true` に設定する必要があります。 

  **ignoreResetRequirement** は慎重に使用してください。容易には検出できない不整合が意図せずデータに生じることがあります。

## <a name="next-steps"></a>次のステップ

インクリメンタル エンリッチメントは、変更の追跡をスキルセットと AI エンリッチメントに拡張する強力な機能です。 インクリメンタル エンリッチメントを使用すると、スキルセットの設計を反復処理する際に、既存の処理済みコンテンツを再利用できます。

次のステップとして、既存のインデクサーのキャッシュを有効にするか、新しいインデクサーを定義するときにキャッシュを追加します。

> [!div class="nextstepaction"]
> [インクリメンタル エンリッチメントのためのキャッシュの構成](search-howto-incremental-index.md)