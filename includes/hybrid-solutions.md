# <a name="azure-service-bus"></a>Azure Service Bus
クラウドで実行されるか、オンプレミスであるかを問わずアプリケーションまたはサービスは、一般的には他のアプリケーションまたはサービスと対話する必要があります。 この必要性に広範に対応するために、Azure には Service Bus が用意されています。 この記事ではこのテクノロジを中心に、その内容とそれを使用する理由について説明します。

## <a name="service-bus-fundamentals"></a>Service Bus の基礎
状況が異なれば、求められる通信のスタイルも異なります。 アプリケーションが単純なキューを介してメッセージを送受信する方法が最適なソリューションであることもあります。 逆に、通常のキューでは不十分で、発行とサブスクライブのメカニズムを備えたキューを使用する方が適していることもあります。 場合によっては、アプリケーション間の接続のみが必要で、キューは不必要なこともあります。 Service Bus はこれらの 3 つのオプションすべてを提供し、アプリケーションがさまざまな方法で対話できるようにします。

Service Bus は、サービスが複数のユーザーによって共有されるマルチテナント クラウド サービスです。 各ユーザー (たとえば、アプリケーション開発者) は、 *名前空間*を作成し、その名前空間内で必要な通信メカニズムを定義します。 [図 1](#Fig1) に、このしくみを示します。

<a name="Fig1"></a>![Azure Service Bus の図][svc-bus]

**図 1: Service Bus は、クラウドを介してアプリケーションを接続するためのマルチテナント サービスを提供する**

名前空間内では、4 つの異なる通信メカニズムの 1 つまたは複数のインスタンスを使用して、それぞれ異なる方法でアプリケーションを接続できます。 選択肢は以下のとおりです。

* *キュー*: 一方向の通信を提供します。 それぞれのキューは、送信されたメッセージが受信されるまでメッセージを格納する仲介者 ( *ブローカー*とも呼ばれます) として動作します。 各メッセージは単一の受信者が受信します。
* "*トピック*": "*サブスクリプション*" を使用して一方向の通信を提供します。1 つのトピックは複数のサブスクリプションを含むことができます。 キューと同様、トピックはブローカーとして動作しますが、必要に応じて、各サブスクリプションはフィルターを使用して特定の条件に一致するメッセージのみを受信できます。
* *リレー*: 双方向の通信を提供します。 キューやトピックと異なり、リレーはブローカーではなく、転送中のメッセージを格納しません。 送信先のアプリケーションにメッセージを渡すのみです。
* *Event Hubs*: クラウドへの大規模なイベントとテレメトリ受信をわずかな遅延と高い信頼性で提供します。

作成したキュー、トピック、リレー、または Event Hubs には名前を付けます。 名前空間に付けた名前とこの名前の組み合わせが、オブジェクトの一意の識別子となります。 この名前を Service Bus に通知すると、アプリケーションは、キュー、トピック、リレー、または Event Hubs を使用して通信を行うことができます。 

これらのいずれかのオブジェクトを使用するために、Windows アプリケーションは Windows Communication Foundation (WCF) を使用できます。 キュー、トピック、Event Hubs に対しては、Windows アプリケーションは、Service Bus によって定義されたメッセージング API を使用することもできます。 これらのオブジェクトを Windows 以外のアプリケーションから簡単に使用できるようにするために、マイクロソフトでは Java、Node.js 向け、また多言語の SDK を提供しています。 また、REST API over HTTP を使用して、キュー、トピック、Event Hubs にアクセスすることもできます。 

Service Bus 自体はクラウド (つまり、Microsoft の Azure データセンター) で実行されますが、Service Bus を使用するアプリケーションはどのような場所でも実行できることを理解しておいてください。 Service Bus を使用すると、たとえば、Azure 上で実行されているアプリケーションや、自社のデータセンター内で実行されているアプリケーションを接続できます。 Azure または他のクラウド プラットフォーム上で実行されているアプリケーションを、オンプレミスのアプリケーション、タブレット、または携帯電話と接続することもできます。 さらに、家電製品、センサーなどのデバイスを中央アプリケーションに接続したり、デバイスを相互接続したりできます。 Service Bus は、あらゆる場所から利用できる、クラウドを使った汎用通信メカニズムです。 Service Bus の利用方法は、アプリケーションで何を行う必要があるかによって決まります。

## <a name="queues"></a>キュー
Service Bus キューを使用して 2 つのアプリケーションを接続するとします。 [図 2](#Fig2) に、この状況を示します。

<a name="Fig2"></a>![Service Bus キューの図][queues]

**図 2: Service Bus キューは一方向の非同期キューを提供する**

この場合のプロセスは単純です。送信者がメッセージを Service Bus キューに送信すると、受信者が後でそのメッセージを取得します。 [図 2](#Fig2) に示すように、キューの受信者は 1 つのみです。また、複数のアプリケーションが同じキューから読み取ることもできます。 後者のケースでは、各メッセージは 1 つの受信者によって読み取られます。マルチキャスト サービスでは、代わりにトピックを使用する必要があります。

それぞれのメッセージは、2 つの部分から構成されます。つまり、それぞれがキーと値のペアであるプロパティのセットと、バイナリ メッセージ本文です。 これらの使用方法は、アプリケーションの目的によって決まります。 たとえば、最近の売り上げに関するメッセージを送信するアプリケーションでは、*Seller="Ava"*、*Amount=10000* といったプロパティが含まれます。 メッセージ本文には、たとえば営業部の署名済みの契約書のスキャン画像を含めることが考えられます。画像がない場合はメッセージ本文が空になります。

受信者は、2 つの異なる方法で Service Bus キューからメッセージを読み取ることができます。 1 つのオプションは *ReceiveAndDelete* です。このオプションでは、メッセージをキューから取り出した直後に削除します。 この方法は単純ですが、メッセージを処理する前に受信者がクラッシュした場合はメッセージが失われます。 メッセージはキューから削除されているため、他の受信者がメッセージにアクセスすることもできません。 

もう 1 つのオプションである *PeekLock* は、この問題に対処できます。 ReceiveAndDelete と同様、PeekLock 読み取りを実行すると、メッセージがキューから削除されます。 ただし、実際に削除する前に、 メッセージをロックして他の受信者が認識できないようにして、次の 3 つのイベントのいずれかの発生を待ちます。

* 受信者がメッセージを正常に処理し、 *Complete*を呼び出すと、キューのメッセージが削除されます。 
* 受信者がメッセージを正常に処理できないと判断すると、 *Abandon*を呼び出します。 すると、キューのメッセージのロックが解除され、他の受信者がメッセージを取得できるようになります。
* 受信者が一定の時間内 (構成可能、既定では 60 秒) にどちらも呼び出さなかった場合、その受信者は失敗したと見なされます。 その場合、その受信者が Abandon を呼び出した場合と同様に処理され、他の受信者がメッセージを取得できるようになります。

ここで考えられるのは、同じメッセージが 2 回、2 つの異なる受信者に配信される可能性があることです。 そのため、Service Bus キューを使用するアプリケーションでは、この問題に対処する必要があります。 重複の検出を容易にするために、各メッセージは一意の MessageID プロパティを持ちます。このプロパティは、メッセージがキューから何回読み取られようとも、既定で同じ値に保持されます。 

キューは、さまざまな状況で利用できます。 同時に実行されていないアプリケーション間でも相互に通信することができます。これは、バッチおよびモバイル アプリケーションで特に便利な機能です。 受信者が複数のキューでは、送信されたメッセージが受信者に分散されるため、自動負荷分散も実現されます。

## <a name="topics"></a>トピック
キューは、便利ではありますが、常に適切なソリューションとは限りません。 Service Bus トピックの方が適切な場合もあります。 [図 3](#Fig3) に、その理由を示します。

<a name="Fig3"></a>![Service Bus トピックとサブスクリプションの図][topics-subs]

**図 3: サブスクライブ アプリケーションが指定するフィルターに基づき、サービス バス トピックに送信された一部またはすべてのメッセージを受信できる**

トピックは、多くの点でキューに似ています。 送信者は、キューに送信する場合と同じ方法でメッセージをトピックに送信します。これらのメッセージは、キューの場合と同じに見えます。 大きな違いは、トピックでは、受信側アプリケーションごとに "*フィルター*" を定義することで独自のサブスクリプションを作成できる点です。 サブスクライバーは、そのフィルターに一致するメッセージのみを識別します。 [図 3](#Fig3) に、1 つの送信者と、3 つのサブスクライバーを持つトピックの例を示します。各サブスクライバーにはそれぞれ独自のフィルターが設定されています。

* サブスクライバー 1 は、 *Seller="Ava"*というプロパティを含むメッセージのみを受信します。
* サブスクライバー 2 は、*Seller="Ruby"* というプロパティを含むか、*Amount* プロパティの値が 100,000 を超えるメッセージを受信します。 Ruby はセールス マネージャーであるため、自分の売り上げと、担当者を問わずすべての大きな売り上げを確認することを目的としています。
* サブスクライバー 3 ではそのフィルターが *True* に設定されています。これは、すべてのメッセージを受信することを表します。 このアプリケーションは、たとえば監査証跡を維持する目的で使用されることが考えられるため、すべてのメッセージを認識する必要があります。

キューの場合と同様、トピックのサブスクライバーは、ReceiveAndDelete または PeekLock を使用してメッセージを読み取ることができます。 ただし、キューとは異なり、1 つのトピックに送信された 1 つのメッセージを複数のサブスクライバーで受信できます。 この手法は一般的に *発行とサブスクライブ*と呼ばれ、同じメッセージを複数のアプリケーションで利用する可能性がある場合に便利です。 適切なフィルターを定義することで、各サブスクライバーは、メッセージ ストリームの中で認識する必要がある部分のみを利用できます。

## <a name="relays"></a>リレー
キューとトピックは、どちらもブローカーを介して一方向の非同期通信を提供します。 トラフィックは一方向に流れ、送信者と受信者の間に直接的な接続はありません。 しかし、それが適切でない状況もあります。 アプリケーションがメッセージの送受信を行う必要がある場合や、アプリケーション間の直接リンクが必要な場合、メッセージを格納する場所はブローカーに必要ありません。 このようなシナリオに対応するために、 [図 4](#Fig4) に示すように、Service Bus にはリレーが用意されています。

<a name="Fig4"></a>![Service Bus Relay の図][relay]

**図 4: Service Bus Relay はアプリケーション間の同期双方向通信を提供する**

リレーに関する素朴な疑問は、なぜリレーを使用するのか、ということでしょう。 キューが不要な場合でも、アプリケーションが直接対話するのではなくクラウド サービス経由で通信を行うのはなぜでしょうか。 それは、直接的な通信が思いのほか難しいためです。

たとえば、会社の別々のデータセンター内で実行されている 2 つのオンプレミスのアプリケーションを接続するとします。 どちらのアプリケーションもファイアウォールの背後に配置され、それぞれのデータセンターでネットワーク アドレス変換 (NAT) が使用されているとします。 ファイアウォールにより、特定のポート以外のポートの着信データはすべてブロックされます。また、NAT が使用されているということは、それぞれのアプリケーションが実行されているコンピューターにデータセンターの外部から直接アクセスできる固定 IP アドレスが割り当てられていないことを意味します。 特別な手段がなければ、2 つのアプリケーションをパブリックなインターネット経由で接続することは困難です。

Service Bus Relay は、この問題を解決するのに役立ちます。 リレーを介して双方向の通信を行うために、それぞれのアプリケーションは Service Bus との間で送信 TCP 接続を確立し、接続を開いたまま保持します。 2 つのアプリケーション間のすべての通信はこの接続を介して行われます。 それぞれの接続はデータセンター内から確立されているため、ファイアウォールは、新しいポートを開くことなく、各アプリケーションへの着信トラフィックを許可します。 この方法では、各アプリケーションは通信においてクラウドに一貫したエンドポイントを持つため、NAT の問題にも対処できます。 リレーを介してデータを交換することで、アプリケーションは、それ以外の方法では通信を困難にする問題を回避できます。 

Service Bus リレーを使用する場合、アプリケーションは Windows Communication Foundation (WCF) に依存します。 Service Bus には WCF バインディングが用意されているため、Windows アプリケーションは容易にリレー経由で対話できます。 通常、WCF を既に使用しているアプリケーションでは、これらのバインディングのいずれかを指定するだけで、リレーを介して他のアプリケーションと通信を行うことができます。 非 Windows アプリケーションからリレーを使用することもできますが、キューやトピックとは異なり、プログラム上の工夫が必要になります。標準ライブラリは用意されていません。

キューやトピックとは異なり、アプリケーションは明示的にリレーを作成しません。 リレーは、メッセージを受信する側のアプリケーションが Service Bus との間に TCP 接続を確立したときに自動的に作成されます。 接続がドロップされると、リレーは削除されます。 特定のリスナーによって作成されたリレーをアプリケーションが検出できるようにレジストリが用意されており、アプリケーションは特定のリレーを名前で見つけることができます。

リレーは、アプリケーション間の直接的な通信が必要な場合に適したソリューションです。 たとえば、オンプレミスのデータセンターで実行される航空券予約システムがあるとします。このシステムには、たとえばチェックイン受付機、モバイル デバイス、その他のコンピューターからアクセスできる必要があります。 これらのすべてのシステムで実行されているアプリケーションが、クラウド上の Service Bus リレーを使用して、実行中は常時通信することができます。

## <a name="event-hubs"></a>Event Hubs
Event Hubs は、毎秒数百万件の処理が可能な高度にスケーラブルなインジェスト システムです。これを使用するアプリケーションは、接続するデバイスとアプリケーションで生成される大量のデータを処理と分析できます。 Event Hubs を使用すると、たとえばすべての保有車のエンジン パフォーマンスの生データを収集できます。 Event Hubs に収集されたデータは、任意のリアルタイム分析プロバイダーやストレージ クラスターを使用して転送と格納できます。 Event Hubs の詳細については、[Event Hubs の概要][Event Hubs overview]に関する記事を参照してください。

## <a name="summary"></a>概要
アプリケーションへの接続は常に完全なソリューション構築の一部であり、インターネットに接続するアプリケーションやデバイスの数が増えるほど、アプリケーションまたはサービス間の相互の通信を必要とするシナリオの範囲も拡がります。 Service Bus は、キュー、トピック、リレー、Event Hubs を介してアプリケーションの接続を実現するクラウド ベースのテクノロジを提供し、この必須の機能をより簡単に、より広範に利用できるようにすることを目的としています。

[svc-bus]: ./media/hybrid-solutions/SvcBus_01_architecture.png
[queues]: ./media/hybrid-solutions/SvcBus_02_queues.png
[topics-subs]: ./media/hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[relay]: ./media/hybrid-solutions/SvcBus_04_relay.png
[Event Hubs overview]: https://msdn.microsoft.com/library/azure/dn836025.aspx


<!--HONumber=Jan17_HO3-->


